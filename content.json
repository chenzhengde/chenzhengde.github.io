{"pages":[],"posts":[{"title":"CAN201 W4","text":"This’s the note of introduction to networking Week4.This week we will talk about the transport layer in networking system. 传输层 Roadmap Transport-layer services Multiplexing and demultiplexing Connectionless transport: UDP Principles of reliable data transfer LectureTransport-layer servicesTransport services and protocols Provide logical communication between app processes running on different hosts Transport protocols run in end systems Send side: breaks app msg into segments, passes to network layer 发送端:将应用程序消息分成段，传递到网络层 Rcv side: reassembles segments into messages Rcv端:将段重组为消息 Transport-layer protocols for Internet: TCP and UDP Network layer: logical communication between hosts 网络层:主机之间的逻辑通信。 Transport layer: logical communication between processes: Relies on, enhances, network layer services. 传输层:进程之间的逻辑通信:依赖、增强网络层服务。假如把信息的传递表示称Ann家12个孩子和Bill家12个孩子的通信，那么Transport protocol就是Ann和Bill家负责收集和分发12封信的服务，而Network-layer protocol则是家庭与家庭之间的邮政服务。 Internet transport-layer protocols Reliable, in-order delivery (TCP) 可靠，有序交付 Congestion control 拥塞控制 Flow control 流量控制 Connection setup 建立连接 Unreliable, unordered delivery: UDP 不可靠，无序交付 多路复用解复用 No-frills extension of “best-effort” IP “尽最大努力”IP的无虚饰扩展 Services not available: 服务不可用 TCP和UDP都不可以 Delay guarantees 延迟保证 Bandwidth guarantees 带宽保证 Multiplexing and demultiplexing 多路复用和解复用How demultiplexing works Host receives IP datagrams 主机接收IP数据报 Each datagram has source IP address, destination IP address 每个数据报都有源IP地址、目的IP地址 Each datagram carries one transport-layer segment 每个数据报携带一个传输层段 Each segment has source, destination port number 每个段都有源端口号、目的端口号 Host uses IP addresses &amp; port numbers to direct segment to suitable socket 主机使用IP地址和端口号直接段到合适的套接字 Connectionless transport: UDPUDP: User Datagram ProtocolFeature: Simple and straightforward Best effort Lost Connectionless No handshaking Each UDP segment handled independently of others: Out-of-order to APP UDP use: Streaming multimedia apps DNS Reliable transfer over UDP: Add reliability at application layer Application-specific error recovery UDP: segment header UDP checksumGoal: detect “errors” in transmitted segment 检测传输段中的“错误”Sender: Treat segment contents, including header fields, as sequence of 16-bit integers 将段内容(包括报头字段)作为16位整数序列处理 Checksum: addition (one’s complement sum) of segment contents 校验和:段内容的添加(一个的补和) 负责检查传输有没有出错 Sender puts checksum value into UDP checksum field 发送端将校验和值放入UDP校验和字段 Receiver: Compute checksum of received segment 计算接收报文段的校验和 Check if computed checksum equals checksum field value: 检查计算的checksum是否等于checksum字段值: NO - error detected YES - no error detected. But maybe errors nonetheless? Principles of reliable data transfer可靠数据传输的原理，参见书和ppt。 Lab1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# clientimport jsonfrom socket import *import argparsedef _argparse(): parser = argparse.ArgumentParser(description=&quot;This is description!&quot;) parser.add_argument('--ip', action='store', required=True, dest='ip', help='IP address') parser.add_argument('--input', type=str, required=True, dest='input', help='The path of input file') parser.add_argument('--port', type=int, required=True, dest='port', help='The port of server') return parser.parse_args()def main(): parser = _argparse() server_name = parser.ip server_port = parser.port clientSocket = socket(AF_INET, SOCK_STREAM) clientSocket.connect((server_name, server_port)) clientSocket.send(parser.input.encode()) feedback_command = clientSocket.recv(20480).decode() feedback = json.loads(feedback_command) print(feedback) clientSocket.close()if __name__ == '__main__': main()# serverimport jsonfrom socket import *import argparsedef _argparse(): parser = argparse.ArgumentParser(description=&quot;This is description!&quot;) parser.add_argument('--ip', action='store', required=True, dest='ip', help='IP address') parser.add_argument('--input', type=str, required=True, dest='input', help='The path of input file') parser.add_argument('--port', type=int, required=True, dest='port', help='The port of server') return parser.parse_args()def main(): parser = _argparse() server_port = parser.port server_socket = socket(AF_INET, SOCK_STREAM) server_socket.bind(('', server_port)) server_socket.listen(2) print('The server is ready to receive') while True: connectionSocket, addr = server_socket.accept() receive_command = connectionSocket.recv(20480).decode() receive_message = json.loads(receive_command) print(receive_message) print(type(receive_message)) connectionSocket.send(parser.input.encode()) connectionSocket.close()if __name__ == '__main__': main()","link":"/2021/10/02/CAN201-W4/"},{"title":"CPT203 W4","text":"The objectives of this week: understand the concepts of user and system requirements and why these requirements should be written in different ways; understand the differences between functional and nonfunctional software requirements; understand how requirements may be organized in a software requirements document; understand the principal requirements engineering activities of elicitation, analysis and validation, and the relationships between these activities; LectureSOFTWARE PROCESS Software Specification (This is what we mainly discussed about.) Software Design and Implementation Software Validation Software Evolution BACKGROUND The requirements for a system are the descriptions of what the system should do reflect the needs of customers for a system 系统的需求是对系统应该做什么的描述，反映了客户对系统的需求 The process of finding out, analyzing, documenting and checking these needs and constraints is called requirements engineering (RE) 发现、分析、记录和检查这些需求和约束的过程称为需求工程 The requirements can be described in a high-level, abstract statement of a service that a system should provide or a constraint on a system. At the other extreme, it is a detailed, formal definition of a system function. 需求可以在系统应该提供的服务或系统约束的高级抽象声明中描述。在另一个极端，它是详细的、正式的系统功能定义。 USER REQUIREMENTS AND SYSTEM REQUIREMENTS High-level description or detail description? 高级描述还是详细描述? As part of a contract for a large software development project, it must define its needs in a sufficiently abstract way 作为大型软件开发项目合同的一部分，它必须以一种足够抽象的方式定义其需求 Once a contract has been awarded, the contractor must write a system definition for the client in more detail so that the client understands and can validate what the software will do 一旦合同被授予，承包商必须为客户编写更详细的系统定义，以便客户理解并能够验证软件将做什么 Different level of details serve different purpose. User requirements and system requirements 不同层次的细节服务于不同的目的。用户需求和系统需求 User requirements - Statements in a natural language plus diagrams to describe the services and constraint of a system 用户需求:用自然语言加上图表来描述系统的服务和约束 System requirements - more detailed descriptions of the software system’s functions, services, and operational constraint 系统需求:对软件系统功能、服务和操作约束的更详细的描述 Requirements should state what the system should do and the design should describe how it does this. 需求应该说明系统应该做什么，设计应该描述它是如何做的。 User Requirements: Client Managers System End-Users Client Engineers Contractor Managers System Architects System Requirements: System End-Users Client Engineers System Architects Software Developers FUNCTIONAL &amp; NON-FUNCTIONAL REQUIREMENTS Software system requirements are often classified as functional requirements or nonfunctional requirements: Functional requirements: These are statements of services the system should provide. How the services should react and behave in certain condition. In some cases, the functional requirements may also explicitly state what the system should not do. 功能需求这些是系统应该提供的服务声明。服务在特定条件下应该如何反应和行为。在某些情况下，功能需求还可能明确说明系统不应该做什么。 Non-functional requirements: These are constraints on the services or functions offered by the system. Non-functional requirements often apply to the system as a whole, rather than individual system features or services. 非功能需求这些是对系统提供的服务或功能的约束。非功能性需求通常作为一个整体应用于系统，而不是单独的系统特性或服务。 The distinction between different types of requirement is not as clear-cut as these simple definitions suggest. 不同类型的需求之间的区别并不像这些简单定义所暗示的那样明确。 我觉得这样翻译ppt没有什么作用，主要的还是自己去看和理解吧。。。要是有空我再把这部分补上。 说一说use case diagram的事。在use case图中，中间的矩形代表的是app部分。左右两边的小人代表的是这个程序的使用者，而中间的圆形则代表的了程序中发生的事件。箭头的指向则代表了人物参加app中的此项活动进行。然而由于一个app中会有不同的事件发生。事件的关系一般有四种： association include extend generalization 假如A事件发生之后B事件一定会发生(属于A事件的子事件)，这种情况我们用虚线箭头从父事件连接子事件，并加上include，假如B事件发生之后A事件可能会发生，也可能不发生，我们用箭头从extend use case连接到base use case上，虚线上写上extend。Extend points是主要事件的细节解释。教你怎么画用例图（use case diagram） References XJTLU CPT203 slides (Week4) 教你怎么画用例图（use case diagram）","link":"/2021/09/29/CPT203-W4/"},{"title":"CPT205 W4","text":"This is the note of CPT205 Week5 Transformation Pipeline and Geometric Transformations 转换管道和几何转换 Transformation pipeline 转换管道 Standard transformations Translation 翻译 Rotation 旋转 Scaling 扩展 Reflection 反射 Shearing 剪切 Homogeneous co-ordinate transformation matrices 齐次坐标变换矩阵 Composite (arbitrary) transformation matrices from simple transformations 复合(任意)变换矩阵由简单变换 OpenGL functions for transformations 转换的OpenGL函数 LectureTransformation pipeline 转换管道 The Transformation Pipeline is the series of transformations (alterations) that must be applied to an object before it can be properly displayed on the screen. 转换管道是一系列转换(更改)，在对象可以正确地显示在屏幕上之前，必须对其应用。 The transformations can be thought of as a set of processing stages. If a stage is omitted, very often the object will not look correct. For example if the projection stage is skipped then the object will not appear to have any depth to it. 可以将转换视为一组处理阶段。如果省略了stage，对象通常看起来就不正确。 Once an object has passed through the pipeline it is ready to be displayed as either a wire-frame item or as a solid item. 一旦对象通过了管道，就可以将其显示为线框项目或实体项目。 Modelling Transformation - to place an object into the Virtual World. 建模转换：将一个对象放入虚拟世界。 Viewing Transformation - to view the object from a different vantage point in the virtual world. 观察变换-从虚拟世界的不同角度观察物体。 Projection Transformation - to see depth in the object. 投影变换-看到物体的深度。 Viewport Transformation - to temporarily map the volume defined by the “window of interest” plus the front and rear clipping planes into a unit cube. When this is the case, certain other operations are easier to perform. 视口变换-临时映射由“感兴趣的窗口”定义的体积，加上前面和后面的裁剪平面到一个单元立方体。在这种情况下，某些其他操作更容易执行。 Device Transformation - to map the user defined “window of interest” (in the virtual world) to the dimensions of the display area. 设备转换-将用户定义的“感兴趣的窗口”(在虚拟世界中)映射到显示区域的尺寸。 Purpose: 当对象从文件加载并准备好被处理时启动。当对象准备好要显示在计算机屏幕上时，我们就完成了。能够画出一个简单物体的图像，比如一个长方体，并直观地显示当它通过每个管道阶段时发生了什么。 Types of geometric transformation 2D translation向量形式 Translating a point from P(x, y) to P’(x’, y’) along vector T Importance in computer graphics – we need to only transform the two endpoints of a line segment and let the implementation draw the line segment between the transformed endpoints 矩阵形式where P(x, y) and P’(x’, y’) are the original and new positions, and T is the distance translated.吐槽：矩阵不就nm是向量吗？向量不就nm是矩阵吗？ 2D rotationRotating a point from P(x, y) to P’(x’, y’) about the origin by angle θ - radius stays the same, and angle increases by θ. 将一个点从P(x, y)旋转到P'(x', y')，绕原点旋转角度θ -半径不变，角度增加θ。where θ is the rotation angle and φ is the angle between the x-axis and the line from the origin to (x,y). θ是旋转角度，φ是x轴和向(x,y)的向量的角度。 Rotation about a fixed point rather than the origin. 绕不动点而不是原点旋转。 Move the fixed point to the origin 把不动点移到原点的位置 Rotate the object 选择对象 Move the fixed point back to its initial position 将固定点移回初始位置 M = T(pf) R(θ) T(-pf) 2D scalingWhen an object is scaled, both the size and location change. 就是把横坐标和纵坐标扩大相应的倍数。where P, and P’ are the original and new positions, and sx and sy (是x和y的变化比例) are the scaling factors along the x- and y-axes. 2D reflectionSpecial case of scaling - corresponding to negative scale factors. 2D shearingEquivalent to pulling faces in opposite directions. 相当于向相反的方向拉长面。假设simple shearing是沿着x轴的: 2D homogeneous co-ordinates在2D的平面上，平移是矩阵相加，旋转和缩放时矩阵相乘，因为这样太多麻烦，所以设计出了homogeneous coordinates，而它的目的只是为了更加方便地去用矩阵来计算图形的变换。那什么是齐次坐标呢？其实就是在原来2D的维度，再加上一个新的维度，多出来的维度的值永远是1 2D composite transformationwhere elements rs are the multiplicative rotation-scaling terms in the transformation (which involve only rotation angles and scaling factors); elements trs are the translation terms, containing combination of translation distances, pivot-point and fixed- point co-ordinates, rotation angles and scaling parameters. 式中元素rs为变换中的乘性旋转缩放项(只涉及旋转角度和缩放因子); 元素TRS是平移术语，包含平移距离、轴心点和定点坐标、旋转角度和缩放参数的组合。 3D translation3D translations and scaling can be simply extended from the corresponding 2D methods. 3D co-ordinate axis rotations从2D旋转方法扩展到3D旋转不那么简单(因为这是关于任意轴而不是任意点)。等价于在二维平面上以常数z(即绕原点)旋转。 General rotation about the originq绕任意轴的旋转可以分解为绕x、y和z轴的串联旋转。R(q) = Rz(qz) Ry(qy) Rx(qx)其中qx qy qz是欧拉角。旋转不能互换，尽管我们可以使用另一种顺序但不同角度的旋转。 3D scaling 3D composite transformation As with 2D transformation, a composite 3D transformation can be formed by multiplying the matrix representations for the individual operations in the transformation sequence. 与2D变换一样，通过将变换序列中各个操作的矩阵表示相乘，可以形成一个复合的3D变换。 There are other forms of transformation, namely reflection and shearing which can be implemented with the other three transformations. 还有其他形式的转换，即反射和剪切，可以与其他三种转换一起实现。 Translation, scaling, rotation, reflection and shearing are all affine transformations in that transformed point P’(x’,y’,z’) is a linear combination of the original point P(x,y,z). 平移，缩放，旋转，反射和剪切都是仿射变换，变换点P’(x’，y’，z’)是原始点P(x,y,z)的线性组合。 矩阵乘法没有交换律，但是有结合律。在建模中，我们通常从一个简单的物体开始，该物体以原点为中心，以一个轴为方向，并且具有标准尺寸。 OpenGL matrices见学校课件 Lab有空更新 Reference XJTLU slides CPT205 (Week4) 2D平面中关于矩阵（Matrix）跟图形变换的讲解","link":"/2021/09/28/CPT205-W4/"},{"title":"INT201 W3","text":"It’s the note of week3. (INT201 W3) LectureRegular expressions 正则表达式A regular expression (r.e.) is a way of describing a language. It can consist of a finite set of words {cat, dog, mouse, ε} which represents the 4 words that are listed. 正则表达式是描述语言的一种方式，它可以由一组有限的单词组成。 Then, there are 3 operators that can appear in r.e’s: they are 有3个操作符可以出现在re中 Union Concatenation Closure these operators allow you to glue together subexpressions to form larger expression. 这些操作符允许您将子表达式粘在一起，形成更大的表达式。 Union and ConcatenationUnion: Any r.e. represnets a set of words (its language) and we may use ∪ to connect 2 subexpressions into a larger regular expression {cat, dog, mouse, ε} ∪ {cat, cats} which represents the 5 words ε, cat, cats, dog, mouse. 就是一般的并集。 Concatenation: By joining two r.e’s together, we denote the set of words you can make by taking a word from the first r.e. and concatenating it to some word from the second r.e.,{over, under}{cooked, state, rate} denotes the words overcooked, undercooked, overstate, understate, overrate, underrate. 就是把两边的单词合并的集合。有先后次序的区别，**+就是union，乘号就是concatenation**。 Closure: If we take a regular expression and add the superscript *, we get a new r.e. that represents the set of all words you can make by taking any sequence of words from the original r.e. and concatenating them together. ({cat })∗ denotes the words ε, cat, catcat, catcatcat, catcatcatcat, ...Notice that using closure, you can define an infinite language! 注意，使用闭包，您可以定义无限语言! Common extensions to the notation 符号的通用扩展Let E denote a regular expression. (E)n denotes concatenations of n words generated by E. (Could be written EEE…E(n times)) 多次重复E (E)+ denotes concatenations of at least one word generated by E (Could be written EE∗ or E∗E). 由E生成的至少一个单词的连接 The above give no extra expressive power in terms of what languages can be described. Lexical tokens 词法记号We can use regular expressions for short, precise definitions of lexical tokens:“variable: string of letters/digits starting with a letter” r.e.: {a,b,...,z,A,B,...,Z} {a,b,...,z,A,B,...,Z, 0,1,2,...9}∗number in exponential/scientific notation 指数/科学记数法 (“1.16121122E-03” denotes 1.16121122 × 10−3, i.e. 0.00116121122): {1, 2, 3, ..., 9}.{0, 1, 2, ..., 9}8E{00,{ε, −}{{1, 2, ..., 9}{0, 1, 2, ..., 9}, {0, 1, 2, ..., 9}{1, 2, ..., 9}}} A language that is easier to describe using a regular expression.A language that is easier to describe using a DFA. Equivalences amongst regular expressions Reference XJTLU slides (INT201 W3)","link":"/2021/09/24/INT201-W3/"},{"title":"CPT205 W3","text":"This’s week we will discuss about Geometric Primitives. (几何图元)Applications Packages Tools –&gt; API Library –&gt; Algorithms Techniques Graphics Primitives Points Lines Polygons 多边形 Line Algorithms Digital Differential Analyser (DDA) Bresenham Algorithm Circles Antialiasing 反锯齿 Polygon Fill 多边形填充 Graphics Primitives with OpenGL glBegin(GL_POINTS); glBegin(GL_LINES) glBegin(GL_POLYGON); glBEgin(GL_QUAD) Lecture“Good” discrete lines 离散线 No gaps in adjacent pixels Pixels close to ideal line Consistent choices; same pixels in same situations Smooth looking Even brightness in all orientations Same line for P0P1 as for P1P0 Double pixels stacked up? Line algorithmsDrawing a hrizontal line from (x1,y) to (x2,y) are below DDADDA is digital differential algorithm Generation of circles略过 Lineraster points 栅格点: 就是一般的点jaggies 锯齿: 把点根据标准线连接在一起pixel space 像素空间: 这条线所占据的像素格 Antialiasing by area averaging通过面积平均反锯齿Colour multiple pixels for each x depending on coverage by ideal line.根据理想线的覆盖范围，为每个x的多个像素着色。 Geometric primitives 几何基本-多边形和三角形 The basic graphics primitives are points, lines and polygons 基本的图形原语是点、线和多边形 A polygon can be defined by an ordered set of vertices 一个多边形可以被定义为一组有序顶点的集合 Graphics hardware is optimised for processing points 图形硬件优化处理点 Complex objects are eventually divided into triangular polygons (a process called tessellation) 复杂的物体最终被分割成三角形的多边形 Because triangular polygons are always flat 三角形的多边形总是平的 Scan conversion 自动转换 also called rasterization 栅格化 The 3D to 2D projection givens us 2D vertices (points). Polygon fill 多边形填充 Rasterize edges into framebuffer. Find a seed pixel inside the polygon. Visit neighbours recursively and colour if they are not edge pixels. When vertices lie on the scanlines, cases (a) and (b) must be treated differently when using odd-even fill definition Case (a): zero or two crossings Case (b): one edge crossing Geometric primitives in OpenGLglBegin (prametres) GL_POINTS: individual points GL_LINES: pairs of vertices interpreted as individual line segments GL_LINE_STRIP: series of connected line segments GL_LINE_LOOP: same as above, with a segment added between last and first vertices GL_TRIANGLES: triples of vertices interpreted as triangles GL_TRIANGLE_STRIP: linked strip of triangles GL_TRIANGLE_FAN: linked fan of triangles GL_QUADS: quadruples of vertices interpreted as four-sided polygons GL_QUAD_STRIP: linked strip of quadrilaterals GL_POLYGON: boundary of a simple, convex polygon GL_POINTS123456// this code will draw a point located at (100,100)glBegin(GL_POINTS); glVertex2f(100.0f, 100.0f); ... // add more points if required glEnd( ); GL_LINES123456// this code will draw a line at starting and ending // coordinates specified by glVertex2fglBegin(GL_LINES); glVertex2f(100.0f, 100.0f); // origin of line glVertex2f(200.0f, 140.0f); // end point of lineglEnd( ); How to make lines efficient?1234567// this code will draw two lines &quot;at a time&quot; to save the time it takes to call glBegin and glEndglBegin(GL_LINES); glVertex2f(100.0f, 100.0f); // origin of the FIRST line glVertex2f(200.0f, 140.0f); // end point of the FIRST line glVertex2f(120.0f, 170.0f); // origin of the SECOND line glVertex2f(240.0f, 120.0f); // end point of the SECOND line glEnd( ); Triangle in OpenGL12345glBegin(GL_TRIANGLES); glVertex2f(-0.5,-0.5); glVertex2f(0.5,0.0); glVertex2f(0.0,0.5); glEnd(); glQuad_STRIPOrdering of coordinates very important","link":"/2021/09/23/CPT205-W3/"},{"title":"CAN201 W3","text":"This’s note is about the lecture and lab of Week2 CAN201.The lecture III - Application Layer. Domain Name System (DNS) P2P Applications Socket Programming 套接字编程 LectureDNSaka domain name system Application-layer protocol: DNS是一个应用层协议 C/S architeture client-server architeture 不是p2p的 UDP (port53) 传输方式(无保障 unreliable) 方便提取 不需要握手🤝 hosts, name servers communicate to resolve names (name/address translation) Distributed database implemented in hierarchy of many name servers 分布式数据库在多个名称服务器的层次结构中实现 分层化命名可以减小重名的可能性 分布数据库解决名字到ip解析的关系，方便维护 services, structureDNS services Hostname to IP address translation (A) 最重要的就是翻译功能 Host aliasing (cname) canonical, alias names 别名问题 Mail server aliasing (mx) Load distribution Replicated Web servers: many IP addresses correspond ot one name Why not centralize DNS? 为什么DNS要用分布数据库？ Single point of failure 单点故障 Traffic volume 交通量 Distant centralized database 远程集中式数据库 Maintenance 维护 a distributed, hierarchical databaseClient wants IP for www.amazon.com: Client queries root server to find com DNS server Client queries .com DNS server to get amazon.com DNS server Client queries amazon.com DNS server to get IP address for www.amazon.com root name servers contacted by local name server that can not resolve name root name server: contacts authoritative name server if name mapping not known get mapping returns mapping to local name server 域名的每一个点都是一层，根据这个点的内容来寻找对应的位置。 TLD, authoritative servers Top-level domain (TLD) servers: 顶级域名服务器 Responsible for com, org, net, edu, aero, jobs, museums, and all top-level country domains, e.g.: cn, uk, fr, ca, jp Network Solution maintains servers for .com TLD Educause for .edu TLD (https://net.educause.edu/) Authoritative DNS servers: 权威DNS服务器 Organization’s own DNS servers, providing authoritative hostname to IP mappings for organization’s named hosts 组织自己的DNS服务器，为组织的命名主机提供权威主机名到IP映射 Can be maintained by organization or service provider 可由组织或服务提供商维护 Local DNS name server Does not strictly belong to hierarchy Each ISP (residential ISP, company, university) has one Also called “default name server” When host makes DNS query, query is sent to its local DNS server Has local cache of recent name-to-address translation pairs (but may be out of date!) 本地缓存最近的名称-地址转换对 Acts as proxy, forwards query into hierarchy 充当代理，将查询转发到层次结构 DNS name resolution example两种查询方法 Host at XJTLU wants IP address for www.feimax.com Iterated query 迭代查询 contacted server replies with name of server to contact “I don’t know this name, but ask this server” 相当于不知道之后指路，让用户去问其他服务器 Recursive query 递归查询 Puts burden of name resolution on contacted name server Heavy load at upper levels of hierarchy 一条路走到底，再走回来 caching, updating records缓存，升级记录 Once (any) name server learns mapping, it caches mapping Cache entries timeout (disappear) after some time (TTL) 缓存条目超时后一段时间 TLD servers typically cached in local name servers 经常会缓存顶级服务器，所以根服务器不常被访问 thus root name servers not often visited Cached entries may be out-of-date if name host changes IP address, may not be known Internet-wide until all TTLs expire 如果主机名更改了IP地址，可能在所有ttl过期之前都不知道 Update/notify mechanisms proposed IETF standard 更新/通知机制提议的IETF标准 RFC 2136 DNS recordsDNS: distributed database storing resource records (RR)RR format: (name, value, type, ttl) Loop up a domain nameThere’re several ways to deal with. Use nslookup command. Use whois command. DNS protocol, messageQuery and reply messages, both with same message format. 查询和回复消息，都使用相同的消息格式。 Inserting records into DNS Example: new startup “feimax.com” Register name feimax.com at DNS register Normally, you don’t need to set up the NS record Insert A record for the IP address of your host Insert MX record for email Domain name is a scarce resource! 稀缺资源 Pure P2P architecture no always-on server arbitrary end systems directly communicate peers change IP addressesExamples: file distribution, streaming, VoIP File distribution: client-server vs P2PQ: how much time to distribute file (size F) from one server to N peers？Peer upload/download capacity is limited resource.Example:client upload rate = u, F/u = 1hour, u_s = 10u, d_min &gt;= u_s File distribution time: client-server server transmission: must sequentially send (upload) N file copies: time to send one copy: F/u_s time to send N copies: NF/u_s 发送N个file的大小再除服务器的带宽 client: each client must download file copy d_min = min client download rate max client download time: F/d_min 最慢的那个用户下载文件所用的时间 后来会线性增长 File distribution time: P2P server transmission: must sequentially send (upload) at least one file copies: time to send one copy: F/us 服务器也是有文件的，假如网络里没有人参与p2p那就是服务器直接向唯一的用户分发。 client: each client must download file copy min client download time: F/dmin clients: as total must download NF bits max upload rate (limiting max download rate) is us + Sui 所有的客户端也可以作为服务器上传 P2P file distribution: BitTorrent 文件分发：比特流 File divided into 256Kb chunks 文件分成碎片 Peers in torrent send/receive file chunks Peer joining torrent: has no chunks, but will accumulate them over time from other peers registers with tracker to get list of peers, connects to subset of peers While downloading, peer uploads chunks to other peers Peer may change peers with whom it exchanges chunks Peers may come and go Once peer has entire file, it may leave or remain in torrent BitTorrent: requesting, sending file chunksRequesting chunks: at any given time, different peers have different subsets of file chunks Periodically, Alice asks each peer for list of chunks that they have Alice requests missing chunks from peers, rarest first Sending chunks: tit for tat Alice sends chunks to those four peers currently sending her chunks at highest rate other peers are choked by Alice (do not receive chunks from her) re-evaluate top 4 every 10 secs every 30 secs: randomly select another peer, starts sending chunks “optimistically unchoke” this peer newly chosen peer may join top 4 Higher upload rate: find better trading partners, get file faster! Socket Programming 套接字编程Two socket types for two transport services UDP: unreliable datagram TCP: reliable, byte stream-oriented Application Example: client reads a line of characters (data) from its keyboard and sends data to server server receives the data and converts characters to uppercase server sends modified data to client client receives modified data and displays line on its screen Socket programming with UDPUDP: no “connection” between client &amp; server No handshaking before sending data Sender explicitly attaches IP destination address and port # to each packet Receiver extracts sender IP address and port # from received packet UDP: transmitted data may be lost or recieved out-of-orderApplication viewpoint UDP provides unreliable transfer of groups of bytes (“datagrams”) between client and server 详细见ppt Lab File Operation Text file – Write / Read Binary file – Write /Read Networking Programming Using Socket UDP Server and Client TCP Server and Client Openopen method is exploit to operate files: 1f = open(file='filename.xxx', mode='r') File open modes12345678‘r’ open for reading (default)‘w’ open for writing, truncating the file first‘x’ create a new file and open it for writing‘a’ open for writing, appending to the end of the file if it exists‘b’ binary mode, used for media files't' text mode (default)'+' open a disk file for updating (reading and writing)'U' universal newline mode (deprecated) Write12f.write(Str) # Write a str to a filef.writelines(StrList) # Write a list of str to a file Read123f.read(n) # read n chars(including \\n), n=-1 means read allf.readline() # read one line (including \\n)f.readlines() # return a list of all lines Text file appending123f = open('/Users/fei/lesson1.txt', 'a') # open the filef.write('Bye.\\n') # add text into the filef.close() # close the file Binary file read123f.read(n) # read n bytes(including \\n), n=-1 means read all f.readline() # read one line (including \\n)f.readlines() # return a list of all lines Binary file write1f.write(bytes) # Write some bytes to a file Binary file operation is very powerful, but we don’t go deep today. Socket programmingUDP12345678910111213# Server sidefrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_DGRAM)server_socket.bind(('', server_port))print('The server is ready to receive')while True: message, client_address = server_socket.recvfrom(20480) modifiedMessage = message.decode().upper() server_socket.sendto(modifiedMessage.encode(), client_address) 123456789101112131415# Client sidefrom socket import *server_name = '127.0.0.1' # 127.0.0.1 is your local IP address# Others should not use this IP. You need to use ipconfig(win)# or ifconfig(linux, macos) to get you IP address in the networkserver_port = 12000clientSocket = socket(AF_INET, SOCK_DGRAM)message = input('Input lowercase sentence:')clientSocket.sendto(message.encode(), (server_name, server_port))modifiedMessage, serverAddress = clientSocket.recvfrom(20480)print(modifiedMessage.decode())clientSocket.close() TCP123456789101112131415# Server sidefrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_STREAM)server_socket.bind(('', server_port))server_socket.listen(1)print('The server is ready to receive')while True: connectionSocket, addr = server_socket.accept() sentence = connectionSocket.recv(20480).decode() capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence.encode())connectionSocket.close() 1234567891011# Client Sidefrom socket import *serverName = '127.0.0.1'serverPort = 12000clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName,serverPort))sentence = input('Input lowercase sentence:')clientSocket.send(sentence.encode())modifiedSentence = clientSocket.recv(20480)print('From Server:', modifiedSentence.decode())clientSocket.close() LabTCP12345678910111213141516171819202122232425262728293031323334353637383940# Server side# TCPfrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_STREAM)server_socket.bind(('', server_port))server_socket.listen(2)print('The server is ready to receive')while True: connectionSocket, addr = server_socket.accept() xjtlu1 = connectionSocket.recv(20480) # 接受xjtlu文件 f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu1.jpg', 'wb') # 保存至xjtlu1 保存图片用wb f.write(xjtlu1) connectionSocket.send(xjtlu1) # 由服务器端发送至客户端 f.close()connectionSocket.close()# Client Side# TCPfrom socket import *serverName = '127.0.0.1'serverPort = 12000clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName, serverPort))f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu.jpeg', 'rb') # 打开xjtlu文件 打开图片用rbimage_data = f.read() # 赋值到image_data里f.close()clientSocket.send(image_data) # 发送至服务器modifiedImage = clientSocket.recv(20480) # 接受服务器发来的xjtlu1xjtlu2 = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu2.jpg', 'wb')xjtlu2.write(modifiedImage) # 保存至xjtlu2xjtlu2.close()clientSocket.close() UDP1234567891011121314151617181920212223242526272829303132333435363738# Server side# UDPfrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_DGRAM)server_socket.bind(('', server_port))print('The server is ready to receive')while True: xjtlu1, client_address = server_socket.recvfrom(20480) f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu1.jpg', 'wb') f.write(xjtlu1) server_socket.sendto(xjtlu1, client_address) f.close()# Client side# UDPfrom socket import *server_name = '127.0.0.1' # 127.0.0.1 is your local IP address# Others should not use this IP. You need to use ipconfig(win)# or ifconfig(linux, macos) to get you IP address in the networkserver_port = 12000clientSocket = socket(AF_INET, SOCK_DGRAM)# message = input('Input lowercase sentence:')f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu.jpeg', 'rb')image_data = f.read()f.close()clientSocket.sendto(image_data, (server_name, server_port))modifiedImage, serverAddress = clientSocket.recvfrom(20480)xjtlu2 = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu2.jpg', 'wb')xjtlu2.write(modifiedImage)xjtlu2.close()clientSocket.close() Reference XJTLU slides (Week3)","link":"/2021/09/23/CAN201-W3/"},{"title":"CPT203 W3","text":"This week we will focus on two topics: Scrum Framework Agile Methods - Background Scrum FrameworkScrum isn’t a standard process.Scrum is a framework for organizing and managing work.Scrum是一个敏捷开发框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发周期包括若干个小的跌代周期，每个小的的跌代周期称为一个Sprint，每个Sprint的建议长度2到4周。The Scrum values, principles, and practices would be the key structural components. You can customize inside the structure of Scrum, adding fixtures and features until you have a process that works for you. Scrum is a simple, people-centric framework based on the values of honesty, openness, courage, respect, focus, trust, empowerment, and collaboration. The Scrum practices themselves are embodied in specific roles, activities, artifacts, and their associated rules. Scrum RolesScrum development efforts consist of one or more Scrum teams. Each made up of three Scrum roles: product owner, ScrumMaster and the development team. The product owner is responsible for what will be developed and in what order. 产品负责人负责开发什么以及以什么顺序开发。 The Scrum Master is responsible for guiding the team in creating and following its own process based on the broader Scrum framework. Scrum Master负责指导团队基于更广泛的Scrum框架创建并遵循自己的流程。 The development team is responsible for determining how to deliver what the product owner has asked for. 开发团队负责确定如何交付产品所有者所要求的内容。 Product OwnerThe single authority responsible for deciding which features and functionality to build and the order in which to build them. The product owner maintains and communicates to all other participants a clear vision of what the Scrum team is trying to achieve. The product owner is responsible for the overall success of the solution being developed or maintained.负责决定构建哪些特性和功能以及构建它们的顺序的单一权威。产品负责人维护Scrum团队想要实现的目标，并与其他所有参与者进行沟通。产品负责人负责开发或维护的解决方案的整体成功。说到底Product Owner就是老板，只负责提供所有的要求和开发顺序。 To make sure that the most valuable work is always performed. 确保最有价值的工作总是被完成 The product owner actively collaborates with the ScrumMaster and development team. 产品负责人积极与ScrumMaster和开发团队合作 Must be available to answer questions soon after they are posed. 必须能在问题被提出后马上回答 ScrumMasterHelps everyone involved understand and embrace the Scrum values, principles, and practices. Acts as a coach, providing process leadership and helping the Scrum team and the rest of the organization develop their own high performance, organization-specific Scrum approach. The ScrumMaster helps the organization through the challenging change management process that can occur during a Scrum adoption.帮助参与的每个人理解并接受Scrum价值观、原则和实践。作为教练，提供过程领导，帮助Scrum团队和组织的其他成员开发他们自己的高效的、针对组织的Scrum方法。ScrumMaster帮助组织完成在采用Scrum过程中可能发生的具有挑战性的变更管理过程。 ScrumMaster有工头那味了 As a facilitator, the ScrumMaster helps the team resolve issues and make improvements to its use of Scrum. 作为一个推动者，ScrumMaster帮助团队解决问题并改进Scrum的使用。 Also responsible for protecting the team from outside interference and takes a leadership role in removing impediments that inhibit team productivity. 还负责保护团队不受外界干扰，并在消除阻碍团队生产力的障碍方面发挥领导作用。 The ScrumMaster has no authority to exert control over the team, so this role is not the same as the traditional role of project manager or development manager. ScrumMaster没有权力对团队施加控制，所以这个角色与传统的项目经理或开发经理的角色不同。 The ScrumMaster functions as a leader, not a manager. ScrumMaster是一个领导者，而不是管理者。 Development Team Scrum defines the role of a development team, which is simply a diverse, cross-functional collection of people who are responsible for designing, building, and testing the desired product. The development team self-organizes to determine the best way to accomplish the goal set out by the product owner. The development team is typically five to nine people in size. Its members must collectively have all of the skills needed to produce good quality, working software. For development efforts that require much larger team size, team members can be organized into several teams with each team nine or fewer team members. Scrum定义了开发团队的角色，开发团队是一个多元化的、跨职能的团队，负责设计、构建和测试所需的产品。开发团队自组织以确定实现产品所有者设定的目标的最佳方法。开发团队的规模通常是5到9人。它的成员必须集体拥有生产高质量、可工作的软件所需的所有技能。对于需要更大团队规模的开发工作，可以将团队成员组织成几个团队，每个团队有9个或更少的团队成员。Development Team低端码农了属于是 Scrum Activities and Artifacts Forecast? Commitment?It is a forecast because the estimate might change as more information becomes known during the course of the sprint. Some also believe that a commitment on the part of the team will cause the team to sacrifice quality to meet the commitment. Or will cause the team to “under-commit” to guarantee that the commitment is met.它是一种预测，因为在sprint过程中，随着更多的信息被了解，估计可能会发生变化。有些人还认为，团队的承诺将导致团队牺牲质量来满足承诺。或者会导致团队“承诺不足”，以保证承诺得到满足。 Using the forecast to derive a commitment. Commitments support mutual trust between the product owner and the development team as well as among the development team. Commitments support reasonable short-term planning and decision making within an organization. When performing multiteam product development, commitments support synchronized planning.利用预测得出一个承诺。承诺支持产品所有者和开发团队之间以及开发团队之间的相互信任。承诺支持组织内合理的短期计划和决策。当执行多团队产品开发时，承诺支持同步计划。 Product Backlog 产品待办事项列表The product owner, with input from the rest of the Scrum team and stakeholders, is ultimately respnsible for determining and managing the sequence of works (product backlog items) and communicating it in the form of a prioritized (or ordered) list known as the product backlog.产品负责人根据Scrum团队其他成员和涉众的意见，最终负责确定和管理产品待定项的顺序，并以优先级列表的形式(即产品待定项列表)进行沟通。 High-value items appear at the top of the product backlog and the lower-value items appear toward the bottom. The product backlog is constantly evolving artifact. Items can be added, deleted, and revised by the product owner as business conditions change, or as the Scrum team’s understanding of the product grows. In pratice, many teams use a relative size measure such as story points or ideal days to express the item size. PBI Example User Story: online user registration Description: as a user, I want to be able to register online, so that I can perform online shopping. Acceptance Criteria: User can register only if the user fills in all required fields The email used in the registration must not be a free email User will receive a notification email after successful registration Product Backlog Grooming 梳理产品待办事项列表The activity of creating and refining product backlog items, estimating them, and priortizing them is known as grooming. 创建和细化产品待办事项列表项、评估它们并对它们进行优先级排序的活动称为梳理。优先级从Feature A–&gt;Feature C逐渐降低。 Sprint 冲刺In Scrum, work is performed in iterations or cycles of up to a calendar month called sprints.The work completed in each sprint should create something of tangible value to the customer or user. Sprints are timeboxed so they always have a fixed start and end date, and generally they should all be of the same duration. A new sprint immediately follows the completion of the previous sprint.在每个“冲刺”中完成的工作应该为客户或用户创造一些有形的价值。sprint是有时间框的，所以它们总是有一个固定的开始和结束日期，通常它们都应该具有相同的持续时间。在前一个冲刺完成之后，马上会有一个新的冲刺。 召开Sprint Plan Meeting，确定这个Sprint的目标、演示日期、要完成的Backlog、Backlog的优先级等； 进入冲刺开发周期，在这个周期内，每天要召开Daily Stand-up Meeting； 整个冲刺周期结束，召开Sprint Review Meeting，将成果演示给Product Owner； 团队成员最后召开Sprint Retrospective Meeting，总结问题和经验. Sprint PlanningA product backlog may represent many weeks or months of work. To complete all the items in the product backlog, a series of sprints are to be carried out. To determine the most important subset of product backlog items to build in the next sprint, the product owner, development team, and ScrumMaster perform sprint planning.一个产品待办事项列表可能代表数周或数月的工作。为了完成产品待办事项列表中的所有项目，需要进行一系列的“冲刺”。为了确定下一个sprint中要构建的产品待定项的最重要子集，产品所有者、开发团队和ScrumMaster执行sprint计划。 During sprint planning, the product owner and development team agree on a sprint goal that defines what the upcoming sprint is supposed to achieve. Based on the sprint goal, the development team reviews the product backlog and determines the high priority items that the team can realistically accomplish in the upcoming sprint while working at a sustainable pace.在“冲刺”计划中，产品负责人和开发团队就“冲刺”目标达成一致，该目标定义了即将到来的“冲刺”应该实现什么。基于“冲刺”目标，开发团队审查产品待办事项列表，并确定在即将到来的“冲刺”中团队可以实际完成的高优先级项目，同时以“可持续的速度”工作。Many development teams break down each targeted feature into a set of tasks. The collection of these tasks, along with their associated product backlog items, forms a second backlog called the sprint backlog.The team provides an estimate (typically in hours) of the effort required to complete each task. 总的来说，选择一个产品待办事项列表项(最重要项)，将该项分解为任务，并确定所选的项是否合理地适合sprint(与同一sprint的其他目标项相结合)。如果它确实适合，并且有更多的能力来完成工作，那么重复这个循环，直到团队没有能力做更多的工作。 Sprint ExecutionOnce the Scrum team finishes sprint planning and agrees on the content of the next sprint, the development team performs all of the task-level work necessary to get the features done. 一旦Scrum团队完成了“冲刺”计划，并就下一个“冲刺”的内容达成一致，开发团队就会执行完成特性所需的所有任务级工作。“done” means there is a high degree of confidence that all of the work necessary for producing good-quality features has been completed. “完成”意味着有高度的信心，生产高质量功能所需的所有工作已经完成。Team members define their own task-level work and then self organize in any manner they feel is best for achieving the sprint goal. 团队成员定义他们自己的任务级工作，然后以他们认为最适合实现sprint目标的方式进行自我组织。 Daily ScrumNot a problem-solving activity. Talk about problems after the daily scrum and do so with a small group of interested member. Not a traditional status meeting. Communicate the status of sprint backlog items among the development team members. It is an inspection, synchronization, and adaptive daily planning activity that helps a self-organizing team do its job better. 在日常的scrum之后和一小群感兴趣的成员讨论问题。不是传统的地位会议。在开发团队成员之间沟通sprint待定项的状态。它是一种检查、同步和自适应的日常计划活动，帮助自组织团队更好地完成工作。 Definition of DoneSprint results as a potentially shippable product increment, meaning that whatever the Scrum team agreed to do is really done according to its agreed upon definition of done. This definition specifies the degree of confidence that the work completed is of good quality and is potentially shippalbe. A bare-minimum definition of done should yield a complete slice of product functionally that is designed, built, integrated, tested and documented. Sprint的结果是一个潜在的可交付产品增量。“完成”的最小定义应该产生设计、构建、集成、测试和文档化的产品功能的完整部分。 “pontentially shippable” does not mean that what got built must actually be shipped. 潜在的交付并不代表项目必须交付，交付的决定属于商业决定(business decision)会因此各种决定而改变。例如: Do we have enough features or enough of a customer workflow to justify a customer deployment? 我们是否有足够的特性或足够的客户工作流来证明客户部署的合理性? Can our customers absorb another change given that we just gave them a release two weeks ago? 我们两周前刚刚发布了一个版本，我们的客户能接受另一个变化吗? Sprint ReviewAt the end of sprint there are two additional inspect-and-adapt activities, sprint review (sprint评审) and sprint retrospective (sprint回顾). Sprint review is to inspect and adapt the product that is being built. Sprint评审是检查和调整正在构建的产品。 Critical to this activity is the conversation that takes place among its participants, which include the Scrum team, stakeholders, sponsors, customers and interested members of other teams. Focused on reviewing the just-completed features in the context of the overall development effort. Everyone in attendance gets clear visibility into what is occurring and has an opportunity to help guide the forthcoming development to ensure that the most business-appropriate solution is created.这个活动的关键是参与者之间的对话，参与者包括Scrum团队、利益相关者、赞助者、客户和其他团队感兴趣的成员。着重于在整个开发工作的上下文中回顾刚刚完成的特性。参加会议的每个人都能清楚地了解正在发生的事情，并有机会帮助指导即将进行的开发，以确保创建最适合业务的解决方案。 Sprint RetrospectiveThis is the second inspect-and-adapt activity at the end of the sprint. 第二个总结活动在sprint结束时。Frequently occurs after the sprint review and before the next sprint planning. 经常发生在“冲刺”评审之后和下一个“冲刺”计划之前。Sprint retrospective is an opportunity to inspect and adapt the process. Sprint回顾是一个检查和调整过程的机会。The development team, ScrumMaster, and product owner discuss what is and is not working with Scrum and associated technical practices. 开发团队、ScrumMaster和产品负责人讨论什么是Scrum，什么不是Scrum，以及相关的技术实践。The focus is on the continuous process improvement. 重点是持续的过程改进。At the end of a sprint retrospective the Scrum team should have identified and committed to a practical number of process improvement actions. 在sprint回顾的最后，Scrum团队应该确定并承诺一些实际的过程改进行动。 Sprint Review和Sprint Retrospective都是在每一个sprint结束后发生的，他俩应该是紧挨在一起进行的，只是会议的内容有所不同。每天的任务结束一直会进行的是daily scrum。 Agile Methods 敏捷方法 Agile methods Plan-driven and agile development 其实这部分和Scrum Framework的位置我放反了，但是就先这么看着吧。 Background大公司需要产品的时候，愿意权衡软件质量和需求，以更快地部署他们需要的软件。因为不可能推导出一套完整的稳定的软件需求。最初的需求不可避免地会发生变化。最后为了尽快交付系统，让用户获得经验，发现更清晰的真实需求由于外部因素，需求可能会迅速和不可预测地变化。 Content Some of the agile methods Extreme programming (Beck, 1999; Beck, 2000) Scrum (Cohn, 2009; Schwaber, 2004; Schwaber and Beedle, 2001) Crystal (Cockburn, 2001; Cockburn, 2004) Adaptive Software Development (Highsmith, 2000) DSDM (Stapleton, 1997; Stapleton, 2003) Feature Driven Development (Palmer and Felsing, 2002) These agile methods are all based around the notion of incremental development and delivery with different processes 这些敏捷方法都是基于增量开发和不同过程交付的概念 However, they share a set of principles, based on the agile manifesto, and so have much in common. 基于敏捷宣言共享了一套原则，因此有很多共同点。 The philosophy behind agile methods is reflected in the agile manifesto that was agreed on by many of the leading developers of these methods. Individuals and interactions over processes and tools 个人和互动高于过程和工具 Working software over comprehensive documentation 工作软件胜过全面的文档 Customer collaboration over contract negotiation 客户合作高于合同谈判 Responding to change over following a plan 响应计划的变更 Most software projects include practices from plan-driven and agile approaches. 大多数软件项目包括来自计划驱动和敏捷方法的实践。 Tutorial Explain why the rapid delivery and deployment of new systems is often more important to businesses than the detailed functionality of these systems. 为什么快速交付和部署新系统往往比这些系统的详细功能更重要A: A conventional waterfall or specification-based process is usually prolonged and the final software is delivered to the customer long after it was originally specified. In a fast-moving business environment, this can cause real problems. By the time the software is available for use, the original requirements may have changed so radically that the software is effectively useless. Therefore, for business systems in particular, development processes that focus on rapid software development and delivery are essential. 传统的瀑布式或基于规格说明的过程通常会延长，最终的软件在最初指定之后很长时间才交付给客户。在快速变化的商业环境中，这可能会导致真正的问题。当软件可以使用时，原始的需求可能已经发生了根本的变化，以至于软件实际上是无用的。因此，特别是对于业务系统，专注于快速软件开发和交付的开发过程是必不可少的。 Explain how the principles underlying agile methods lead to the accelerated development and deployment of software. 敏捷开发的原则 Individual and interactions over processes and tools. 流程和工具之上的个人和交互 Working software over comprehensive documentation. 工作软件胜过全面的文档 Customer collaboration over contract negotiation. 客户合作高于合同谈判 Responding to change over following a plan. 响应计划的变更 When would you recommend against the use of an agile method for developing a software system? 什么时候你会建议不要使用敏捷方法来开发软件系统 Agile methods should probably not be used when the software is being developed by teams who are not co-located. If any of the individual teams use agile methods, it is very difficult to coordinate their work with other teams. Furthermore, the informal communication which is an essential part of agile methods is practically impossible to maintain unless they are being supported by collaboration tools such as online meeting. 当软件由不在同一地点的团队开发时，可能不应该使用敏捷方法。如果任何一个团队使用敏捷方法，那么就很难与其他团队协调工作。此外，非正式交流是敏捷方法的重要组成部分，除非得到在线会议等协作工具的支持，否则实际上是不可能维护的。 Agile methods should probably also be avoided for critical systems where the consequences of a specification error are serious. In those circumstances, a system specification that is available before development starts makes a detailed specification analysis possible. 对于规范错误后果严重的关键系统，可能也应该避免使用敏捷方法。在这些情况下，在开发开始之前可用的系统规范使详细的规范分析成为可能。 However, some ideas from agile approaches such as test first development are certainly applicable to critical systems. 然而，敏捷方法中的一些想法，如测试优先开发，肯定适用于关键系统。 To reduce costs and the environmental impact of commuting,your company decides to close a number of offices and to provide support for staff to work from home. However, the senior management who introduce the policy are unaware that software is developed using agile methods, which rely on close team working and pair programming. Discuss the difficulties that this new policy might cause and how you might get around these problems. 引入这一策略的高级管理人员并不知道软件是使用敏捷方法开发的，这种方法依赖紧密的团队合作和结对编程。讨论这个新政策可能导致的困难，以及如何解决这些问题。A: When a company is driven by a close team and is divided they will be unable to have daily meetings, which can cause issues with communication, programming in pairs would not be possible, a communication gab would be created, productivity will slow down due to communication issues, and detecting errors would be quite difficult. These problems can be avoided by creating merging offices together so pair programming and daily communication can be established. If that is not possible, a communication platform consisting of webcams, desktop viewing software, and microphones should be created to allow better communication. 当一个公司是由亲密的团队,他们将无法日常会议,这可能会导致问题沟通、成对编程不可能,一个通信唠叨会被创建,生产力将减缓由于沟通问题,和检测错误是相当困难的。这些问题可以通过在一起创建合并办公室来避免，这样就可以建立结对编程和日常通信。如果这是不可能的，应该创建一个由网络摄像头、桌面查看软件和麦克风组成的通信平台，以便更好地进行通信。 References XJTLU slides CPT203 Week3 什么是敏捷开发之Scrum框架，如何入门？ - 项目管理进阶的回答 - 知乎 Sprint Review vs Sprint Retrospective","link":"/2021/09/22/CPT203-W3/"},{"title":"INT201 W2","text":"This is the note of INT201 Week2. The lecture is still focusing on decision, computation and language. Alphabet A,A* = {alll strings consisting symbols from A}A subset L of A* is called a languageQuestion: For a language L, does exist an algorithm to check for any x, if x is in L? Nondeterministic finite automata 非确定性有限自动机Recall: we took original DFA definition and extended that definition to allow some transitions to be undefined. Nondeterministic Finite Automata (NFA) are a futher extension… 我们采用了原始的DFA定义并扩展了该定义以允许未定义一些转换。非确定性有限自动机是一个进一步的扩展。 describing a formal language (may be simpler than equivalent DFAs) 描述一种形式语言 conversion between finite automata and regular expressions 有限自动机和正则表达式之间的转换 “nondeterministic” – an input string does not determine the final state. 一个输入字符串不能决定最终状态。This is because given a current state and an input letter, we may specify a set of allowable new states, not just one. 这是因为给定一个当前状态和一个输入字母，我们可以指定一组允许的新状态，而不仅仅是一个。DFA和NFA的区别在于转移函数的类型。不同于DFA对于同一个输入和同一个状态只有一个转移，NFA对于同一输入和同一状态可以有多个或零个转移。DFA的转移必须是一对一的，NFA中的状态转移以集合的形式展现。Then we say that a NFA accepts an input word w if there exists a sequence of transitions labelled by symbols in w, starting from initial state and ending at some accepting state. 然后我们说一个NFA接受一个输入词w，如果存在一个以w标记的转换序列，从初始状态开始到某个接受状态结束。 通过CSDN上的一篇文章系统的了解了一下NFA和DFA当输入一个数值的时候，DFA可以转移到固定的状态，但是NFA不可以转移到确定的状态 The formal definitionLet P(S) denote the set of all subsets of a set S. A nondeterministic finite automaton (or NFA) is a quintuple A = (Q,A,φ,i,T) where Q is a finite nonempty set whose members are called states of the automaton. A is a finite nonempty set called the alphabet of the automaton. φ is a map from Q × A to P(Q) called the transition function of the automaton. i is a number of Q and is called the initial state. T is a nonempty subset of Q whose members are called terminal states or accepting states. Notation建议直接看ppt 假设，在一个DFA中，我们可以通过以单词w的字母标记的转换从状态p到状态q，然后我们说状态p和状态q由标记为w的路径连接。如果w = abc两个中间状态是r1和r2，我们可以把它写成In a NFA, if φ(p,a) = {q,r} we could write DFA是一种NFA的约束形式，DFA进行转换的结果集的大小被约束为1或0，因此，DFA接受的语言都被NFA接受。NFA优缺点: NFA相对于对应的DFA，需要更少的状态，但是这样就会增加搜索的时间。DFA比较快，但不提供Backtrack（回溯）功能，NFA比较慢，但提供了Backtrack功能。 Reference XJTLU MC PowerPoint slides (Week2) bilibili: NFA to DFA","link":"/2021/09/20/INT201-W2/"},{"title":"CPT205 W2","text":"This’s the note of CPT205 W2. The topics for this week: Computer representation of objects Cartesian co-ordinate system Points, lines and angles Trigonometry 三角函数 Vectors (unit vector) and vector calculations (addition, subtraction, scaling, dot product, cross product) 矢量和矢量计算 Matrices (dimension, transpose, square/symmetric/identity, inverse) and matrix calculations (addition, subtraction, multiplication) 矩阵和矩阵计算 因为矩阵的知识快忘光了，所以矩阵的部分写的比较多。 LectureComputer representation of objects Cartesian co-ordinate system都是笛卡尔平面直角坐标系的知识，不会的建议重开。 Points, lines and angles同上。 Trigonometry同上。 Vectors同上。 Matrices Techniques for applying transformations use matrices. 应用变换的技术使用矩阵。 A matrix is simply a set of numbers arranged in a rectangular format. 矩阵是一组按矩形形式排列的数字。 Each number is known as an element. 每个数字都是一个元素。 Capital letters are used to represent a matrix. 用大写字母表示矩阵。 Bold letters when printed (M), or underlined when written. 打印时加粗或下划线。 A matrix has dimensions that refer to the number of rows and the number of columns it has. 矩阵的维数指的是它的行数和列数 Dimensions of matricesThe dimensions of Matrix are (x * y). x is the number of rows in matrix and y is the columns.$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$The dimensions of this matrix are (2*3). Transpose matrixWhen a matrix is rewritten so that its rows and columns are interchanged, then the resulting matrix is called the transpose of the original. 当一个矩阵被改写使它的行和列互换时，得到的矩阵叫做原矩阵的转置。The original A:$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$The transpose matrix of A:$$ \\begin{bmatrix} 1 &amp; 4 \\\\ 2 &amp; 5 \\\\ 3 &amp; 6 \\\\ \\end{bmatrix}$$ Square and symmetric matrices A square matrix is matrix where the number of rows equals the number of columns. 行列数量相同的是方阵。 A symmetric matrix is a square matrix where the rows and columns are such that its transponse is the same as the original matrix. 对角线对称的方阵是对称矩阵。 Identity matricesAn identity matrix, I is a square matrix with zeros everywhere except its diagonal elements which have a value of 1. 单位矩阵就是对角线是1，剩下的都是0的方阵。 Adding matrices Matrices A and B may be added if they have the same dimensions. That is, the corresponding elements may be added to yield a resulting matrix. The sum is commutative, i.e. A + B = B + A 加法交换律 Subtracting matricesMatrix B may be subtracted from matrix A if they have the same dimensions, i.e. the corresponding elements of B may be subtracted from those of A to yield a resulting matrix.The result is not commutative. Reversing the order of the matrices yields different results, i.e. A - B ≠ B -A ⚠️减法🈚️交换律! Multiplying matrices By a constant By a matrix - The rule for multiplying one matrix to another is simple: if the number of columns in the first matrix is the same as the number of rows in the second matrix, the multiplication can be done. 也就是必须要是(x * y)&amp;(y * z)，计算结果是(x * z)。 Matrix multiplication is not commutative. Reversing the order of the matrices yields different results. ⚠️矩阵的乘法也是没有交换律的！交换相乘的两个矩阵的位置会产生不同的结果。 Inverse matricesIf two matrices A and B, when multiplieid together, results in an indentity matrix I, then matrix A is the inverse of matrix B and vice versa, i.e.$$A * B = B * A = I$$$$A = B^{-1} and B = A^{-1}$$两个矩阵相乘是一个单位矩阵那这两个矩阵就是逆矩阵。 LabThe tutorial explains the C/C++ basics that will be used in CPT205 Computer Graphics.跟着lab做问题不大，注意一个cpp的project中只有可以有一个main方法，这是和py不一样的地方。学校给的那个lab代码需要引入math才可以正常操作。引入库的时候需要手动输入，复制粘贴的时候会出现无法读取的问题 #include &lt;GL/freeglut.h&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define FREEGLUT_STATIC #include &lt;GL/freeglut.h&gt; #include &lt;math.h&gt;void define_to_OpenGL(); /////////////////////////////////// int main(int argc, char** argv) { glutInit(&amp;argc,argv); // Task 2 glutInitWindowSize(600, 400); // 整个window的大小 glutInitWindowPosition(50, 50); // window的左上角对于屏幕左上角的坐标 glutCreateWindow(&quot;Graphics Primitives&quot;); // 初始化一个窗口 glutDisplayFunc(define_to_OpenGL); glutMainLoop(); // 实现循环} /////////////////////////////////// void define_to_OpenGL() { glClearColor(1,1,1,1); glClear(GL_COLOR_BUFFER_BIT); // The stuff to appear on screen goes here // Task 2 Set the Dimensions glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(-100,500,-200,200); // window的原点设定，因为window是600*400，所以这里的x1x2y1y2分别代表了左下角的点和右上角的点。 // Task 3 Draw the Axes glLineWidth(1.0); glColor3f(1.0,0.0,0.0); glBegin(GL_LINES); glVertex2f(0.0,0.0); // start location glVertex2f(450.0,0.0); // end location glVertex2f(0.0,-150.0); // start location glVertex2f(0.0,150.0); // end location glEnd(); // Task 4 Draw a Dot at the Origin glPointSize(10); glColor3f(1.0,0.0,1.0); glBegin(GL_POINTS); glVertex2f(0.0,0.0); glEnd(); // Task 5 Plot a Sine Wave // draw a sine wave int i; float x,y; glColor3f(0.0,0.0,1.0); glPointSize(1); glBegin(GL_POINTS); for(i=0;i&lt;361;i=i+1) { x = (float)i; y = 100.0 * sin(i*(2*3.14/360.0)); //角度360转弧度2Π，sin函数里面放的是弧度 glVertex2f(x,y); } glEnd(); // Tasks 6 Draw a Triangle // Tasks 7 Draw A Multi-coloured Triangle // Tasks 8 Draw a Single-coloured Triangle glShadeModel(GL_FLAT); //turn off the smoothing capability glBegin(GL_TRIANGLES); glColor3f(1, 0, 0); glVertex2f( -50, 50 ); glColor3f(0, 1, 0); glVertex2f( -50, 0 ); glColor3f(0, 0, 1); glVertex2f( 0, 0 ); glEnd(); glFlush(); // 这两个是让图像显示到屏幕上} References XJTLU CPT205 slides (Week2)","link":"/2021/09/20/CPT205-W2/"},{"title":"CPT203 W2","text":"This note is about the Lecture 2 of CPT203. This week we will focus on three following spots. understand the concepts of software processes and software process models; introduced to three generic software process models and when they might be used; know about the fundamental process activities of software requirements engineering, software development, testing, and evolution; IntroductionA software process is a set of related activities that leads to the production of a software product. These activites may involve the development of software from scratch 软件从零开始 by extending and modifying existing systems 扩展和修改现有系统 by configuring and integrating off-the-shelf software or system components 通过配置和集成现成的软件或系统组件 Software processes must include four activites that are fundamental to software engineering: software specification 软件规范 software design and implementation 软件设计与实现 software validation 软件验证 software evolution 软件进化They’re complex activities and include sub-activities.There’re also supporting process activities such as documentation and software configuration management. 还有支持过程活动，如文档和软件配置管理。 Software processes are categorized as either plan-driven or agile processes. 软件过程分为计划驱动过程和敏捷过程两种。 Plan-driven processes are processes where all of the process activities are planned in advance and progress is measured against this plan. 计划驱动的过程是指所有过程活动都提前计划，并根据该计划衡量进度的过程。 In agile processes, planning is incremental and it is easier to change the process to reflect changing customer requirements. 在敏捷过程中，计划是增量的，更容易改变过程以反映客户需求的变化。 Software Process ModelsA software process model is a simplified representation of a software process.软件过程模型是软件过程的简化表示。 The models in our discussionThe waterfall model 瀑布模型This takes the fundamental process activites of specification, development, validation, and evolution and represents them as separate process phases such as requirements specification, software design, implementation, testing, and so on. 它将基本的过程活动(如规格说明、开发、验证和演进)表示为独立的过程阶段，如需求规格说明、软件设计、实现、测试等等。 Incremental development 增量开发This approach interleaves the activities of specification, development, and validation. The system is developed as a series of versions (increments), with each version adding functionality to the previous version.这种方法将规范、开发和验证活动交织在一起。系统被开发为一系列版本(增量版本)，每个版本向前一个版本添加功能。 Reuse-oriented software engineering 面向重用的软件工程This approach is based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.这种方法是基于大量可重用组件的存在。系统开发过程关注于将这些组件集成到系统中，而不是从头开始开发它们。 These models are not mutually exclusive and are often used together, especially for large systems development. 这些模型不是相互排斥的，而且在大型系统开发中经常一起使用。 The waterfall modelThis model is known as the ‘waterfall model’ or software life cycle 生命循环. This is an example of a plan-driven process 计划驱动流程.该模型直接反应了以下的活动 Requirements analysis and definition 需求分析和定义 System and software design 系统和软件设计 Implementation and unit testing 实现和单元测试 Integration and system testing 集成和系统测试 Operation and maintenance 操作维护 In principle, the result of each phase is one or more documents that are approved (‘signed off’). The following phase should not start until the previous phase has finished. In practice, these stages overlap and feed information to each other. The software process is not a simple linear model but involves feedback from one phase to another. Documents produced in each phase may then have to be modified to reflect the changes made.原则上，每个阶段的结果是一个或多个文件被批准。在下一阶段应该直到前一阶段结束后才开始。实际上，这些阶段相互重叠并提供信息。软件过程不是一个简单的线性模型，而是涉及从一个阶段到另一个阶段的反馈。每个阶段产生的文件可能需要修改以反映所做的更改。 Because of the costs of producing and approving documents, iterations can be costly and involve significant rework. Therefore, after a small number of iterations, it is normal to freeze parts of the development, such as the specification, and to continue with the later development stages. Problems are left for later resolution, ignored, or programmed around. This premature freezing of development tasks may mean that the system won’t deliver what the users are expecting.由于生产和批准文件的成本，迭代可能是昂贵的，并涉及重大的返工。因此，在少量的迭代之后，冻结开发的某些部分(如规范)并继续进行后期的开发阶段是正常的。问题被留到以后解决，或者被忽略，或者被编程处理。开发任务的过早冻结可能意味着系统无法交付用户所期望的内容。 During the final life cycle phase (operation and maintenance) the software is put into use. Errors and omissions in the original software requirements are discovered. Program and design errors emerge and the need for new functionality is identified. The system must therefore evolve to remain useful. Making these changes (software maintenance) may involve repeating previous process stages.在软件生命周期的最后阶段(操作和维护)，软件投入使用。发现原始软件需求中的错误和遗漏。出现程序和设计错误，识别新功能的需求。因此，系统必须不断发展才能保持有用。进行这些更改(软件维护)可能涉及重复前面的过程阶段。 In the Waterfall Model, documentation is produced at each phase. This makes the process visible so managers can monitor progress against the development plan. Its major problem is the inflexible partitioning of the project into distinct stages. Commitments must be made at an early stage in the process, which makes it difficult to respond to changing customer requirements. In principle, the waterfall model should only be used when the requirements are well understood and unlikely to change radically during system development.在瀑布模型中，每个阶段都会生成文档。这使得过程可见，以便管理人员可以根据开发计划监控进度。它的主要问题是不灵活地将项目划分为不同的阶段。必须在流程的早期阶段做出承诺，这使得很难响应客户不断变化的需求。原则上，瀑布模型只应该在需求被很好地理解并且不太可能在系统开发过程中发生根本变化的情况下使用。 Incremental development Incremental development is based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an adequate system has been developed. Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across activities. Incremental software development, which is a fundamental part of agile approaches, is better than a waterfall approach for most business, e-commerce, and personal systems.增量开发基于这样的想法:开发一个初始实现，将其公开给用户评论，并通过几个版本对其进行改进，直到开发出一个合适的系统。规范、开发和验证活动是交错而不是分离的，活动之间有快速的反馈。增量软件开发是敏捷方法的基本部分，对于大多数业务、电子商务和个人系统来说，增量软件开发比瀑布方法要好。 By developing the software incrementally, it is cheaper and easier to make changes in the software as it is being developed. Each increment or version of the system incorporates some of the functionality that is needed by the customer. Generally, the early increments of the system include the most important or most urgently required functionality. This means that the customer can evaluate the system at a relatively early stage in the development to see if it delivers what is required. If not, then only the current increment has to be changed and, possibly, new functionality defined for later increments.通过增量式开发软件，在开发过程中对软件进行更改更便宜也更容易。系统的每个增量或版本都包含了客户需要的一些功能。通常，系统的早期增量包括最重要或最迫切需要的功能。这意味着客户可以在开发的相对早期阶段评估系统，看看它是否交付了所需的内容。如果没有，那么只需要更改当前的增量，并且可能为以后的增量定义新的功能。 Incremental development has three important benefits, compared to the waterfall model: 相比于瀑布模型的优势 The cost of accommodating changing customer requirements is reduced. 降低了适应客户需求变化的成本。 It is easier to get customer feedback on the development work that has been done. 对于已经完成的开发工作，更容易获得客户的反馈。 More rapid delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. 即使没有包含所有的功能，也可以更快速地向客户交付和部署有用的软件。 From a management perspective, the incremental approach has two problems: the process is not visible. 流程不可视 system structure tends to degrade as new increments are added. 系统结构会随着增量的增加而降低 Other problems with incremental development includes: large organizations have bureaucratic procedures that have evolved over time and there may be a mismatch between these procedures and a more informal iterative or agile process. 大型组织的官僚程序随着时间的推移而演变，在这些程序和更非正式的迭代或敏捷过程之间可能存在不匹配。 Formal procedures are required by external regulations (e.g., accounting regulations) The problems of incremental development become particularly acute for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture. This has to be planned in advance rather than developed incrementally.对于大型、复杂、长生命周期的系统，增量开发的问题变得特别尖锐，在这些系统中，不同的团队开发系统的不同部分。大型系统需要一个稳定的框架或体系结构，不同团队在系统部分的工作职责需要根据该体系结构明确定义。这必须提前计划，而不是渐进地开发。 Reuse-oriented software engineering In the majority of software projects, there are some forms of informal software reuse. This informal reuse takes place irrespective of the development process that is used. In the 21st century, software development processes that focus on the reuse of existing software have become widely used. Reuse-oriented approaches rely on a large base of reusable software components and an integrating framework for the composition of these components.在大多数软件项目中，有一些非正式的软件重用形式。这种非正式的重用与所使用的开发过程无关。在21世纪，注重现有软件重用的软件开发过程得到了广泛的应用。面向重用的方法依赖于大量的可重用软件组件和用于这些组件组合的集成框架。 Three types of software component that may be used in a reuse-oriented process: Web services that are developed according to service standards and which are available for remote invocation. 根据服务标准开发并可用于远程调用的Web服务。 Collections of objects that are developed as a package to be integrated with a component framework such as .NET or J2EE. 对象的集合被开发成一个包，与组件框架集成。 Stand-alone software systems that are configured for use in a particular environment. 配置为在特定环境中使用的独立软件系统。 Advantages reducing the amount of software to be developed and so reducing cost and risks. 减少需要开发的软件数量，从而降低成本和风险。 usually also leads to faster delivery of the software. 通常也会导致更快的软件交付。 However, requirements compromises are inevitable and this may lead to a system that does not meet the real needs of users. Furthermore, some control over the system evolution is lost as new versions of the reusable components are not under the control of the organization using them.然而，需求妥协是不可避免的，这可能导致系统不能满足用户的实际需求。此外，由于可重用组件的新版本不在使用它们的组织的控制之下，对系统演化的一些控制就会丢失。 Software process activitiesThere’re four types of software process activites. Software Specification Software Design and Implementation Software Validation Software Evolution 真实的软件过程是技术、协作和管理活动的交错序列，其总体目标是指定、设计、实现和测试一个软件系统。在不同的开发过程中，规范、开发、验证和演进这四个基本过程活动的组织方式不同。 In the waterfall model, they are organized in sequence. 在瀑布模型中，它们是按顺序组织的。 In incremental development they are interleaved. 在增量开发中，它们是交错的。 How these activities are carried out depends on the type of software, people, and organizational structures involved. 这些活动如何进行取决于所涉及的软件、人员和组织结构的类型。 Software specification 软件规格说明Software specification or requirements engineering is the process of understanding and defining 软件规格说明或需求工程是理解和定义的过程 what services are required from the system 系统需要哪些服务 identifying the constraints on the system’s operation and development. 识别系统运行和发展的制约因素 Requirements engineering is a particularly critical stage of the software process as errors at this stage inevitably lead to later problems in the system design and implementation. 需求工程是软件过程中一个特别关键的阶段，因为这一阶段的错误不可避免地会导致系统设计和实现中的后续问题。 The activities of analysis, definition, and specification are interleaved. 分析、定义和规范的活动是交错的。 The requirements engineering process aims to produce an agreed requirements document that specifies a system satisfying stakeholder requirements. 需求工程过程的目的是产生一个商定的需求文档，指定一个满足涉众需求的系统。 规格一般分为两层级细节。Requirements are usually presented at two levels of detail. End-users and customers need a high-level statement of the requirements; 终端用户和客户需要高层次的需求说明; system developers need a more detailed system specification. 系统开发人员需要一个更详细的系统规范。 There are four main activities in the requirements engineering process: 在工程过程需求中一般有四种活动 Feasibility study 可行性研究 Requirements elicitation and analysis 需求提取和分析 Requirements specification 需求规范 Requirements validation 需求验证 Software design and implementationThe implementation stage of software development is the process of converting a system specification into an executable system. It always involves processes of software design and programming but, if an incremental approach to development is used, may also involve refinement of the software specification. A software design is a description of the structure of the software to be implemented, the data models and structures used by the system, the interfaces between system components and, sometimes, the algorithms used. 软件开发的实现阶段是将系统规范转换为可执行系统的过程。它总是涉及到软件设计和编程的过程，但是，如果使用增量开发方法，也可能涉及到软件规范的细化。软件设计是描述要实现的软件的结构、系统使用的数据模型和结构、系统组件之间的接口，有时还包括使用的算法。 设计师不会立即完成设计，而是反复开发设计。他们在开发设计的过程中添加了正式性和细节，不断回溯以纠正早期的设计。 Design activities Architectural design, where you identify the overall structure of the system, the principal components (sometimes called sub-systems or modules), their relationships, and how they are distributed. 架构设计，确定系统的整体结构、主要组件，它们之间的关系以及它们是如何分布的。 Interface design, where you define the interfaces between system components. This interface specification must be unambiguous. 接口设计，定义系统组件之间的接口。这个接口规范必须是明确的。 Component design, where you take each system component and design how it will operate. 组件设计，将每个系统组件设计成如何运行。 a simple statement of the expected functionalities. 对预期功能的简单说明 a list of changes to be made to a reusable component. 可重用组件的更改列表 a detailed design model (model-driven approach). 详细的设计模型 Database design, where you design the system data structures and how these are to be represented in a database. 数据库设计，即设计系统数据结构以及如何在数据库中表示这些结构。 The detail and representation of the design output vary considerably. For critical systems, detailed design documents setting out precise and accurate descriptions of the system must be produced. 对于关键系统，必须编制详细的设计文件，对系统进行精确的描述。 If a model-driven approach is used, these outputs may mostly be diagrams. 如果使用模型驱动的方法，这些输出可能主要是图。 Where agile methods of development are used, the outputs of the design process may not be separate specification documents but may be represented in the code of the program. 在使用敏捷开发方法的情况下，设计过程的输出可能不是单独的规格文件，而是在程序代码中表示。 Software validation There’re three testing process: 三种test process Development testing 开发测试 - The components making up the system are tested by the people developing the system. Each component is tested independently, without other system components. System testing 系统测试 - System components are integrated to create a complete system. This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems. Acceptance testing 验收测试 - This is the final stage in the testing process before the system is accepted for operational use. The system is tested with data supplied by the system customer rather than with simulated test data. Tutorial questionsQ: Giving reasons for your answer based on the type of system being developed, suggest the most appropriate generic software process model that might be used as a basis for managing the development of the following systems. A system to control anti-lock braking in a car A virtual reality system to support software maintenance A university accounting system that replaces an existing system An interactive travel planning system that helps users plan journeys with the lowest environmental impact A: Anti-lock braking system. This is a safety-critical system so requires a lot of up-front analysis before implementation. It certainly needs a plan-driven approach to development with the requirements carefully analysed. A waterfall model is therefore the most appropriate approach to use, perhaps with formal transformations between the different development stages. Virtual reality system. This is a system where the requirements will change and there will be an extensive user interface components. Incremental development with, perhaps, some UI prototyping is the most appropriate model. An agile process may be used. University accounting system. This is a system whose requirements are fairly well-known and which will be used in an environment in conjunction with lots of other systems such as a research grant management system. Therefore, a reuse-based approach is likely to be appropriate for this. Interactive travel planning system. System with a complex user interface. An incremental development approach is the most appropriate as the system requirements will change as real user experience with the system is gained. PS: To be honest, I am quite confused about this reference answer cus NEITHER OF THESE ANSWERS is in the slides. So just have a glance at the answer, it’s common to stuck on these questions. Q: Explain why incremental development is the most effective approach for developing business software systems. Why is this model less appropriate for real-time systems engineering?A: Business software systems usually complex, software intensive, and frequently being changes when business goals or processes are changed. So incremental development is better. 业务目标或过程发生变化时经常发生变化。所以增量开发更好。Real-time systems usually involve many hardware components which are not easy to change and cannot be incremental. Also real-time systems usually safety critical which needed be built based on well planned process. 实时系统通常包含许多硬件组件，这些硬件组件不容易更改，也不能增量。此外，实时系统通常是安全的关键，需要建立在良好的计划过程。 Q: Consider the reuse-based process model. Explain why it is essential to have two separate requirements engineering activities in the process.A:In a reuse based process, you need two requirements engineering activities because it is essential to adapt the system requirements according to the capabilities of the system/components to be reused. These activities are: An initial activity where you understand the function of the system and set out broad requirements for what the system should do. These should be expressed in sufficient detail that you can use them as a basis for deciding of a system/component satisfies some of the requirements and so can be reused. 一个初步的活动，在这个活动中，您了解系统的功能，并为系统应该做什么设定广泛的需求。这些应该以足够详细的方式表达，以便您可以将它们作为决定系统/组件是否满足某些需求的基础，从而可以重用。 Once systems/components have been selected, you need a more detailed requirements engineering activity to check that the features of the reused software meet the business needs and to identify changes and additions that are required. 一旦选择了系统/组件，您需要一个更详细的需求工程活动来检查重用软件的特性是否满足业务需求，并确定所需的更改和添加。 Q: Suggest why it is important to make a distinction between developing the user requirements and developing system requirements in the requirements engineering process.A:There is a fundamental difference between the user and the system requirements that mean they should be considered separately. The user requirements are intended to describe the system’s functions and features from a user perspective and it is essential that users understand these requirements. They should be expressed in natural language and may not be expressed in great detail, to allow some implementation flexibility. The people involved in the process must be able to understand the user’s environment and application domain. 用户需求旨在从用户的角度描述系统的功能和特性，用户理解这些需求是至关重要的。总的来说就是用户没有方法表达的太清楚，需要开发人员理解用户的需求。 The system requirements are much more detailed than the user requirements and are intended to be a precise specification of the system that may be part of a system contract. They may also be used in situations where development is outsourced and the development team need a complete specification of what should be developed. The system requirements are developed after user requirements have been established. 系统需求要比用户需求详细得多，并且要成为系统合同的一部分的系统的精确规范。当开发被外包，并且开发团队需要一个完整的关于应该开发什么的规范时，也可以使用它们。系统需求是在建立用户需求之后开发的。 References XJTLU MC PowerPoint Slides (CPT203 Week2 Lecture2)","link":"/2021/09/20/CPT203-W2/"},{"title":"CAN201 W2","text":"This is the note of CAN201(introduction to networking). This lecture is mainly discussing about Application Layer. 应用程序层 Principle of network application Web application Email The lab of this week is about Introduction of Python. LectureRich network applications Communication: Email, IM, SNS Web: countless Internet games: countless Video based: TikTok VoIP / Meeting: Zoom P2P file sharing: BitTorrent, Thunder… Architectures for applications Client-server peer to peer 所有的applications都是这两个架构 Client-server architecture Server Always-on host 不间断的主机 Permanent IP address 永久ip地址 High performance 高性能 / Distributed computing Clients Link to the server for service 连接服务器进行服务 May be intermittently connect to the internet 可能是间歇性连接到互联网 Dynamic IP address 动态ip地址 Do not communicate directly with each other P2P architecture No always-on server is needed Arbitrary end systems directly exchange data Peers request service from other peers, provide service in return to other peers Self scalability new peers bring new service capacity, as well as new service demands Peers are intermittently connected Dynamic IP addresses How to communicate over the network?Host –&gt; Sockets 插座 –&gt; NetworkA program with: identifier protocol.IP地址标记主机，port标记主机里的进程。 Host - Program process: a program running within a host processes in different / same hosts: socket can be used to exchange messages Processes in the same host: Inter-process communication defined by OS CS architecture: Client process: initiates communication Server process: waits to be contacted P2P architecture: client process / server process on the same host Addressing processes Host device has unique 32-bit IPv4 and/or 128-bit IPv6 Process network identifier: IPv4:port 192.168.1.100:80 [IPv6]:port [240e:3a1:4cb1:69d0:f40c:4269:74a2:7ea3]:80 App-layer protocol defines Types of messages exchanged request, response Message syntax what fields in messages &amp; how fields are delineated Message semantics: meaning of information in fields Message timing: when and how 一共两种协议Open protocols: 公开协议 Defined in RFCs Allows for interoperability e.g., HTTP, SMTP, FTP Closed protocols: 私有协议 e.g., Skype, Games, you own protocols… Transport service requirementsThere’re 4 requirements in transport service: 必须遵守 (应用协议) data integrity throughput timing security Internet transport protocols services (传输层协议) TCP 传输控制协议 UDP 用户数据报协议 TCP service Reliable transport between sending and receiving process 发送和接收过程之间的可靠传输 Flow control 流量控制: sender won’t overwhelm receiver 发送方不会淹没接收方 Congestion control 拥塞控制: throttle sender when network overloaded 当网络过载时限制发送者 Does not offer 不提供: timing, minimum throughput guarantee, security 记时，最低吞吐量保证，安全性 Connection-oriented 面向连接: setup required between client and server processes 需要在客户端和服务器进程之间进行设置 Internet transport protocols servicesThe problems with UDP service: unreliable data transfer between sending and recieving process Does not offer: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup. 不提供: 可靠性,流量控制,拥塞控制,时间,吞吐量保证,安全性或连接设置 Securing TCPSecure Sockets Layer - SSL TCP &amp; UDP No encryption 无加密 Cleartext psws 明文程序状态字 –&gt; Internet SSL Provides encrypted TCP connection 提供加密TCP连接 Data integrity 数据完整性 End-point authentication 端点认证 SSL is at app layer Apps use SSL libraries, that “talk” to TCP SSL socket API Cleartext psw 明文程序状态字 –&gt; encrypted psw –&gt; Internet Web applicationWeb, HTTP and WWW World Wide Web: WWW HTTP: Hypertext Transfer Protocol Web page consists of base HTML-file which includes several referenced objects, addressable by a URL 网页上的每一个对象都通过url进行寻址 HTTP overviewHTTP: hypertext transfer protocol 超文本传输协议 Application layer protocol 应用层协议 Client/server model Client: browser that requests, receives, (using HTTP protocol) and show Web objects (Render) Server: Web server sends (using HTTP protocol) objects in response to requests Uses TCP: Client initiates TCP connection (creates socket) to server, port 80 客户端发起TCP连接到服务器，端口80 Server accepts TCP connection from client 服务器接受来自客户端的TCP连接 HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server) 在浏览器和Web服务器之间交换HTTP消息 TCP connection closed TCP连接关闭 HTTP is “stateless”: server maintains no information about past client requests. HTTP是“无状态的”:服务器不维护关于过去客户端请求的信息。 Protocols that maintain “state” are complex! past history (state) must be maintained. if server/client crashed, their view of “state” may be inconsistent, must be reconciled. 如果服务器/客户端崩溃，他们的“状态”视图可能不一致，必须协调 Non-persistent HTTP 非持久性HTTP At most one object sent over TCP connection 最多一个对象通过TCP连接发送 Downloading multiple objects required multiple connections 下载多个对象需要多个连接 Persistent HTTP 持久HTTP Multiple objects can be sent over single TCP connection between client, server 客户端和服务器之间可以通过单个TCP连接发送多个对象 Non-response time Persistent HTTPNon-persistent HTTP issues Requires 2 RTTs per object 每个对象需要2个rtt OS overhead for each TCP connection 每个TCP连接的操作系统开销 Browsers often open parallel TCP connections to fetch referenced objects 浏览器经常打开并行TCP连接来获取引用的对象 Persistent HTTP issues Server leaves connection open after sending response 服务器在发送响应后保持连接打开 Subsequent HTTP messages between same client/server sent over open connection 在同一个客户端/服务器之间通过开放连接发送的后续HTTP消息 Client sends requests as soon as it encounters a referenced object 客户端一遇到引用对象就发送请求 As little as one RTT for all the referenced objects 对于所有引用的对象，只有一个RTT Persistent HTTP is not perfect HTTP request message Two types of HTTP messages: request, response HTTP 1.x request message: ASCII (human-readable format) general format HTTP 1.1 methodWhat do we need from a web protocol?Get, Create, Modify, Delete —- resource / data / information HTTP 1.0 1.1 Additional methodsGet, Post, Put, Delete, Patch —- Safe MethodsHead, Trace, Options, Connect —- Idempotent Methods 幂等方法 HTTP response status codes Status code appears in 1st line in server-to-client response message. Some sample codes: 200 OK 301 Move Permanently 400 Bad Request 404 Not Found 505 HTTP Version Not Supported User-server state: cookies many web sites use cookie four components: cookie header line of HTTP response message HTTP响应消息的cookie报头行 cookie header line in next HTTP request message 下一个HTTP请求消息中的cookie头行 cookie file kept on user’s host, managed by user’s browser cookie文件保存在用户的主机上，由用户的浏览器管理 back-end database at web site 网站的后端数据库 Example:Bob always access Internet from PC and visits Taobao site for first time. When initial HTTP requests arrives at site, site creates: unique ID –&gt; cookie, entry in backend database for ID. cookiesWhat cookies can be used for: cookies可以用来做什么 authorization 授权 shopping carts 购物车 recommendations 建议 user session state 用户会话状态 How to keep “state”: Protocol endpoints: maintain state at sender/receiver over multiple transactions 协议端点:在多个事务中维护发送方/接收方的状态 Cookies: http messages http消息 Cookies and privacy: cookies permit sites to learn a lot about you; remember to clean your cookies. Cookies允许网站了解更多关于你的信息。 Web Caches web缓存(Proxy server代理服务器)Goal: satisfy client request without involving origin server 满足客户端请求而不涉及原始服务器 User sets browser: Web accesses via cache 用户设置浏览器:通过缓存访问Web Browser sends all HTTP requests to cache 浏览器将所有HTTP请求发送到缓存 object in cache: cache returns object 缓存返回对象 else cache requests object from origin server, then returns object to client 从源服务器缓存请求对象，然后返回对象给客户端 Cache acts as both client and server 缓存既是客户端也是服务器端 server for original requesting client 服务器为原始请求客户端 client to origin server 客户端到源服务器 Typically cache is installed by ISP (university, company, residential ISP) 缓存通常由ISP安装 Why web caching? reduce response time for client request 减少客户的要求的反应时间 reduce traffic on an institution’s access link 减少机构访问链接的流量 internet dense with caches: enable “poor” content provides to effectively deliver content (so too does P2P file sharing) 使“糟糕的”内容提供商能够有效地传递内容 cache exampleAssumptions: avg object size: 100K bits avg request rate from browsers to origin servers: 15/sec avg data rate to browsers: 1.50 Mbps 100k*15 RTT from institutional router to any origin server: 2 sec access link rate: 1.54 Mbps Consequences: LAN utilization: 0.15% access link utilization = 99% 1.50/1.54 无限拥塞，以分钟做为单位 total delay = Internet delay + access delay + LAN delay = 2 sec + minutes + usecs conditional GET Goal: don’t send object if cache has up-to-date cached version no object transmission delay lower link utilization cache: specify date of cahced copy in HTTP request If-modified-since: server response contains no object if cached copy is up-to-date: HTTP/1.0 304 Not Modified EmailHow Email Works: A user (Alice) sends an email message and connects to an SMTP (Simple Mail Transfer Protocol) server as configured in her email client or Mail User Agent (MUA). 用户发送电子邮件消息并连接SMTP服务器配置在她的电子邮件客户端或邮件用户代理。 On the SMTP server, a Mail Transfer Agent (MTA) looks at the recipient address and looks up the domain part of the address to determine its destination. 在SMTP服务器上，邮件传输代理查看收件人地址并查找地址的域部分以确定其目的地。 After querying a Domain Name System (DNS) server for the name of the Mail eXchanger (MX) for the recipient’s domain name… 在DNS服务器上查询收件人域名的Mail exchange名称后 …the SMTP server will send the message to that server via the SMTP protocol. SMTP服务器将通过SMTP协议将消息发送到该服务器。 The receiving server will store the message and make it available to the recipient (Bob), who can access it via web, POP, or IMAP. 接收服务器将存储消息并使其对接收方可用，接收方可以通过web、POP或IMAP访问该消息。 Email ProtocolsComponents: mail user agent 先从mua发送到ms 然后ms发送到另外一个ms ms再送到收件人的mua mail server 邮件服务器 SMTP (protocol) Delivery: SMTP: simple mail transfer protocol[RFC2821, Apr. 2001] Receive: POP3 - Post Office Protocol - Version 3[RFC1939, May 1996] IMAP - Internet Message Access Protocol[RFC3501, Mar. 2003] Exchange ActiveSync – Microsoft’s protocol[from 2002] Lab1234567891011121314151617import re # 为正则表达式引入的re库input_str = input(f'input: ')# 通过正则表达式，提取出两种形式的数字，第一种是整数，第二种是带小数点的数字numbers = re.findall(r&quot;\\d+\\.?\\d*&quot;, input_str)number_list = []location_list = []for number in numbers: if '.' in number: number_list.append(float(number)) else: number_list.append(int(number))number_list.sort()# .sort()方法没有返回值，所以不能直接用print()输出，假如是sorted就可以直接输出print(number_list)for number in number_list: location_list.append([input_str.index(str(number)), len(str(number))])print(location_list) References XJTLU MC PowerPoint slides (CAN201 Week2 Lecture2 &amp; Lab2) 计算机网络 自顶向下方法.原书第6版","link":"/2021/09/17/CAN201-W2/"},{"title":"Python爬虫入门","text":"这学期暑假的时候，打开了Learning mall下载下学期的课件，但是却发现LM并没有批量下载功能，最后只能通过一个一个点击来下载。无疑这是一个体验非常不好的过程。所以想写一个爬虫来下载learning mall的课件和资料。遇到的问题是learning mall是需要登陆才能下载的，登陆无疑是爬虫操作中的一个较难解决的问题。这篇文章会通过爬豆瓣图片的过程和爬learning mall来讲解如何使用Python爬虫解决生活实际问题。 需要准备的工具有: Pycharm, Chrome(安装插件XPath helper) 抓取豆瓣图片爬虫过程分为四步 找到数据 发送地址请求 数据解析 数据保存 目前爬的这个豆瓣页面不需要登陆，但是需要翻页，后面会尝试爬learningmall的课件，那个需要虚拟登陆，但是应该不需要翻页。我们在爬的过程中一定要注意是适度，要是爬的过分可能会导致别人的网页崩溃，就直接进局子了。 找到数据 第一步是先要找到数据，请求URL地址。 第二步是随机大概我们要爬取的一个文件，通过开发者模式打开之后，找到header底下的User-Agent。 我们要通过User-Agent来伪装我们的访问，防止被直接Forbidden 403反爬。 以我的电脑为例: 12url = f'https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=0&amp;sortby=like&amp;size=a&amp;subtype=a'headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36'} 发送地址请求 声明变量response，利用requests库的get提取页面的内容并保存在response中。 声明html_data，把response转换成text格式储存进去。 可以通过print来看一下我们保存的内容是否包含了我们想要抓去的内容。 html_data需要我们用正则表达式来表达: 123response = requests.get(url=url, headers=headers) # 把请求伪装成一般的浏览器html_data = response.textprint(html_data) # 正则 数据解析XPath helper的用法: 打开Chrome 安装XPath helper 打开开发者模式，通过分析html标签，找到我们需要的位置 //表示定位标签，/表示前面标签的下级标签，定位到具体元素的时候用@ 我们获得html_data需要定位哪些内容是我们需要爬取的内容，这是就需要用到XPath helper。 安装parsel库，通过这个库转化html_data的数据类型。 用XPath定位分析html标签，找到我们需要的内容的具体url位置。 把这些具体的二级页面的url储存在href_list里。 对于href_list中的二级页面，我们利用分析一级页面的方法再次分析一次，找到要下载的资源具体的URL链接放入img_list。 这时候我们已经可以打印出来我们需要的图片具体的url了。 12345678910111213selector = parsel.Selector(html_data) # 转换数据类型href_list = selector.xpath('//div[@class=&quot;cover&quot;]/a/@href').getall()print(href_list)for href in href_list: # 发送图片链接的请求 print(f'当前图片页面地址:', href) response_2 = requests.get(url=href, headers=headers).text # 第二次数据解析 解析图片的url地址 selector_2 = parsel.Selector(response_2) img_list = selector_2.xpath('//div/a[@class=&quot;mainphoto&quot;]/img/@src').getall() print(img_list) 数据保存既然所以我们需要的内容都已经保存在img_list里了，因为我们这次下载的是图片，所以就最后的结果放在img文件夹里。 用for循环遍历img_list里的每一个元素。 为了不让程序爬的太快被封，我们加上一段sleep，减缓一下爬取的速度。 通过split分割并用最后一段命名文件名。 保存文件至img文件夹。 12345678for img in img_list: img_data = requests.get(url=img, headers=headers).content # 这里的数据是二进制 所以用content time.sleep(1) # 延时1秒 刚开始是5秒 但是速度太慢了 file_name = img.split('/')[-1] # 准备文件名 通过 / 分割 把分割出来的最后一部分作为文件名 with open('img/' + file_name, mode='wb') as f: f.write(img_data) print('保存成功:', file_name) 实现翻页但是这还没有结束，因为这样的爬虫只能爬到第一页的图片，而我们想要他爬到的所有的图片，所以我们需要添加上翻页的功能。 page2的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=30&amp;sortby=like&amp;size=a&amp;subtype=a page3的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=60&amp;sortby=like&amp;size=a&amp;subtype=a page26的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=750&amp;sortby=like&amp;size=a&amp;subtype=a 所以估计page1的url就是把30改为0，事实也确实如此，所以我们在整个程序的开头套上一个page作为for循环。爬取的内容一共只有26页，所以我们设置边缘也就是0-750。 1234page_num = 0for page in range(0, 751, 30): # 每30翻一页 一共750页 page_num += 1 print(f'----------正在爬取第{page_num}页----------') 豆瓣爬虫总结这样我们就实现了完整的豆瓣爬图片的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243import time # 延时用的 爬的太快了容易被发现 把别人网站爬塌了就进局子了import requests # 第三方模块 terminal: pip install requestsimport parsel # 第三方模块 terminal: pip install parselpage_num = 0for page in range(0, 751, 30): # 每30翻一页 一共750页 page_num += 1 print(f'----------正在爬取第{page_num}页----------') # 1. 找到数据 请求url地址 url = f'https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start={page}&amp;sortby=like&amp;size=a&amp;subtype=a' # 随便找到一个图片 开发者模式打开之后找到`header`下的`User-Agent` headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36'} # 2. 发送地址请求 response = requests.get(url=url, headers=headers) # 把请求伪装成一般的浏览器 html_data = response.text # print(html_data) # 正则 # 3. 数据解析 selector = parsel.Selector(html_data) # 转换数据类型 href_list = selector.xpath('//div[@class=&quot;cover&quot;]/a/@href').getall() # print(href_list) for href in href_list: # 发送图片链接的请求 print(f'当前图片页面地址:', href) response_2 = requests.get(url=href, headers=headers).text # 第二次数据解析 解析图片的url地址 selector_2 = parsel.Selector(response_2) img_list = selector_2.xpath('//div/a[@class=&quot;mainphoto&quot;]/img/@src').getall() # print(img_list) for img in img_list: img_data = requests.get(url=img, headers=headers).content # 这里的数据是二进制 所以用content # 4. 数据保存 time.sleep(1) # 延时1秒 刚开始是5秒 但是速度太慢了 file_name = img.split('/')[-1] # 准备文件名 通过 / 分割 把分割出来的最后一部分作为文件名 with open('img/' + file_name, mode='wb') as f: f.write(img_data) print('保存成功:', file_name) 下面将会介绍如何爬取learningmall中的课件和资料。 Learning Mall 爬虫To be continued… References Python爬虫教程入门教程：从零带你采集某度约会吧上全部小姐姐高清图片，爱了嘛？","link":"/2021/09/12/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"title":"CAN201 W1","text":"This is the note of CAN201(introduction to networking). The lecture of W1 is mainly discussing about Internet. What’s the Internet? Network edge and core Network performance Protocol layers and service models Network security 这星期主要是对这学期所要学习的内容大致的介绍，由预习笔记改编完成。The lab of this week is about Python I - IDE and Interpreter. LectureWhat’s the Internet?Many forms: application, hardware, ongoing… How does the Internet work?People access Internet with Wi-Fi, 4G and so on.Medium: optical fiber光纤, metal, radio…Methods: Packet switches 分组交换 Protocols协议: TCP/IP, HTTP, 802.11 Framework: Layered(from global to local): ISO/OSI - 7, IP stack - 5 Protocols协议Protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt.协议定义格式，在网络实体之间发送和接收消息的顺序，以及在消息传输和接收时所采取的动作。Network protocols: Machines rather than humans All communication activity in Internet governed by protocols. 所有互联网上的活动都收到协议的控制。 How to build the Internet world?Infrastructure 基础设施 Communication Channel 沟通渠道 Provided by ISP 由ISP提供 Computing Service Servers or Cloud Provided by institutions or Cloud Service Provider 由机构或云服务提供商提供 Applications A variety of applications with nice GUI 应用程序 Provided by many companies and developers 公司和开发者 StandardsIETF (Internet Engineering Task Force)https://www.ietf.org/This’s their website. Network edge and coreNetwork edge = Host: 主机 Clients: PCs, Mobile phones, Smart Servers: normally hosted in data centers Physical media to access networks: Wired or wireless communication links Network core: Interconnected routers 互联路由器 Network of networks Access networks and physical mediaHow to connect end systems to edge router? 如何连接终端系统到边缘路由器 Residential access nets 住宅 Institutional access networks 机构 Mobile access networks 移动设备 Keep in mind: Bandwidth (bits per second) of access network? 网络的访问带宽 Shared or dedicated? 共享还是专用 Dial-up Internet accessDial-up Internet access is a form of Internet access that uses the facilities of the public switched telephone network (PSTN) to establish a connection to an Internet service provider (ISP) by dialing a telephone number on a conventional telephone line. Dial-up connections use modems to decode audio signals into data to send to a router or computer, and to encode signals from the latter two devices to send to another modem.拨号互联网接入是利用公共电话交换网(PSTN)的设施，通过在传统电话线上拨打电话号码，与互联网服务提供商(ISP)建立连接的互联网接入形式。拨号连接使用调制解调器将音频信号解码成数据发送到路由器或计算机，并将后两个设备发出的信号编码发送到另一个调制解调器。带宽: 56 Kbps Digital subscriber lineaka DSL 数字用户线Telephone line based: to central office DSL Access Multiplexer aka DSLAM data over DSL phone line goes to internet voice over DLS phone line goes to telephone net 带宽: Upstream transmission rate &lt; 2.5 Mbps (typically &lt; 1Mbps) 上行传输速率 Downstream transmission rate &lt; 24 Mbps (typically &lt; 10Mbps) 下行传输速率 ADSL = Asymmetric Digital Subscriber Line 非对称数字用户线路 Access network: cable network (TV net based)接入网:有线网络(基于电视网络)key technology: Frequency division multiplexing (FDM) 频分复用 Different channels transmitted in different frequency bands 不同的信道在不同的频段传输 HFC: hybrid fiber coax 混合光纤同轴电缆 Asymmetric: 30Mbps downstream transmission rate, 2 Mbps upstream transmission rate. 非对称:下行速率为30Mbps，上行速率为2mbps。 Access network: fiber to the home光纤到家 Access network: home network Enterprise access networks (Ethernet)以太网（企业用）Typically used in companies, universities, etc.10 Mbps, 100Mbps, 1Gbps, 10Gbps transmission rates.Today, end systems typically connect into Ethernet switch. 终端系统通常连接到以太网交换机。 Wireless access networksShared wireless access network connects end system to router ,via base station, aka “access point”. 共享无线接入网将终端系统连接到路由器，通过基站，也就是“接入点”。 Physical mediatwisted pairtwo insulated copper wires 双绝缘铜线 category 5:100 Mbps, 1 Gbps Ethernet category 6:10 Gbps coaxial cabletwo concentric copper conductors 两根同心铜导线 bidirectional 双向 broadband: multiple channels on cable 宽带 fiber optic cableglass fiber carrying light pulses, each pulse a bit 玻璃纤维携带光脉冲，每个脉冲一点 high-speed operation: high-speed point-to-point transmission 点对点高速传输 low error rate: repeaters spaced for apart, immune to eletromagnetic noise 中继器间隔，不受电磁噪声影响 radioSignal carried inelectromagnetic spectrum 电磁波谱中携带的信号 No physical “wire” bidirectional 双向Propagation environment effects: 传播环境影响 Reflection Obstruction by objects 物体的阻碍 Interference! 干扰 Radio link types: Wireless LAN (e.g., WiFi) 54 Mbps – 9.6Gbps Wide-area (e.g., cellular) 4G cellular: ~ 100 Mbps 5G cellular: ~ 1Gbps Satellite Kbps to 45Mbps channel (or multiple smaller channels) Starlink ~ 1440Mbps 270 msec end-end delay Network Core Mesh of interconnected routers. 互连路由器的网状结构 Packet-switching: 分组交换 Hosts break application-layer messages into small packets. 主机将应用层消息分解成小数据包 Packages are forwarded from one router to the next, across links on path from source to destination. 包从一个路由器转发到下一个路由器，在从源到目的地的路径上跨越链接 Two key network-core functions Routing: determines source- destination route taken by packets (routing algorithms) 路由:确定数据包采取的源-目的路由。 Forwarding: move packets from router’s input to appropriate router output. 转发:将数据包从路由器的输入端移动到相应的路由器输出端。 Packet Switchingstore-and-forward queueing delay, lossif arrival rate (in bits) to link exceeds transmission rate of link for a period of time: 如果一段时间内到达链路的速率超过了链路的传输速率 packets will queue, wait to be transmmitted on link 报文将排队，等待链路传输 packets can be dropped (lost) if memory (buffer) fills up 如果内存(缓冲区)被填满，包会被丢失 Circuit switching dedicated resources专用资源: no sharing circuit-like (guaranteed) performance 电路性能 Circuit segment is idle if not used by call (no sharing) 如果没有调用，电路段空闲 Commonly used in traditional telephone networks FDM &amp; TDM Packet VS CircuitPacket switching allows more users to use network! 分组交换允许更多的用户使用网络。Is packet switching a “winner?” PS advantages: resource sharing simpler, no call setup PS drawbacks: excessive congestion possible: delay and loss protocols needed for reliable data transfer, congestion control How to provide circuit-like behavior PS? Bandwidth guarantees New methods should be developed Internet: Network of networks End systems connect to Internet via access ISPs (Internet Service Providers) 终端系统通过接入isp(互联网服务提供商)连接到互联网 residential, company and university ISPs Access ISPs in turn must be interconnected. 接入isp也必须相互连接 so that any two hosts can send packets to each other Resulting network of networks is very complex evolution was driven by economics and national policies Q: Given millions of access ISPs, how to connect them to together?Option 1: connect each access ISP to every other access ISPA: connecting each access ISP to each other directly doesn’t scale: O(N2) connections. 将每个访问ISP直接连接到彼此并不具有伸缩性:O(N2)连接。 Option 2: connect each access ISP to one global transit ISP Network performancePackage Loss, Delay and Bandwidth How do loss and delay occur? Four sources of packet delay dproc: nodal processing 节点处理 check bit errors 检查位错 determine output link 确定输出环节 typically &lt; msec dqueue: queueing delay 队列延迟 time waiting at output link for transmission 输出链路等待传输的时间 depends on congestion level of router 取决于路由器的拥塞水平 dtrans: transmission delay L: packet length (bits) R: link bandwidth (bps) dtrans = L/R dprop: propagation delay: d: length of physical link s: propagation speed (~2.9x10^8 m/sec) dprop = d/s dtrans and dprop very different. Queueing delay Packet Loss丢包 Queue (aka buffer) preceding link in buffer has finite capacity 队列前的链接在缓冲区有有限的容量 Packet arriving to full queue dropped (aka lost) 到达队列满的数据包被丢弃 Lost packet may be retransmitted by previous node, by source end system, or not at all 丢失的数据包可以由前一个节点、源端系统重传，或者根本不重传 Throughput吞吐量Definition: rate (bits/time unit) at which bits transferred between sender/receiver 在发送方/接收方之间传输比特的速率Two kinds of throughput: instantaneous瞬时: rate at given point in time 给定时间点的速率 average平均: rate over longer period of time 较长时期内的比率 服务器传送bits到管道里，管道带着fluid以Rsbits/sec速度运行，穿过buffer之后以Rcbits/sec速度运行，最后到达用户处 Internet ScenarioPer-connection end-end throught: min{Rc,Rs,R/10}In practice: Rc or Rs is often bottleneck. Protocol layers and service modelsInternet protocol stack五层结构！！！ ISO/OSI reference model Encapsulation封装Why layering? 为什么要分层 divide complex systems to simple components 把复杂的系统分割成简单的部分 easy to maintenance 易于维护 flexible for updating 可以灵活的升级 Network securityQ: Field of network security how bad guys can attack computer networks how we can defend networks against attacks how to design architectures that are immune to attacks Q: Internet not originally designed with (much) security in mind Original vision: “a group of mutually trusting users attached to a transparent network” Internet protocol designers playing “catch-up” Security considerations in all layers Types Malware恶意软件: virus, worm, spyware 病毒、蠕虫、间谍软件 DDoS: Distributed denial of service attack 分布式拒绝服务攻击 Packet “sniffing” 包嗅探 LabTask: Install Python and PyCharm Build a virtual Python runtime environment using Virtualenv Write a hello world code in a python script file (.py file) in PyCharm Study variables and print in Python – number / string / list / dict Study conditionals in Python Study loops – for and while 这就没必要写了，INT104都学过了。就是打出一个”Hello World”就没有了。 123456def print_hi(name): print(f'Hi, {name}')if __name__ == '__main__': print_hi('Pycharm') References XJTLU MC PowerPoint slides (CAN201 Week1 Lecture1 &amp; Lab1) 计算机网络 自顶向下方法.原书第6版","link":"/2021/09/10/CAN201-W1/"},{"title":"CPT205 W1","text":"This is the note of CPT205(Computer Graphics).包括了Lecture还有Lab的内容，是在预习笔记上增加了一些内容。 The lecture of this week is mainly discussing about Introduction: hardware and software. LectureWhat is Computer graphics?‘Computer Graphics’ is concerned with all aspects of producing pictures or images using a computer. There are three closely related meanings, each representing a different perspective on the same thing. the images that you see on the computer screen the computer code that is used to create the images a mathematical model of the real-world (which is sometimes called the virtual world) When working at the most advanced levels of Computer Graphics, the computer graphics specialist will create a virtual world implement the virtual world in computer code run the code to see life-like images on the computer screen How do the individual subjects relate?Two subjects are at the heart of computer graphics: 2D Computer Graphics 3D Computer Graphics What are the application areas? Display of information Design Simulation and animation User interfaces Hardware and Software Graphics Hardware Input, Processing and Output Devices Framebuffers Pixels and Screen Resolution Graphics Software Techniques (Algorithms, Procedures) Programming Library / API (OpenGL, JOGL and so on) Not our focus: High level Interactive Systems (Maya, Studio Max, Unity, AutoCAD and so on) Graphics devices Input Devices Processing Devices Output Devices In this order! FramebufferWhat is framebuffer?A block of memory, dedicated to graphics output, that holds the contents of what will be displayed. What is pixel?An element of the framebuffer. Framebuffer in memoryIf we want a framebuffer of 640 pixels by 480 pixles.How many bits should we allocate?framebuffer = 640*480 bitsQ: What do more bits get you?A: More values to be stored at each pixel. bit depthNumber of bits allocated per pixel in a buffer. How much memory we allocate to store the color at each pixel?Common Aswer: 32bits RGBA 32 bits perpixel (true colour) 8 bits for red, green, blue and alpha potential for 256 reds, greens and blues total colours: 16,777,216 (more than the eye can distinguish) Data type refresher7 types of data type refresher: bit - a 0 or 1. Can represent 2 unique values. byte - 8 bits or 256 values. word - 32 bits or 4,294,967,296 values. int - 32 bits. float - 32 bits. double - 64 bits. unsigned byte - 8 bits. How much memory is on our graphic card?三种，分别是: 640 * 480, 1024 * 768, 1600 * 1200 640 * 480 * 32 bits = 1,228,800 bytes 1024 * 768 * 32 bits = 3,145,728 bytes 1600 * 1200 * 32 bits = 7,680,000 bytes Framebuffer -&gt; monitorThe values in the framebuffer are converted from a digital (1s and 0s representation, the bits) to an analog signal that goes out to the monitor. This is done automatically (not controlled by your code), and the conversion can be done while writing to the framebuffer. 帧缓冲区中的值被从数字转换为输出到监视器的模拟信号。这是自动完成的，转换可以在写入framebuffer时完成。 Image quility issues Screen resolution Colour Refresh rate Brightness Contrast Sensitivity of display to viewing angle PixelsPixel: The most basic addressable image element in a screen CRT: Colour triad (RGB phosphor dots) LCD: Single colour element Screen resolution: measure of number of pixels on a screen. (m by n) m: Horizontal screen resolution n: Vertical screen resolution Video formats NTSC: 525x480,30f/s, interlaced PAL: 625x480,25f/s, interlaced VGA: 640x480,60f/s, non-interlaced SVGA: 800x600,60f/s, non-interlaced RGB: 3 independent video signals and synchronisation signal, vary in resolution and refresh rate. 3个独立的视频信号和同步信号，不同的分辨率和刷新率。 Raster display 光栅/显像 Cathode Ray Tubes 阴极射线管 (CRTs), most “tube” monitors you might see. Used to be very common, but big and bulky. Liquid Crystal Displays 液晶显示器 (LCDs), there are two types transmissive (laptops, those snazzy new flat panel monitors) and reflective (wrist watches). Cathode ray tubes (CRTs)Strong electrical fields and high voltage. 强电场和高电压 Very good resolution. 非常好的分辨率 Heavy, not flat. 重，不平 Liquid crystal displays (LCDs)Flat 平 Light weight 轻重量 Low power consumption 低能耗 Graphics softwareHow to talk to the hardware?Algorithms, Procedures, Toolkits &amp; Packages(Low Level –&gt; High Level) Programming APIwhich helps to program in labs OpenGL (our focus) JOGL (Open GL for Java) etc. Special purpose softwarenot so important in our module Excel, Mathlab… AutoCAD, Studio Max… LabUnderstand how to create 2D and 3D graphic images using C++ and OpenGL graphics library.我用的是MacOS，所以戏比较多。 安装虚拟机选择的是Parallels，目前使用的是试用版。下载之后点击安装win10，再安装visual studio。 配置第一个OpenGL 解压freeglut至文件夹 Visual Studio打开创建空白文件 (C++) 修改配置 (细节见Lab文件) 点击运行 1234567891011121314151617181920212223242526272829#define FREEGLUT_STATIC // Define a static library for calling functions#include &lt;GL/freeglut.h&gt; // Include the header filevoid renderScene(void) // Function for geometric creation{ // Clear the buffer to the predefined color and depth value glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //Move origin of current user coordinate system to the screen center: similar to a reset operation glLoadIdentity(); glBegin(GL_TRIANGLES); // Start draw TRIANGLE function glVertex3f(-0.5, -0.5, 0.0); // Set coordinates of first vertex glVertex3f(0.5, 0.0, 0.0); // Set coordinates of second vertex glVertex3f(0.0, 0.5, 0.0); // Set coordinates of last vertex glEnd(); // End draw TRIANGLE function glutSwapBuffers(); // Refresh the screen to display the graphics}int main(int argc, char* argv[]) // Standard main function{ glutInit(&amp;argc, (char**)argv); // Initialization // Define display mode: depth buffer, double buffer and RGBA color glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA); glutInitWindowPosition(100, 100); // Define the location of the window glutInitWindowSize(320, 320); // Define the size of the window glutCreateWindow(&quot;Hello OpenGL&quot;); // Create a window called “Hello OpenGL” glutDisplayFunc(renderScene); // Set the first function glutMainLoop(); // Enter the GLUT event processing loop return 0; // Return an integer value} Reference XJTLU MC PowerPoint slides (CPT205 Lecture1 &amp; Lab1)","link":"/2021/09/08/CPT205-W1/"},{"title":"CPT203 W1","text":"This is the note of CPT203 (Software Engineering I). The lecture of W1 is mainly discussing about Intro to Software Engineering. Understand what software engineering is and why it is important. Understand that the development of different types of software systems may require different software engineering techniques. Understand some ethical and professional issues that are important for software engineers. I will add the tutorial to the note later. (if there is a tutorial on Thursday) 本笔记基于预习笔记增加了一些内容。 Chapter 1 is recommended for reference. BasicWhat’s a computer software?Computer software is the product that software professionals build and then support over the long term. It encompasses computer programs and associated documentation that execute within a computer of any size and architecture. Software products may be developed for a particular customer or may be developed for a general market. 计算机软件是软件专业人员构建并长期支持的产品。它包括在任何大小和结构的计算机中执行的计算机程序和相关的文档。软件产品可能是针对特定客户开发的，也可能是针对一般市场开发的。 Why is it important?Hence it affects nearly every aspect of our lives and has become pervasive(无处不在的) in our commerce, our culture, and our everyday activities. 影响人们生活的各个方面… What is software engineering?Software engineering is an engineering discipline (工程学科) that is concerned with all aspects of software production. 软件工程是一门涉及软件生产的各个方面的工程学科。 What is software system? More than a program System that operate throughout the entire organization People, documentation, training, technical support, software evolution Progamming和software development是有很大区别的，program可能就是几行很短的程序，而software development则是很多program的集合，他们在一起构成了一个完整的software。 IntroductionSoftware engineering is essential for the functioning of national and international societies. 不可缺少的。 Software failure &amp; successSoftware engineering is criticized as inadequate for modern software development. 被批评不适合现代软件开发。(wtf哪什么适合?) Two factors of failures increasing demands 增加的需求 low expectations 低期望值 However, we’re still gonna learn these shits.😅 Professional software development Amateur People in business write spreadsheet programs to simplify their jobs scientists and engineers write programs to process their experimental data hobbyists write programs for their own interest and enjoyment Professional vast majority of software development is a professional activity where software is developed for specific business purposes, for inclusion in other devices, or as software products such as information systems, CAD systems, etc. intended for use by someone apart from its developer is usually developed by teams rather than individuals It is maintained and changed throughout its life. Four important attributesFour important attributes that all professional software (课后习题) Maintainability 可维护性 Dependability and security 可靠性和安全性 Efficiency 效率 Acceptability 可接受性 Two kinds of software products Generic software products 通用软件产品 Customized software products 定制软件产品 The distinction between these system product types is becoming increasingly blurred. 两者之间的界限越来越模糊。 Software deterioration软件恶化软件是逻辑的而不是物理的系统元素，所以软件不会磨损。因此软件的故障率曲线应该是如图所示的“理想曲线”的形式，但实际上，在其生命周期内，软件将经历变化。当进行更改时，很可能会引入错误，导致故障率曲线出现如“实际曲线”所示的峰值。 Software engineeringSoftware engineering is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. 软件工程是一门工程学科，它涉及软件生产的各个方面，从系统规范的早期阶段到系统投入使用后的维护。 Engineering discipline工程纪律就是软件工程师工作的纪律规定。 All aspects of software production软件工程不仅仅涉及软件开发的技术过程。它还包括诸如软件项目管理和支持软件生产的工具、方法和理论的开发等活动。 Challenges for developing systemsWhat challenges for heterogeneity, business and social change and trust and security, identify other problems? (课后习题) Developing systems that are energy-efficient. Developing validation techniques for simulation systems Developing systems fro multicultural use Developing systems that can be adapted quickly to new business needs Designing systems for outsourced development Developing systems that are resistant to attack Developing systems that can be adapted and configured by end-users Finding ways of testing, validating and maintaining end-user developed systems Software engineering approachesA software process is a sequence of activities that leads to the production of a software product. 在软件工程中使用的系统方法被称为software process。 Four fundamental activities: Software specification 软件规范 Software development 软件开发 Software validation 软件验证 Software evolution 软件进化 Software engineering diversityDifferent types of systems need different development processes. Software engineering is a systematic approach to the production of software that takes into account practical cost, schedule, and dependability issues, as well as the needs of software customers and producers. 软件工程是软件生产的一种系统方法，考虑实际成本、进度和可靠性问题，以及软件客户和生产商的需求。 How this systematic approach is actually implemented varies dramatically depending on the organization developing the software, the type of software, and the people involved in the development process. 根据软件开发的组织、软件的类型以及参与开发过程的人员的不同，这种系统方法的实际实现方式有很大的不同。 Two major approaches: Sequential 顺序 Iterative 迭代 Software engineering ethics You must also behave in an ethical and morally responsible way if you are to be respected as a professional engineer. 作为一名专业工程师，如果你想受到尊重，你的行为必须符合道德规范和负责任的态度。 You should not use your skills and abilities to behave in a dishonest way or in a way that will bring disrepute to the software engineering profession. 你不应该使用你的技能和能力以一种不诚实的方式行事，或者以一种会给软件工程专业带来声誉的方式行事。 在某些领域，可接受的行为标准不受法律约束，而是受到更模糊的职业责任概念的约束。 Confidentiality 保密 Competence 能力 Intellectual property rights 知识产权 Computer misuse 计算机滥用 References XJTLU MC PowerPoint Slides (CPT203 Week1) SOFTWARE ENGINEERING Ninth Edition –Ian Sommerville","link":"/2021/09/07/CPT203-W1/"},{"title":"INT201 W1","text":"This is the note of INT201(Decision Computation and Language). The lecture of this week is mainly discussing about Preliminaries: principal mathematical ideas necessary to understand the material of the course. 根据预习的笔记修改了一些内容。 Decision, Computation and LanguageThis module is about the theory of computation and answering the question: “What are the fundamental capabilities and limitations of computers?”这个模块是关于计算理论的，并回答这个问题:“计算机的基本能力和局限性是什么?”The central theme: Are the languagues, their membership problems can not be solved (computed) Algorithmically. Lecture 1LanguageFormal languages have the property that there is a precise rule that governs what strings belong to the language.正式语言包括了programming languages, database query languages, various file formats.然而English, Mandarin这种并不是Formal languages. what the module is about notations for representing formal languages. These give us ways to define them precisely ways to build compilers that recognise the languages ways to check whether a string of symbols belongs to a language whether two alternative descriptions of languages are actually the same language tools to analyse languages natural languages (NL): want to recognise valid sentence 自然语言 programming languages (PL): want to recognise valid program 编程语言 Some notations/methods for describing a language (other than explicitly listing it) include finite state automaton 有限状态自动机 regular expressions 正则表达式 context-free grammar 上下文无关语法 pushdown Automation 叠加自动化 Turing machine 图灵机 Observations 语法可以生成毫无意义的句子。 可以生成任意长的句子。 语义可以根据语法来确定，例如由单词“and”组成的子句的逻辑连接。 语法可以扩展到处理从句、副词等。 你不能完全用这种方式定义自然语言句子，但你可以用这种方式定义编程语言。 Stages of compilation lexical analysis: divide sequence of characters into tokens, such as variable names, operators, labels. In a natural language tokens are strings of consecutive letters (easy to recognise!) 将字符序列划分为符号 parsing: identify relationships between tokens 辨别符号之间的关系 code generation: generate object code 集成目标代码 code optimisation 代码优化 lexical analysis 词法分析1pay=salary+(overtimerate*overtime); Break into tokens as follows: 123456789pay=salary+( overtimerate*overtime); 这就是一个把句子拆开成token的过程 Parse Tree Definitions and notationNothing serious, man. Languagesε is nothing and it’s a word. This’s not an empty set. Empty set is a language.A language (or formal language) over alphabet A is a subset of A*.L1L2 ={w1w2: w1 ∈ L1 and w2 ∈ L2}. L1L2是两个集合中的所有元素两两组合之后的集合L* = {w1w2…wn: n ≥ 0 and w1,w2,…wn ∈ L} L*是一个集合元素中任意组合 Lecture 2Deterministic Finite Automata 确定性有限自动机Can be used a model for what happens during lexical analysis — scan program from beginning to end and divide it into tokens. 可以用一个模型来描述词法分析过程中发生的事情——从头到尾扫描程序，并将其划分为标记。Finite automata are used to specify tokens of programming languages. 有限自动机用于指定编程语言的标记。Also used in “model checking”, reasoning about systems with objective of proving they satisfy useful properties. 也用于“模型检验”，即以证明系统满足有用性质为目标的推理。Also used in statistical models for analysing biological and textual sequences. 也用于分析生物和文本序列的统计模型。DFA适用的对象: 任意有限长的字符串 任意无限长的有限字符串组成的列表 DFA适用的匹配模式: 保证某个字符出现次数不多于几次；保证字符串长度不超过多少；保证字符b永远出现在字符a后DFA不适用的匹配模式：如：字符串列表中a开头的字符串数量多于b开头的字符串；字符串回文；有意义的算数表达式 不知道为什么这个让我想到了BST。可能这就是为什么说DFA可以用于”模型验证”。 A deterministic finite automaton (DFA) has 5 components: Q is a finite nonempty set whose members are called states of the automaton; Q是一个有限的非空集，其成员称为自动机的状态; A is a finite nonempty set called the alphabet of the automaton; A是一个有限的非空集被叫做字母表的自动机; φ is a map from Q × A to Q called the transition function of the automaton; φ是一个从Q × a到Q的映射，称为自动机的转移函数; i is a member of Q and is called the initial state; i是Q的一个元素，称为初始状态; T is a nonempty subset of Q whose members are called terminal states or accepting states. T是Q的一个非空子集，其成员称为终端状态或接受状态。 因此，假如Q = {q0,q1,q2}，所以q0是初始状态，唯一的接受状态是q1，也就是说终结状态T是q1。接受语言L(有01子串的串的语言)的自动机A的完整描述是A = ({q0,q1,q2},{0,1},φ,q0,{q1})。φ是转移函数。 State of a machine tells you something about the prefix that has been read so far. If the string is a member of the language of interest, the state reached when the whole string has been scanned will be an accepting state (a member of T ). 机器的状态告诉您有关到目前为止已读取的前缀的一些信息。如果字符串是感兴趣的语言的成员，当整个字符串被扫描时达到的状态将是接受状态。Transition function φ tells you how state should change when an additional letter is read by the DFA转移函数φ告诉你当DFA读取一个额外的字母时状态应该如何变化。DFA常被描述为一个有标记的有向图。 Initially the state is i and if the input word is w = a1a2 …an then, as each letter is read, the state changes and we get q1, q2, . . . , qn defined by 假如w按照要求的顺序输入，state就会根据下面图示进行变化。 转化图的例子右下角的出口箭头和同心圆(concentric circles)都表示终端态input word 110100| symbol | 1 | 1 | 0 | 1 | 0 | 0 || —– | —– | —– | —– | —– | —– | —– || state | i | t | t | t | t | t | 简化If φ is a partial function (not defined for some state/letter pairs), then the DFA rejects an input if it ever encounters such a pair. 如果简化自动机，将不能达到最终态的途径状态去掉，只考虑根据当前状态和这一次扫描的字符能否达到最终态，如果不能就拒绝，这里描述为undefined未定义。This convention often simplifies the definition of a DFA. In the previous example we could use transition table只有cat和dog可以到达最终态，剩下的都被简化掉了。 An important observationAny DFA that uses the convention that an undefined transition leads to a rejection, can be converted to a DFA that uses a total transition function (that is, one that is defined for all combinations of input symbols and states). The convention is useful, but it does not add extra expressive power. 任何使用未定义转换导致拒绝约定的DFA，都可以转换为使用总转换函数(即为所有输入符号和状态组合定义的转换函数)的DFA。这种约定是有用的，但并没有增加额外的表达能力。 Any finite language is accepted by some DFAGeneral rule: i is the initial state. For each prefix p of a word in the list, include state sp with the idea that the machine should be in state sp after p has been read. i是初始状态。对于列表中每个单词的前缀p，包含状态sp，即在读取p之后，机器应该处于状态sp。这和DFA算法的原理是有关系的，DFA的本质是根据初始状态，通过一系列事件转化为另外一种状态的过程。即:state --&gt; event --&gt; state. 确定：状态以及引起状态转换的事件都是可确定的，不存在“意外”。 有穷：状态以及事件的数量都是可穷举的。 练习见CSDN博主「sanmusen_wu」的原创文章: INT201 决策，计算，语言 笔记 References XJTLU MC PowerPoint slides (INT201 Lecture1 &amp; Lecture2) CSDN博主「sanmusen_wu」的原创文章: INT201 决策，计算，语言 笔记","link":"/2021/09/07/INT201-W1/"},{"title":"hexo部署步骤变化","text":"Problem今天写完blog上传的时候，发现原来的GitHub输入用户名再输入密码push的方式没用了，报错如下: 1234567891011remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: unable to access 'https://github.com/chenzhengde/chenzhengde.github.io.git/': The requested URL returned error: 403FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/chenzhengde/Library/Mobile Documents/com~apple~CloudDocs/大三上学期/myblog/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:400:28) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html Solution经过Google发现，原来从8月13日起GitHub不在接受GitHub.com上的Git操作验证账户密码。必须使用基于令牌的身份验证进行操作。没有办法就去生成了一个personal token存放在印象笔记里。然后使用MacOS的钥匙串，进入GitHub所储存的密码，把含有互联网密码的密码全部改成了personal token。现在的上传步骤: Github用户名 Personal token 正常钥匙串密码 References Mac が覚えている GitHub のパスワードをパーソナルアクセストークンに変更する Git password authentication is shutting down","link":"/2021/08/14/hexo%E9%83%A8%E7%BD%B2%E6%AD%A5%E9%AA%A4%E5%8F%98%E5%8C%96/"},{"title":"icarus使用知识","text":"前几天用yilia改subnav，莫名其妙的又把yilia改出问题了，这次干脆直接把主题换掉了，一步到位。不得不说icarus确实是个非常优秀的主题，首先图标就是调用的GitHub上的fontawesome库，再也不用自己调整图标了😅 有空再研究研究图片的设置了。 I. 安装icarusGithub链接: https://github.com/ppoffice/hexo-theme-icarusIcarus网站链接: https://ppoffice.github.io/hexo-theme-icarus/安装过程和教程里写的差不多，但是有的时候会提示node缺少依赖，需要按照要求安装相对应的依赖，就可以解决这个问题。这时候就可以发现多在myblog目录下多了一个_config.icarus.yml文件，这个文件就是负责配置icarus主题的。（这个配置文件的位置和yilia的配置文件不一样，需要注意一下）老版的icarus下载的时候是自带这个文件的，但是新版的（version4.0.0）现在好像没有了，当运行的时候假如检测到没有会自动生成，所以不用担心。 II. _config.icarus.yml配置这个配置文件一般就在myblog下，假如没有的话可以去myblog\\themes\\icarus\\下看有没有_config.yml文件。There’re many kinds of setting in this doc. Most have been explained clearly. variantTwo kinds of variants: “default” &amp; “cyberpunk”. I picked default one cus it’s easier to read and customize. logoThis part is for setting up the logo in the website header. Pic and str are available. headfaviconKeeping the old favicon. Url and pic are both available here. other optionsI didn’t edit other options. Since there’s no need for these options currently. navbarmenuThe horizontal menu on the top of the website. I deleted about button. linksThe GitHub icon on the right-top of web. footerThree icons on the right-bottom of web. articleCode highlight and readtime settings are in this part. I think it’s nice for now, so didn’t edit them. searchNo edit. comment经过考虑选择了Facebook的评论插件，先用用再说。 share用的是sharethis插件。进去之后选择Start with Share Buttons，然后开始自定义按钮并登陆该网站（提醒一下自己使用163邮箱登录的）。最后，从HTML代码段中复制src中的URL地址到分享按钮配置中。 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://platform-api.sharethis.com/js/sharethis.js#property=6113d16f12036d00122e6422&amp;product=inline-share-buttons&quot; async=&quot;async&quot;&gt;&lt;/script&gt; donate有一说一不大好意思开这个功能，先不开吧。 sidebar两边的sidebar都是可以移动的，这样看起来页面会充实一些，不会太空。 widgets这里是页面左右组件，在个人介绍页面上最爽的就是可以通过调用GitHub的fontawesome库，这样可以添加很多subnav的标志。假如设置了gravatar链接，会优先提取邮箱的头像作为avatar，所以那里不要设置邮箱。 plugins &amp; providersNo edit. III. markdown新增加知识icarus主题需要在markdown文件里设置toc: true。这样才可以正常在左侧sidebar显示目录。设置中的categories可以设置文章的分类。顶端设置中 1234567title: icarus使用知识date: 2021-08-11 10:42:54tags: [hexo, icarus, blog]toc: truecategories: [blog note]thumbnail: #侧边栏缩略图cover: #文章封面图","link":"/2021/08/11/icarus%E4%BD%BF%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"title":"flutter运行说明","text":"flutter前端项目库的调用操作，就从0开始呗。其实这个框架还有dart语言都还挺不错的，有时间可以细细的学一下。这种一次性可以开发多个客户端的语言也该还是有很大前景的。 Install Flutter unzip 'the position of package' export PATH=pwd/flutter/bin:$PATH flutter doctor Build Clone repo git clone https://github.com/projectName/projectName.git Run flutter pub get to install dependencies Run flutter pub run build_runner watch to generate code Run flutter run For Flutter newbieA few resources to get you started if this is your first Flutter project:Lab: Write your first Flutter appCookbook: Useful Flutter samplesFor help getting started with Flutter, view our online documentation, which offers tutorials, samples, guidance on mobile development, and a full API reference. Some shitty informationEverything in Flutter is a widget.主页储存在\\lib\\main.dart里，语料卡片在\\lib\\compoents\\ExtentGrid.dart里目前对于页面在手机上的想法是，通过获得设备屏幕的宽度，依照宽度来决定首页的布局，假如屏幕宽度大于500px就使用默认的布局方式，假如小于500px就去掉两边的留白，直接把语料卡片的大小设置为屏幕的大小。通过对已经写过的代码的分析，dart可以使用if, else if, else语句 ReferencesDart Cheat Sheet","link":"/2021/08/03/flutter%E8%BF%90%E8%A1%8C%E8%AF%B4%E6%98%8E/"},{"title":"yilia已知问题和部分解决方案","text":"目前blog出现了一些问题，有的已经解决，在这里有解决的方法，还有一些没有解决需要继续研究。不需要继续研究了，框架已经从yilia换成了icarus。 I. 文章内目录文章内目录自带的颜色很丑，是一种怪异的蓝色，现在已经改成了橘色。大部分相关的设置都可以搜索tooltip搜索到，但是在目录的旁边有一个冒泡的符号颜色一直不能修改，原因是这个符号是一个icon，颜色是自带的，不是加上去的，所以已经把background-image修改成了none。该问题已解决。 II. subnav设置yilia自带的subnav有很多社交网络可以选择，但是我想加一个instagram上去。按照网上的教程已经把svg文件打包成功了，但是在console里调用npm run dev的时候一直报缺少sass错误。安装sass也没有成功。该问题待解决 III. left-col-headerleft-col-header就是在左侧头上上面的那一小块区域。在电脑上的显示大小是300px*180px。图片的设置在/themes/yilia/main.0cf68a.css中，调整background-image后面的url就可以了。但是这个图片在手机端上显示的有重复，还没有得到解决。之前看起来手机端上是使用nav自动调整在窄屏上的适配。该问题待解决 IV. 返回页面顶部按钮原来是可以用的，但是莫名其妙的挂了，现在还不知道为什么。估计是搜索top寻找相关信息。该问题待解决 V. 返回js报错有个litten.me:9005一直在访问，这是个原来编写yilia的xd做的统计功能。导致在chrome的页面上看起来要加载很久。可以在themes\\yilia\\source\\main.0cf68a.js中找到192function，删除掉函数内的内容，就ok了。该问题已解决。 VI. 添加文章置顶功能先安装插件： 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在/themes/*/layout（/_macro）/post.ejs输入： 12345&lt;% if (page.top) { %&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;% } %&gt; 最后在markdown文件的开头top设置中输入数字，数字越大优先级越高。该问题已解决。 VII. 置顶的标签问题打开文章之后左上角会有一个紫色的小置顶标签，看起来有点丑，但是不影响正常使用，还不知道怎么美化。该问题待解决 VIII. aboutme显示问题好像打开网站之后aboutme的显示总是会慢一拍，现在莫名其妙的好了。该问题已解决。","link":"/2021/08/02/yilia%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98%E9%83%A8%E5%88%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"hexo使用说明","text":"这个blog的框架使用的是hexo，themes是下载的yilia，可以从github上免费下载。自己调整了一些配置，主要是记录一下调整的内容和一些代码命令。 I. 下载的链接hexo估计下载的几率比较小，主要是参考了b站上的一个视频教程。但是yilia主题偶尔还是会发生一些错误，需要重新下载并配置：yilia下载链接。 II. 简单代码操作进入root目录: sudo su 后输入password本地调试: hexo clean + hexo g + hexo s推到远端: hexo d 然后输入GitHub的账户和密码创建笔记: hexo n &quot;笔记名称&quot; 然后就可以在/source/_posts目录下找到对应的笔记文件大多数的root代码就是这些，应该可以满足日常的需求。 III. blog的配置在本地的文件中，有两个名字一样的配置文件夹，都叫_config.yml，但是这两个有本质性的区别。myblog目录下的_config.yml调整的是整个网站的配置内容。themes目录下的_config.yml针对的是blog主题的配置，一般来说这个用的多一点。 themes目录下的_config.yml大部分的操作其实这个文件里的注释都已经写的比较清楚了，但是还是有一些需要注意的地方。在这个文件里true表示功能已经打开，false表示功能已经关闭。menu菜单中有一个随笔目前还没有弄懂是做什么的。已经在菜单中添加了归档，可以按照日期检查所有的blog文章。添加了author和subtitle，这两部分内容将显示在主页的头像下面。主页左边栏上的社交网络表示在文件里是subnav，可以在该文件中修改地址，目前还没有想出添加新的社交网络的方法，本来想加一个Instagram上去，但是npm run dev一直显示缺少sass文件，装了半天也没有装上去，好像和node的版本有关系（触及知识盲区）😅 有人知道怎么改的话请告诉我。在subnav里还有一个rss目前还不知道是干什么的，估计和底下的rss有点关系。快速到顶端的功能，目前已关闭，测试的时候是可用的，但是每次过一阵子不管这个按钮就挂了，目前不知道原因。上面的目录功能可以打开，所有文章都会显示目录。头像是avatar，调用的是/yilia/source/assets里面的head.jpeg。同理标签页上的是favicon，图片也保存在这个上面的文件夹里。评论功能还没有研究明白，目前已经关闭，后面可能会开启。打赏功能估计后面也不会开启，没什么卵用。友链目前也关掉了，还没有想好需要什么样的友链加上去，其他有blog的同学可以来一起交流，其实感觉可以吧csdn和leetcode这种网站加上去，我也不太懂。tag的开关默认设置为了打开，因为关闭按钮的颜色被我修改目录颜色的时候不小心给改成了橘色，现在看起来有点丑，所以就一直保存开的状态吧（css源码实在是太多了）。右滑块的背景颜色使用的是BrulyWood到OldLace的渐变，因为没想出来用什么样的背景比较好看，所以只改了个颜色。还有aboutme部分不知道为什么一打开网页的时候会显示brbr标签，需要过一会才会变成正常的排版，手机端可能也是相同情况。 myblog目录下的_config.yml这个文件中主要是关于hexo的配置。我把本地的端口设置为了4001，因为4000经常会被莫名其妙的占用。包括添加了一部分关于jsonContent的设置，这样滑块目录内容才可以正常使用。网站的名字目前是divide÷，因为没有想出更好的名字，就用微信名先代替。deploy里设置的是git的内容，保证每次能推到GitHub的仓库里。 IV. CSS&amp;HTML5的内容这部分内容其实挺多挺杂的，因为hexo框架和yilia本身就带了很多内容，而且格式很乱，非常难以辨别，主要可以使用Chrome浏览器的开发者模式去定位需要修改的模块和内容，再去vscode里搜索直接进行修改，这样会方便一些。","link":"/2021/08/01/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"title":"Markdown的语法知识","text":"这是一篇简单介绍和记录Markdown语法的笔记，参考的一些网上的资料和CSDN的文章。 I. 标题1.使用#表示标题其中#必须在行首，在标题的前面的#越少，标题的字体就越大 （从一个#到五个#都有） 2.使用===或者---表示例如：一级标题用===二级标题用--- II. 分割线使用三个或以上的-或者*表示，且这一行只有符号，注意不要被识别为二级标题即可，例如可以为往中间或者前面加上空格- - -* * * III. 斜体和粗体使用*和**分别表示斜体和粗体，例如：斜体 粗体 斜体+粗体删除线用两个～，例如：～～这是要删除的文字～～删除文字部分失败了，不过感觉用处不大 IV. 超链接和图片超链接和图片的写法类似，图片仅在超链接之间多加了一个!超链接写法分别是：网站写法(Google)图片的例子: V. 无序列表使用-,+,*表示无序列表，前后留一行空白，可以嵌套，例如： 一层 二层 二层 三层 四层 一层 VI. 有序列表使用1. （点后面有个空格）表示有序列表 一层 一层 这一级别的列表没有显示出序号 一层 VII. 文字应用使用&gt;表示，可以有多个&gt;，表示层次更深 the first floor the second flooralthough i used the &gt; in the beginning. this is still the second floor the third floor have a line of space. here is the first floor now VIII. 行内代码块用`表示:行内代码块有一些字符需要转译，使用反斜杠\\进行转译 IX. 代码块使用四个缩进表示代码块，一般使用三个`表示 public static void main(String[] args){ System.out.println(“Hello World”); }上面的代码没有按照要求显示出来，不过底下的已经出来了上面的意义不大，以底下的写法为准下面是有highlight和行数提醒的代码 123public static void main(String[] args){ System.out.println(&quot;Hello World);} X. 表格直接看例子，第二行的---:表示了对齐方式，默认左对齐，还有右对齐和居中|商品|数量|单价||—|—:|:—:||苹果|10|$1||电脑|1|$1000|表格失败了，没有显示出来，需要完善 XI. 流程图主要的语法为 name=&gt;type: describe，其中type主要有以下几种：1.开始和结束：start end2.输入输出：inputoutput3.操作：operation4.条件：condition5.子程序：subroutine语法参考网站：流程图语法参考估计流程图很少用得上 XII. 数学公式使用$表示，其中一个$表示在行内，两个$表示独占一行$$E=mc^2$$支持LaTeX编辑显示，访问MathJax参考更多用法推荐一个数学公式在线编译网站：https://private.codecogs.com/latex/eqneditor.php今天增加了矩阵的写法，假如我们想要在markdown中实现一个矩阵，也需要用Mathjex。 123456$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\\\\\ 4 &amp; 5 &amp; 6 \\\\\\\\ \\end{bmatrix}$$ 上面的代码实现出来的效果👇$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$假如要更换矩阵的括号，需要修改{bmatrix}变成其他的标志符。 XIII. 支持HTML标签1. 段落的缩进例如想要段落的缩进，可以如下：&nbsp;&nbsp;不断行的空白格&nbsp;或 &ensp;&ensp;半方大的空白&ensp;或 &emsp;&emsp;全方大的空白&emsp;或  2. 页面内跳转点我跳转点我跳转的功能这里演示不了，写法如下： &lt;h6 id='anchor'&gt;我是一个锚点&lt;/h6&gt; XIV. 参考文章Markdown语法介绍（详细）","link":"/2021/07/29/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"XJTLU","slug":"XJTLU","link":"/tags/XJTLU/"},{"name":"CAN201","slug":"CAN201","link":"/tags/CAN201/"},{"name":"Lecture","slug":"Lecture","link":"/tags/Lecture/"},{"name":"Lab","slug":"Lab","link":"/tags/Lab/"},{"name":"CPT203","slug":"CPT203","link":"/tags/CPT203/"},{"name":"Tutorial","slug":"Tutorial","link":"/tags/Tutorial/"},{"name":"CPT205","slug":"CPT205","link":"/tags/CPT205/"},{"name":"INT201","slug":"INT201","link":"/tags/INT201/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"yilia","slug":"yilia","link":"/tags/yilia/"}],"categories":[{"name":"XJTLU note","slug":"XJTLU-note","link":"/categories/XJTLU-note/"},{"name":"CAN201","slug":"XJTLU-note/CAN201","link":"/categories/XJTLU-note/CAN201/"},{"name":"CPT203","slug":"XJTLU-note/CPT203","link":"/categories/XJTLU-note/CPT203/"},{"name":"CPT205","slug":"XJTLU-note/CPT205","link":"/categories/XJTLU-note/CPT205/"},{"name":"INT201","slug":"XJTLU-note/INT201","link":"/categories/XJTLU-note/INT201/"},{"name":"SURF note","slug":"SURF-note","link":"/categories/SURF-note/"},{"name":"problem solving","slug":"problem-solving","link":"/categories/problem-solving/"},{"name":"blog note","slug":"blog-note","link":"/categories/blog-note/"}]}