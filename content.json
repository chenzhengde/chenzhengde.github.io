{"pages":[],"posts":[{"title":"Duke ECE550K","text":"纯在折磨这个课可能会有很多不完善的地方，我也有很多地方感觉一知半解，欢迎讨论和交流。 Lec1 IntroductionProcessors are made of transistors Levels of Abstraction Transistors: “electrical switch” Gates: a few transistors Meaningful logic elements: a handful of gates Large elements (stages, units): combining logic elements Core Chip We have transistors. They’re electronic switches. You can make logic by combining transistors. You can make arithmetic from logic. Transistors can also make basic memory. Combine arithmetic and logic circuits to make an Arithmetic/Logic Unit (ALU) Combine memory elements to make registers to store values Combine the ALU, registers, and other stuff to make a full CPU! Use other transistor configurations to make large-scale RAM. RAM is too slow, so add cache, another form of memory to speed it up. We have storage in the form of hard drives and SSDs. Use storage and RAM together: this is virtual memory, which allows us to run more programs with more efficiency. We halt the CPU with exceptions to handle things like I/O to storage. The modern computer is governed by basic software called the operating system. We have networking to connect multiple computers. CPU performance is increased by various techniques, including pipelining. Lec2 Transistor to GatesVcc &amp; GndVcc就是power（高电平）， Gnd就是ground（低电平）。高电平用1V表示，低电平用0V表示。两个不可以直接连，会短路！ Transistor2 types: NMOS (左边没带圈圈的) gate是1的时候接通，0是断线 PMOS (右边带圈圈的) gate是0的时候接通，1的时候断线 CMOSComplementary MOS上面接了一个PMOS，底下接了一个NMOS 当input等于1的时候（PMOS断，NMOS接），output为0 当input为0的时候（NMOS断，PMOS接），output为1 Switching delays当input切换的时候，output的转变不会立刻发生，因为有延迟，影响延迟的因素有： Voltage Higher voltage = faster switching, more power/energy 高电压可以减小延迟 Resistance lower resistance = faster switching 低电阻 Capacitance lower capacitance = faster switching 低电容 所以可以想象电流在电线中是不断向前流动的，只有完全的流过了这个电路，output和各个管线的结果才是我们想象的结果。 CMOS可以构成not gate 这就是一个小小的abstraction，只有interface是有逻辑的，内部实现是transistor实现的 build a gatebuild a 2-input NOR gate write down the truth table of NOR gate. output = 1 when A and B = 0 看真值表，只有A和B为0的时候结果才是1 connect PMOS in series (Not A) and (Not B) output = 0 when A or B = 1 Connect NMOS in parallel Not (A or B) NOTE: 这两个方程逻辑相等通过DeMorgan’s Laws(看纸质笔记或者hw计算) bar(A*B) = barA + barB bar(A+B) = barA * barB 两个gates相乘就是串联，相加就是并联 在设计此类图的时候PMOS一定是在output的上沿，NMOS在output下沿。 同理设计一个NAND gate 先看真值表： output = 0的时候，(Not A) and (Not B)，所以下沿是两个NMOS串联。 output = 1的时候，(Not a) or (Not B)，所以上沿是两个PMOS并联。 Boolean gates 底部是直的是AND 底部是弯的是OR 底部有两条的是XOR 带圈圈的是基础班加NOT XOR gate 可以用来表示二进制加法 可以使用buffer to increase speed Lec3 Combinational Logicthree inputs NOR gate 在处理多个gate的时候，complementary nature非常重要。 假如不注意的话就会出现短路的情况（Vcc和Gnd直接连接），烧毁电路板。 PMOS的方程，应该等于CMOS的方程，例如：PMOS: ((NotA) or (NotB)) and (NotC) NMOS: Not(C or (A and B)) = (NotC) and (Not(A and B)) = (Not C) and ((Not A) or (Not B)) 所以可以得出，正确的情况下，uppull和downpull的两个方程应该是相等的 所以And gate 是怎么实现的呢：NAND gate后面跟着一个Not gate即可。 Not(Nand(a, b)) Nor(NotA, NotB) Circuits are made from a network of gates. 不要把两个input直接连在一起，会短路 Mux是一个选择器，input会有正常的input和一个selector，mux通过selector去选择input中的一部分output出来。 How to make a mux Pick between 2 inputs (2to1Mux) Make a truth table (S = 0 pick A, S = 1 pick B) Sum of product to get formula Find the rows where the output is 1(!A &amp; B &amp; S) | (A &amp; !B &amp; !S) | (A &amp; B &amp; !S) | (A &amp; B &amp; S) Simplifying this formula: (A &amp; !S) | (B &amp; S) 通过简化过的formula构成2to1的Mux： 通过这个可以进行进一步的组合，2to1Mux变成4to1变成8to1变成16to1变成32to1（通过不断增加selector的bits数量） DeMorgan’s Laws Lec4 Number Representations二进制没啥可说的 二进制转化为16进制（0x开头），可以把二进制四位四位分开，每一位分别计算，作为16进制的一位。 需要负数怎么办？ 开头第一位出来，0就是正数，1就是负数 如何把一个正数变成负数？正数取反+1 overflow但是出现了一个问题两个positive numbers相加得到一个negative number，这是不对的 原因是发生了overflow！溢出了！ 什么情况是发生了overflow？ Signed addition: CI != CO of last bit 最后一位的cin和cout不同 Unsigned addition: CO != 0 of the last bit detect in hardware signed: XOR CI and CO of last bit unsigned: CO of last bit 减法怎么做？ A - B = A + ~B + 1 A-B就是A+B的取反然后cin变成1 one-hot独热编码，懂得都懂 decoder &amp; encoder Delays 开关不是instant的。 gate越多，延迟也就越多。 wire也有延迟。 Fan-out: how many gates the output drives related to capacitance high fan-out = slow sometimes better to replicate logic to reduce its fan-out Lec5 Digital Arithmetic1bit adder一位全加器 RCAripple carry adder每一个adder都有两个unit的delay（因为从input到output需要穿过两个gate），所以rca的delay是很大的，需要一个一个adder的过，N个adder的delay就会是2N。 CSAcarry select adderCSA的优点就是可以同时进行不同位数的计算，只需要根据低位的cout选择高位的计算结果拼接上去就可以得出正确结果。 但这个的问题是用空间换时间，他的delay是会比RCA小，但是所需空间会比RCA大。 这个的delay取决于一个CSA模块所需要的delay和mux的delay之和（一般来说一个mux的delay约等于2 units）。 ALUArithmetic Logic Unit left shift (&lt;&lt;&gt;&gt;) Moves left, bringing in 0s at right, excess bits “fall off” 10010001 &lt;&lt; 2 = 01000100 x &lt;&lt; k corresponds to x*2^k 想象一下用手把数字往左侧推，然后在右侧的空格里补0 logical (or unsigned) right shift (&gt;&gt;) Moves bits right, bringing in 0s at left, excess bits “fall off” 无脑补0 10010001 &gt;&gt; 3 = 00010010 x &gt;&gt;k corresponds to x / 2^k for unsigned x arithmetic (or signed) right shift (&gt;&gt;) Moves bits right, brining in (sign bit) at left 根据最高位的数字补对应的数字 10010001 &gt;&gt; 3= 11110010 x &gt;&gt;k corresponds to x / 2k for signed x Floating point example看ppt，IEEE754 Lec6 Storage and Clocking1SR Latch为什么不可以输入两个都为1？ 因为两个都为1会导致输出结果不平衡，不会有一个固定的结果。 其他的输入都会有在最终平衡，输入不再改变。 sr latch Data Latch为了处理srlatch可能会出现的两个都是1的情况，data latch在输入的时候加入了一个not gate，使R和S输入的数据一定是相反的。 enable作为一个开关，去决定Q的输入，当enable是1的时候，Q的输出才会根据D而发生改变，假如enable为0，Q的输入就会保持当前的输入不变。 data latch 可以使用clock作为enable Strawman: Level Triggered 看ppt Lec7 Storage and Clocking2DFF相比于data latch的持续监测，dff的enable就是一个脉冲（clk从down到high），当出现脉冲的时候，记录当前状态，然后就继续保持不变直到下一个脉冲激活。DFF Register写入的时候使用decoder： decoder读入一个selcode，然后解码为一个one-hot code，对是1的那位写入数据 比如是32位的，就需要一个5位的selcode，然后进行解码，出来的结果应该是一个32bits的独热编码 不用mux，因为mux太慢了 读取的时候也使用了decoder 使用了tri-state buffer 指当enable为1的时候，才可以写入data是0/1 当enable为0的时候，保持高阻态Z（既不是0，也不是1，就是什么都没有） Lec8 Finite State MachinesFSM: Input + Current State = Output + New State 有两种machine mealy machine moore machine 这两个有一定的区别：FPGA状态机（一段式、二段式、三段式）、摩尔型（Moore）和米勒型（Mealy） Transition function: (state*inputs)-&gt;state (Helpful to draw as diagram) Output function: (state*inputs)-&gt;outputs Division??? 细节的图和画法得看ppt，复习的时候去看一下 Lec9 ISAs &amp; MIPSAssembly Assembly programming: 1 machine instruction at a time 一次一个机器指令 still in human readable form much lower level than any other programming Limited number of register vs unlimited variables Flat scope Registers Two places processors can store data Register in processor fast Memory outside of processor huge slow think of registers like “variables” $1 = $2 + $3 much like x = y + z simple running example line1: loop: line label lw = load words指读取memory对应位置的32位words $1 把从memory中阅读的结果放到reg1里 Memory[1004] = address in memory to read from (where x lives) 几乎所有的MIPS都是把distination放到第一位。 line2: 把1008位置的words从memory读取到reg2中存放 line3 把reg1里的内容+reg2的内容然后放在reg3里 line4 把reg3和reg4相加然后放到reg4里 line5 jump出line1的loop 以上的代码是人可以读的，但是不是机器执行的。 instructions are numbers too! 在MIPS中，每一个assembly instruction都可以被转化为一个独特的32bits的表示。 而完成这个转化的就是assembler. What must be specified? Instruction “opcode” （比如是add还是sub） Location of oprands and result（register还是memory还是immediates） Data type and Size（比如signed还是unsigned） what instruction comes next?（比如jump去哪？） ISAinstructions set architecture contract between hardware and software 软硬件之间的合同 specifies everything hardware and software need to agree on instruction encoding and effects memory structure etc 有很多ISA的种类：x86， ARM， MIPS 我们主要就说MIPS RISC vs CISC 2 broad categories of ISAa Complex instruction set computing (CISC) come first, days when people always directly wrote assembly big complex instructions Reduced instruction set computing (RISC) goal: make hardware simple and fast write in high level language, compiler do the dirty work RISCfixed length instruction encodingfew memory addressing modes (更少的内存地址模式)有更多的寄存器 32three-oprand arithmeticload-store ISA CISCvariable length instruction encodingmany addresssing modesfew registers 8various oprand models(stack, two-operand, implicit operands)可以直接操作内存 说句实话我不知道这节ppt后面半截的作用是什么，有人能告诉我吗？ 所以后面有一个executing add的例子，非常显而易见。 在address里是一行一行执行的，然后instruction会调用register进行计算，再把结果重新赋值到指定的register里去。 Lec10 ISAs &amp; MIPS 2R type1R Type: &lt;OP&gt; rd, rs, rt 假如我想加上一个常数怎么办？ 把常数放到寄存器中 使用带immediate的instruction I type1I Type: &lt;op&gt; rt, rs, immediate 正常操作之后带i基本上就是需要immdiate的操作 有许多isns有immediate形式： addi, andi, ori, xori之类的都有 没有sub （表达减法使用加上负数来表示） 没有muli和divi Accessing memory MIPS is a “load-store” ISA (RISC) only load and store insns access memory different with x86 which allows add reg = (memory location) + reg add (memory location) = (memory location) + reg l开头的是把内存里的数据赋值给寄存器，s开头的是把寄存器的数据保存到内存里 后面都是例子，直接看ppt Lec11 ISAs &amp; MIPS 31J-Type &lt;op&gt; immediate jtype provide long range, unconditional jump:31-26: Op25-0: target Can jump anywhere with jr $reg(jump register) write a function f2c Call: Jump… but also remember where to go back May be many calls to f2c() in the program Need some way to know where we were Instruction for this jal jal label Store PC +4 into register $31 Jump to label Return: Jump… back to wherever we were Instruction for this jr jr $31 Jump back to address stored by jal in $31 ra寄存器（Return Address Register）： 作用：$ra 寄存器用于存储函数调用的返回地址。当一个函数被调用时，程序会跳转到函数的代码执行，并在函数执行完成后返回到调用它的地方。$ra 寄存器用于保存调用函数之前的程序执行地址，以便在函数返回时能够回到正确的执行位置。 使用示例：在函数调用之前，程序通常会将返回地址保存在 $ra 寄存器中，然后在函数执行完毕后，使用 jr $ra 指令将控制返回到保存的地址。 v0寄存器： 作用：$v0寄存器通常用于存储函数的返回值。在 MIPS 汇编中，函数返回值通常存储在 $v0 寄存器中，以便调用者可以访问和使用返回的结果。 使用示例：如果一个函数计算了某个值，并希望将这个值作为返回值返回给调用者，它通常会将计算结果存储在 $v0 寄存器中。调用者可以使用 $v0 寄存器中的值来获取函数的返回值。 Assembly language Directives: tell the assembler what to do 解释要做什么 Format &quot;.&quot;&lt;string&gt; [arg1], [arg2] Stack为什么需要栈？ local variables saving register across calls spilling variables (not enough regs) passing more than 4 arguments stack layout在内存里 use loads and stores to accesstwo registers for stack: (一个开头一个结尾) stack pointer ($sp): points at end (bottom) of stack frame pointer ($fp): points at top of current stack frame procedure calls obey stack discipline 程序被call的时候遵循stack原则 local procedure state contained in stack frame 本地的程序储存在stack frame里 procedure stack is in memory 程序栈储存在内存里：从内存的顶部一路往下 Calling Procedure Step1: Setup the arguments 头四个arguments（arg0-arg3）被传入寄存器$a0-$a3 剩下的被推入栈中 Step2: save caller-saved registers save registers $t0-$t9 if they contain live values at the call site Step3: Execute a jal instruction Step4: Cleanup stack by updating $sp (if more than 4 args) Called Routine Establish stack frame subtract the frame size from the stack pointer subiu $sp, $sp, &lt;frame-size&gt; Typically, minimum frame size is 32 bytes (8words) Save callee saved registers in the frame register $fp is always saved register $ra is saved if routine makes a call registers $s0-$s7 are saved if they are used Establish Frame pointer Add the stack - 4 to the address in $sp addiu $fp, $sp, - 4 On return from a call Put returned values in registers $v0, [$v1] Restore callee-saved registers restore $fp and other saved registers. [$ra, $s0 - $s7] Pop the stack add the frame size to $sp addiu $sp, $sp, &lt;frame-size&gt; Return jr to address in $ra Lec12 ISAs and MIPS 4内存就像是一栋大楼，address就是每个房间的门牌号，value就是住在房子里的人，住在房子里的既可以是储存的数字，也可以是储存的其他房间的门牌号。 register就像是一个工位，通过address把里面的value拽出来储存在寄存器里（load），然后让他们工作（计算之类），结束再保存回内存去（save）。 现在让我们看这个图PC一直是下一步需要运行的地址 subiu $sp, $sp, 16这条指令的作用是将栈指针 $sp 减去16，这会使栈指针向低地址方向移动16字节，为当前函数调用分配16字节的栈空间。在函数执行期间，可以使用 $sp 寄存器来访问分配的栈空间，例如存储和读取局部变量的值。当函数退出时，通常会使用 addiu $sp, $sp, 16 或类似的指令来释放分配的栈空间，将栈指针还原到调用函数时的位置，以确保不会发生内存泄漏。 sw $fp, 0($sp)把栈顶储存在向大楼要求的四个房间里的第一个，故偏移量是0 sw $ra 4($sp)把完成之后要跳回的地址（也就是$ra），存在房间里 sw $s0 8($sp)把s0寄存器里value放到内存里 什么事callee saves？ addiu $fp, $sp, 12把$fp的位置更新偏移量，也就是更新申请的房子用了几个门牌号，（4个房间用了三个） 这时候到了address 1018的位置，1018指向了address位4200的位置 $ra会更新为0000101C，因为等4200位置的方法返回之后，程序需要从101C这里重新进行。 然后从房间里取出来一开始存进去的东西stack的特点是 first in last out取东西的时候是用栈顶开始取得 $fp是栈顶的门牌号，$sp是栈底的门牌号取的时候使用的是关于栈顶的偏移量 因为只用了三个房间，所以需要从$fp 偏移量为-4的地方开始读取，依次是-4，-8，-12 addiu $sp, $sp, 16 归还使用的房间 jr $ra 根据之前来的时候储存的地址，跳回调用这个函数的地方。 为什么需要$fpbalabalabala system call instructionsystem call被用来和操作系统和要求服务（memory allocation, I/O）syscall instruction in MIPS General Rules 补充1234567891011121314151617181920212223242526int leaf_example (int g, int h, int i, int j){ int f; f = (g+h)-(i+j); return f;}leap_example:addi $sp, $sp, -12 # adjust stack to make room for 3 itemssw $t1, 8($sp)sw $t0, 4($sp)sw $s0, 0($sp)add $t0, $a0, $a1 add $tl, $a2, $a3 sub $s0, $t0, $t1add $s0, $t0, $zerolw $s0, 0($sp) # restore register $sO for caller lw $tO, 4($sp) # restore register $tO for caller lw $t1, 8($sp) # restore register $t1 for caller addi $sp, $sp, 12 # adjust stack to delete 3 itemsjr $ra # jump back to calling routine 参数变量 g、 h、 l 和j对应参数寄存器 $a0、 $a1、 $a2 和 $a3, f对应 $s0。编译后的 程序是以如下标号开始的过程 midtermFloating point: single precision, double precision Arithemetic/logical operations adder: rca, csasubtractionoverflowbit-wise operation: shiftALU: 以上加起来 storageSR latch (has illegal state)data latchDFF (two dlatch)register (dff only 1bit, reg could have many bits)register file: tri-state gate FSM new state = f(Input, Current state) output = g(Input, Current state)this is meanly machine moore machine output = g(Current state) state tablestate diagramexcitation table hardware implementationapplication: division MIPSISAinstruction set architecture assembly programmingrisc v ciscMIPS: R type, I type, J type(jump)PCRA(return address)sp(stack pointer)fp(frame pointer)v0-v1: resultsa0-a3: argumentst0-t9: caller saves registerss0-s7: callee saves registers 这里来解释一下t register和s register的用法（个人见解）首先，所有的register都是在任何时候都可以save和load的，但是这里需要说到几个register的区别（也就是惯例用法）t register是caller save也就是在当前函数中被保存s register是callee save也就是在被call的函数中保存a register是保存argument的的register，a0-3都是不用在stack里的， 用一个比喻来说，register都是一个桌子，而stack里的储存空间就是locker。这时function0会在使用过程中call function1。OK，那也就是func0在桌子上办公到一半的时候，func1会接手这个桌子继续办公 那在function0来到这个桌子的时候，他需要保存好他上面一个func给他遗留的s register里的东西但是由于这时候桌子上的t register里的东西应该是上一个func里已经save好的了，所以function0可以直接使用t register不用考虑一开始的储存问题 好的，现在function0要离开桌子了，function1马上要接受桌子开始工作在func0走之前，func0需要把自己在t register里的东西储存到stack里，但是不需要管自己目前在s register里的东西。 func1来了之后需要帮func0把s reg里的东西储存好，才可以正常使用s reg。func1工作完了之后，需要跳回func0，这时候func1需要把func0当时留在s reg里的东西从locker里取出来（被func1放到了stack），放回桌子上 func0回到了自己的桌子上，已经有了所有的s reg（被func1摆好了），这是在去locker里找回自己的当时存的t register里的东西使用。 这就是整个的过程","link":"/2023/10/01/Duke-ECE550K/"},{"title":"Duke ECE551K","text":"Sept. 30th 2023,从今天开始好好记笔记。开学一个多月，我的评价是快乐不会消失只会转移，一点也乐不出来力。All of Programming IntroductionHow to write a program AlgorithmsAn algorithm is a clear set of steps to solve any problem in a particular class. have at least one parameter (algorithms with no parameters exist) everything is a number which is a key principle in programming. This figure shows how u should approach designing your algorthim.上图表示了该如何实现一个算法。 However, note that “translate to code” comes only after you have an algorithm that you have tested by hand—giving you some confidence that your plan is solid before you build on it.只有当手动执行过了之后才去翻译algorthim为code。 It would seem that writing a correct algorithm to make a sandwich from an arbitrary list of ingredients is quite a complex task. Even if we did not want to implement that algorithm in code, but rather have it be properly executed by a person with no common sense (or a professor with a comedic disregard for common sense), this task is quite challenging to do correctly. How could we go about this task and hope to get a good algorithm? The wrong way to write an algorithm is to just throw some stuff on the page, and then try to straighten it out later. Imagine if we approached our sandwich example by writing down some steps and having someone (with no common sense) try them out. After the kitchen catches on fire, we try to go in and figure out what went wrong. We then tweak the steps, and try again. This time, the kitchen explodes instead. We repeat this process until we finally get something that resembles a sandwich, and the house did not burn down. Step1: Work an Example YourselfThe first step in trying to design an algorithm is to work at least one instance of the problem— picking specific values for each parameter—yourself (by hand). 设计算法的第一步是手动做一个例子 假如卡在了这一步，一般说明有两个问题： the first case is that the problem is ill-specified - it is not clear what you are supposed to do. 不知道你该做什么 问需求去 the second case where step1 is difficult is when u lack domain knowledge. 知道该做什么也不会做 学知识去 Step2: Write Down What U just DidU must think about what you did to solve the problem and write down the steps to solve that particular instance. 写下解决这个“特定实例”的步骤。another way to think about this step is to write down a clear set of instructions that anyone else could follow to reproduce your answer for the particualr problem instance that u just solved. 写下一组清晰的说明，其他人可以按照这些说明来重现你刚刚解决的特定问题实例的答案。 难的部分是think about exactly what you did to accomplish the problem Step3: Generalize yours StepsHaving solved one or more problems from the class we are interested in and written down the particular steps we executed to solve them, we are ready to try to generalize those steps into an algorithm. 把数个已经成功的步骤考虑实现为一个算法。 Step4: Test ur Algorithm测试第三步generate的算法有没有问题，可能会出现的错误有misgeneralizing，还有可能出现的错误有the casese we did not consider in designing our algorithm (即corner case)。解决这些问题的方法是回到第一步和第二步。 Reading CodeVariablesdeclarationWhen executing code by hand, the effect of a variable declaration is to create a new box, labeled with the name of the variable. 创建一个新盒子，给盒子标记变量名在C语言中，一个新申明的变量是uninitialized的，which means its value是undefined的。当这代码被电脑执行的时候，会从有限的盒子中分配一个目前没有在用的给这个变量 （has a finite (but quite large) number of boxes (memory locations), and the variable will be given one that is currently not in use）。这时候，这个盒子就被assign给了这个变量，但是box里的value是没有被初始化的，box里的value碰巧是多少，那这个变量目前就是多少，这是cannot predict的。 assignment在创建完变量之后，使用assignment statements，改变box中的value。 an assignment statement starts with an lvalue 左值 on the left. an lvalue must be sth that “names a box” - indicating which box the assignment statement will change. After the lvalue, comes a single equals sign (called the assignment operator), followed by an rvalue on the right, then a semicolon at the end. 左值之后跟着一个等于号，再跟着右值，最后是冒号结尾。The rvalue must be an expression, and its value will be placed in the box. 最简单的左值是variable, which names the variable’s own box. An expression is a combination of values and operations that evaluates to a value. 12345int x;x = 4;int y = 6;// 这line1+line2是line3相同的效果， declaration和initialization可以同时实现// 也可以分开作为两个进行操作 ExpressionsExpression is a combination of values and operations that evaluates to a value. 1234int x;x = 4 + 3 * 2;int y = x - 6;x = x * y; FunctionsA function gives a name to a parameterized computation—it is the implementation in code of a specific algorithm. 函数为参数化计算提供了一个名称——它是特定算法的代码实现。该说的其实在学java python的时候也都知道，看看就行了 ScopeThe scope of a variable is the region of code in which it is visible. 变量的作用域是它在其中可见的代码区域。 其实也就是变量的作用范围，比如全局变量在所有的地方都可以使用，局部变量只在部分地方可以使用。 下图很清晰的展示了不同变量的使用范围的例子（即使他们都有相同的名字x）。 Printing123int x = 3;int y = 4;printf(&quot;x + y = %d&quot;, x + y); %d means this is a decimal number. 一说打印整数如int %f 用于打印浮点数，如float或double类型。 %c 用于打印字符，如char类型。 %s 用于打印字符串，如字符数组或指向字符串的指针。 %x 用于打印十六进制整数。 %o 用于打印八进制整数。 %u 用于打印无符号整数。 %p 用于打印指针地址。 12345678910int main (void) { int a = 42; int b = 7; printf(&quot;hello world\\n&quot;); printf(&quot;a is %d\\n&quot;, a); printf(&quot;b is %d, a+b is %d\\n&quot;, b, a+b); return 0;}// \\n用来换行// \\\\用来打出一个实际上的\\。 Conditional Statementsif else下面是一个ifelse例子 12345678910if (x==3){ y = z+1;}else if (x==2){ y = z+2;}else{ z = x-2; x = x+1;} switch case1234567891011switch (expression) { case value1: // 如果expression等于value1，执行这里的代码 break; case value2: // 如果expression等于value2，执行这里的代码 break; // 可以有更多的case default: // 如果expression与任何case都不匹配，执行这里的代码} 注意在执行的过程中，假如有一个case符合了条件，并不代表后面的case就不会被expression便利，所以假如需要找到一个case就直接跳出，需要用break停止便利之后的case。 default是可选的，假如case都没有符合的话，可以执行default的内容。 Shorthand Loopswhile loops1234while (x &lt; n){ y = y * x; x++;} do-while loops1234do { y = y * x; x++;}while (x &lt; n); for loops123for (int i = 0; i &lt; n; i++){ y = y * i;} continue &amp; break break用于完全退出循环或switch语句。 continue用于跳过当前迭代中的剩余代码，然后继续下一次迭代。 break是直接全部跳出，continue只是跳出这一轮的迭代 TypesHardware RepresentationBinary Numbers二进制数，懂得都懂 Looking under the hoodAbstraction: the separation of interface (what sth does or how u use it) from implementation (how sth works). Hex: 16进制，0-9代表0-9，A-F代表10-15。 Basic Data Types charchar是最小的data type，只有8个bits。 intint是32个bits构成，有signed和unsigned两种。 unsigned int组成中32位全部是数字，能表示的所有内容均为positive number。 signed int组成中第一位是符号为，后面31位为数字，所以有positive number （最左位为0）也有negative number（最左位为1）。 float &amp; double StandardsIEEE754 【IEEE754单精度浮点数的转换，32位浮点数】 PrecisionA double offers more precision than a float. and A double takes up twice as much space as a float. Expression have TypesType conversion假如有一个double加上int，处理器如何处理？处理器有四种指令 add two 32-bit integers add two 16-bit integers add two 32-bit floats add two 64-bit doubles 其他的都需要转变成这四个进行计算，比如double+int就会变成两个double相加 有时候会出现问题 1234567unsigned int bigNum = 100;int littleNum = -100;if (bigNum &gt; littleNum) { printf (&quot;Obviously, 100 is bigger than -100!\\n&quot;) ; else} else { printf (&quot;Something unexpected has happened!\\n&quot;) ;} 结果会是sth unexpected has happened，因为在signed int里负数最高位会被填充为1.","link":"/2023/09/30/Duke-ECE551K/"},{"title":"Farewell XJTLU","text":"Ciao!感谢四年朋友的陪伴","link":"/2023/07/21/Farewell-XJTLU/"},{"title":"CAN302 Technologies for E-Commerce","text":"臭狗lzx看这👇Email : Ping.Zhang@xjtlu.edu.cnOffice : EE222 Lecture 1 IntroductionCommerce: The exchange or buying and selling of commodities on a large scale involving transportation from place to place.Business: The activity of making, buying or selling goods or providing services in exchange for money. Definition of e-Commerce Electronic commerce (EC)Electronic enabled commercial transactions between and among organizations and individuals 电子使组织和个人之间的商业交易成为可能 Internet commerce (web commerce)The process of buying, selling, or exchanging products, services, or information via Internet 交易:通过因特网购买、出售或交换产品、服务或信息的过程 E-businessIt in volves using information technologies in all aspects of the business. Widely used E-business systems只有一个是标红的: CRM (Customer Relationship Management) Three flows in commerce Broad definition: any process by computer (electronic) would be e-commerce.Narrow definition: the order process should be an e-format. Security is always the No.1 issue EFT: eletronic fund transfer EDI: Electronic Data Interchange EDI made the e-commerce beyond e-payment. EDI使电子商务超越了电子支付。 EDI is the intercompany communication of business documents in a standard format. EDI是公司间以标准格式的商业文件通信。 The simple definition of EDI is a standard electronic format that replaces paper-based documents such as purchase orders or invoices. EDI的简单定义是一种标准的电子格式，它取代了采购订单或发票等纸质文档。 EDI is an old but still mainstream technology in B2B. EDI是B2B中的一种老技术，但仍然是主流技术。 Lecture 2 HTTP &amp; Server全是图片，去看ppt，搁着搬运没意义。 Lecture 3 dynamic HTML by server pageDynamic webpage: frame+dataA dynamic website is the webpage on the server side where different contents are shown when assessed at different timings. 动态网站是服务器端的网页，在不同的时间评估时显示不同的内容。CGI is an interface between Web server and program, language can be C,javaCGI program can access the data stored in databaseCGI是Web服务器与程序之间的接口，语言可以是C、javaCGI程序可以访问存储在数据库中的数据 Java Servlet If we treat CGI as a concept, Servlet can be regard as a Java type CGI. While it is very different from traditional CGI by C or Perl. To have the dynamic Html content, programmer need to write a lot of “System.out.println()”. Sever page ASP JSP (Java server page) PHP TomcatThe Apache Tomcat server is Java-based, open source reference implementation (RI) web application and servlet container created to run servlets and Java Server Pages (JSP) based web applications.Again, Tomcat server is a software. It can work together with Apache server. Apache Tomcat服务器是基于Java的开源参考实现(RI) web应用程序和servlet容器，用于运行基于servlet和Java server Pages (JSP)的web应用程序。同样，Tomcat服务器是一个软件。它可以与Apache服务器协同工作。 Tomcat可以加上Static web server使用 PHP PHP以类似的方式工作，将脚本嵌入到html代码中。 PHP是为Web开发而优化的，可以用于通用用途(但是很少有人在Web之外使用它)。 PHP是被广泛使用的，免费的，并且仍然活跃。 Apache有支持PHP的扩展。 XAMPP是所有必要软件的组合。 Database basics Similar to web server, database is a software. A database is an organized collection of structured information, or data, typically stored electronically in a computer system. A database is usually controlled by a database management system (DBMS). Together, the data and the DBMS, along with the applications that are associated with them, are referred to as a database system. We often call a certain database which is actually the name of DBMS. 与web服务器类似，数据库是一种软件。 数据库是结构化信息或数据的有组织的集合，通常以电子方式存储在计算机系统中。 数据库通常由数据库管理系统(DBMS)控制。数据和DBMS，以及与它们相关联的应用程序一起被称为数据库系统。 我们经常称某个数据库为DBMS。 SQL languageSQL is a pragramming language used by nearly all relational databases to query, manipulate, and define data, and to provide access control.SQL是一种编程语言，几乎所有关系数据库都使用它来查询、操作和定义数据，并提供访问控制。 Transaction: ACID Atomicity: ensures that all operations within the work unit are completed successfully. Otherwise, the transaction is aborted at the point of failure and all the previous operation are rolled back to their former state. 原子性:确保工作单元内的所有操作都成功完成。否则，事务将在故障点中止，之前的所有操作将回滚到以前的状态。 Consistency: ensures that the database properly changes states upon a successfully committed transaction. 一致性:确保数据库在成功提交事务时正确地更改状态。 Isolation: enables transactions to operate independently of and transparent to each other. 允许事务独立操作，并且对彼此透明。 Durability: ensures that the result or effect of a committed transaction persists in case of a system failure. 确保提交事务的结果或效果在系统故障时仍然存在。 Primary and foreign keys Primary key: ensures data is unique. Foreign key: ensures the reference relationship Interaction with PHP serverBy post or get, the parameters are send to the serverApache has the build-in fucntion to receive such parameters Lecture 4 Typical project life cycleResearch or Analysis分析是设计之前的步骤data sources是可以分析的内容可以提供一个business plan Design可以是UX,UI,IA,IxDUI: user interfaceIxD: interaction designIA: information architertureUX: user experience Design tools: Adobe XD, modao, Sketch, etc 然而，UI/UX只是设计的一部分A product requirements document (PRD) defines the requirements of a particular product, including the product’s purpose, features, functionality, and behavior. It serves as a guide for business and technical teams to help build, launch, or market the product. 产品需求文档(PRD)定义了特定产品的需求，包括产品的用途、特性、功能和行为。它可以作为业务和技术团队帮助构建、发布或销售产品的指南。PRD is not only the UI/UX, it should address 5 types of requirements: Business Requirements Market Requirements Functional Requirements Non-Functional Requirements UI/UX Requirements Develop and Test开发过程中不是只有coding 还有test Test in different stage After the survey: write system test cases调查后:编写系统测试用例 After design: write unit test cases设计后:编写单元测试用例 After the module is submitted: execute the unit test case and revise it模块提交后:执行单元测试用例并修改它 Unit test in progress: write integration test cases进行中的单元测试:编写集成测试用例 After module assembly: execute integration test cases and revise them模块组装后:执行集成测试用例并修改 Requirements change during development: modify all the above test cases开发过程中的需求变更:修改以上所有测试用例 Before release: execute system test cases发布前:执行系统测试用例Test what Functional test: pay attention to whether the function is correct. Usability test: pay attention to whether the product is easy to use. Compatibility test: focus on whether the product is applicable to multiple platforms. Reliability test: pay attention to whether the product is stable and reliable. Security test: pay attention to whether the product has vulnerabilities. Performance test: focus on whether the product can run efficiently. Implementation or OperationA/B test Lecture 5 Database cluster and CacheServers are more powerful computer 服务器是功能更强大的电脑只有一个服务器的话就可能会达到up-limitation Network CPU Memory Disk I/O Separate the web server with DB server to handle the high con-currency flow, the wb server and DB server should be deployed individually 为了处理高并发流量，建议将wb服务器和DB服务器分开部署 the web server and DB server should be high availability and clusters web服务器和DB服务器应该是高可用性和集群 需要有high availability，redundance is MUST对于高风险应用 Host standby,主机需要有备用。两台主机具有相同的功能，一个主机down了第二个可以顶上 VRRPVirtual Routing Redundancy Protocol 虚拟路由冗余协议 Two “servers” has the same configuration. 两台路由器有相同的配置 Standby one would check the health of active one. 备用的那个会检查开放的那个的健康情况 Once the active one is gone, the standby one would take over the network traffic. 假如启动的那个寄了，备用的就会接替上去 A typical software for this function: keepalived Master/Slave MySQL 在电商应用中，“read”是很大一部分request the slave DB只负责支持“read” 只写将适用于主DB和多个服务器支持读。“并发货币”能力将得到扩展。 Proxy the cluster代理集群：代理会自动的选择master和slave Data inconsistent数据不一致会希望两个site可以扩大可用性，client会从两个网站中取出相同的部分假如G2没有更新他的数据，那客户就只能获取到老的数据 CAP理论声明任何分布式数据存储只能提供以下三种保证中的两种: Consistency 一致性 Every read receives the most recent write or an error. Availability 可用性 Every request receives a (non-error) response, without the guarantee that it contains the most recent write. 每个请求都会收到一个(非错误)响应，但不能保证它包含最近的写入。 Partition tolerance 分区公差 The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes. 系统继续运行，尽管任意数量的消息被节点之间的网络丢弃(或延迟)。 怎么选择CAP取决于不同的情况和场景： Read/write master database scheme 读写主数据库方案 Delay query scheme 延迟查询方案 Judge the active/standby non-delay scheme 判断主备无延迟方案 Determine synchronization site scheme 确定同步站点方案 Waiting for synchronization site scheme 等待同步站点方案 Semi-synchronous replication scheme + waiting point 半同步复制方案+等待点 Group replication MGR scheme 组复制MGR方案 都是图，自己看ppt。 Lecture 6 web clusters for high flow要把web server和DB server区分开 Nginxthe king of HTTP ProxyNginx is a web server, can server static contents and use multi-thread to gain the high performance. Proxy the webservers 代理web服务器 The web should only publish one domain name to end user. web只向最终用户发布一个域名 Nginx is a strong web server. Nginx是一个强大的web服务器 Nginx can server the static contents. Nginx可以服务器静态内容 Nginx set the proxy rules based on path. Nginx基于路径设置代理规则 There are 4 (can be any number) servers for dynamic contents proxying together by nginx. 有4个(可以是任意数量)服务器，通过nginx将动态内容代理在一起 Balancing techniques Round robin 默认方法: the load balancer runs through the list of upstream servers in sequence Hash: calculates a hash that is based on teh combination of text and NGINX variables you specify IP HASH: the hash is based on the client’s IP address 基于客户端的IP地址进行HASH Least connections: compares the current number of active connections and sends the request to the server with the fewest connections. 连接数最少:比较当前活动连接数，将请求发送给连接数最少的服务器。 Least time: combines two metrics for each server – the current number of active connections and a weighted average response time for past requests 最短时间:结合了每个服务器的两个指标——当前活动连接数和过去请求的加权平均响应时间 Cookies and sessionHttp is 无状态的， 一个网页需要cookie/session去保持他的状态假如有多个后端服务器需要被使用，服务器需要share same sessionredis is a choice for session sharing Default session file in ApacheApache store the session as a file in ‘tmp’ folderThe contents can be set by PHP code. Proxy the webservers 代理web服务器Shared session with Cache: all servers can get shared session from Redis Health check: Use heath_check to make sure all backend can work properly. HTTP and TCPRecall the network and httpencapsulate the data: MAC addresses后面是IP addresses在后面是TCP header LVS (linux virtual server) Lvs is a kernel service of Linux system LVS share the VIP with real severs LVS re-direct the request (TCP UDP) packages to real servers Proxy rules based on IP +ports Bandwith of network card would be the bottle neck","link":"/2023/02/22/CAN302-Technologies-for-E-Commerce/"},{"title":"CAN304 Computer Systems Security","text":"Email: jie.zhang01@xjtlu.edu.cnOffice hours: 2:00-3:00PM, Tue &amp; Wed EE522 Lecture 1. IntroductionComputer security conceptsDefinitionThe protection afforded to an automated information system in order to attain the applicable objectives of preserving the integrity, availability, and confidentiality of information system resources (includes hardware, software, firmware, information/data, and telecommunications).为实现信息系统资源的完整性、可用性和机密性(包括硬件、软件、固件、信息/数据和电信)的适用目标而对自动化信息系统提供的保护。 CIA (3 key objectives) Confidentiality 保留对信息获取和披露的授权限制，包括保护个人隐私和专有信息的手段。 Integrity 集成度 防止不适当的信息修改或破坏，包括确保信息的不可抵赖性和真实性。 Availabilitiy 确实及时可靠的获取和使用信息 Other objectives Authenticity Accountability Ensuring actions of an entity to be traced uniquely to that entity. Support nonrepudiation, deterrence, intrusion detection and prevention, etc. 术语Computer security deals with computer-related assets that are subject to a variety of threats and for which various measures are taken to protect those assets.要保护什么？ System Resource Hardware Software Data Communication facilities and networks Security Policy A set of rules and practices that specify or regulate how a system or organization provides security services to protect sensitive and critical system resources. 一组规则和实践，指定或规范系统或组织如何提供安全服务来保护敏感和关键的系统资源。 Vulnerability A flaw or weakness in a system’s design, implementation, or operation and management that could be exploited to violate the system’s security policy. 系统设计、实现或操作和管理中的缺陷或弱点，可以被利用来违反系统的安全策略。 Exploit An actual incident of taking advantage of a vulnerability. 利用漏洞的实际事件。 Term also refers to the code or methodology used to take advantage of a vulnerability. 术语也指用于利用漏洞的代码或方法。 Threat A potential for violation of security, which exists when there is a circumstance, capability, action, or event, that could breach security and cause harm. 违反安全的潜在可能性，当存在可能违反安全并造成危害的环境、能力、动作或事件时，就存在这种可能性。 Vulnerability vs threat Vulnerabilities are not introduced to a system; rather they are there from the beginning. Threats are introduced to a system like a virus download or a social engineering attack. That is, a threat is a possible danger that might exploit a vulnerability. Attack A threat that is carried out and, if successful, leads to an undersirable violation of security, or threat consequence Attacker The agent carrying out the attack. Types of attack: Active attack: An attempt to alter system resources or affect their operation. 试图改变系统资源或影响其运行。 Passive attack: An attempt to learn or make use of information from the system that does not affect system resources. 试图从系统中学习或使用信息，但不影响系统资源。 Inside attack: Initiated by an entity inside the security perimeter (an “insider”). The insider is authorized to access system resources but uses them in a way not approved by those who granted the authorization. 由安全边界内的实体发起(“内部人员”)。局内人被授权访问系统资源，但使用这些资源的方式没有被授予权限的人批准。 Outside attack: Initiated from outside the perimeter, by an unauthorized or illegitimate user of the system (an “outsider”). 由系统的未经授权或非法用户(“局外人”)从外围发起。 Countermeasure 对策 An action, device, procedure, or technique that reduces a threat, a vulnerability, or an attack by eliminating or preventing it, by minimizing the harm it can cause, or by discovering and reporting it so that corrective action can be taken. 一种动作、装置、程序或技术，通过消除或预防威胁、漏洞或攻击，将其可能造成的伤害降至最低，或通过发现并报告威胁、漏洞或攻击，从而采取纠正措施。 More on threats, attacks, and assets4 threat consequences Unauthorized disclosure 未经授权的披露 Deception 欺骗 Disruption 破坏 Usurpation 篡夺 Unauthorized disclosureA circumstance or event whereby an entity gains acess to data for which the entity is not authorized. 一个实体获得未授权的数据访问权的情况或事件。什么攻击可以引起unauthorized disclosure？ Exposure: Sensitive data are directly released to an unauthorized entity. 将敏感数据直接暴露给未授权的实体。 Interception: An unauthorized entity directly accesses sensitive data traveling between authorized sources and denstinations. 未经授权的实体直接访问在授权源和站点之间传输的敏感数据。 Inference: An unauthorized entity indirectly accesses sensitive data by reasoning from characteristics or by-products of communications. 未经授权的实体通过推理通信的特性或副产品间接访问敏感数据。 Intrusion: An unauthorized entity gains access to sensitive data by circumventing a system’s security protections. 未经授权的实体绕过系统的安全保护，获取敏感数据。 DeceptionA circumstance or event that may result in an authorized entity receiving false data and believing it to be true. 可能导致授权实体收到虚假数据并认为其为真实的情况或事件。什么攻击可以引起deception？ Masquerade 伪装 未经授权的实体通过伪装成授权实体获得对系统的访问权限或执行恶意行为。 Falsification 篡改 虚假数据欺骗授权实体。 Repudiation 否认 一个实体通过错误地否认某一行为的责任来欺骗另一个实体。 DisruptionA circumstance or event that interrupts or prevents the correct operation of system services and functions. 中断或阻止系统服务和功能正常运行的情况或事件。什么攻击可以引起disruption？ Incapacitation: Prevents or interrupts system operation by disabling a system component. 失能:通过使能系统组件，阻止或中断系统运行。 Corruption: Undesirably alters system operation by adversely modifying system functions or data. 损坏:通过对系统功能或数据的不良修改，对系统运行造成不良影响。 Obstruction: A threat action that interrupts delivery of system services by hindering system operation. 阻碍:指通过阻碍系统运行而中断系统业务的威胁行为。 UsurpationA circumstance or event that results in control of system services or functions by an unauthorized entity. 由未经授权的实体控制系统服务或功能的情况或事件。什么攻击可以引起usurpation？ Misappropriation: An entity assumes unauthorized logical or physical control of a system resource. 挪用:一个实体对系统资源进行未经授权的逻辑或物理控制。 Misuse: Causes a system component to perform a function or service that is detrimental to system security. 误用:导致系统组件执行不利于系统安全的功能或服务。 Threats to assets Hardware Major threat: availability Confidentiality Software Major threat: availability Confidentiality, integrity Data A much more widespread problem is data security Availability, confidentiality, integrity Communication lines and networks: network security network security attacks Passive attacks: are in the nature of eavesdropping on, or monitoring of, transmissions (Release of message contents/Traffic analysis) are very difficult to detect because they do not involve any alteration of the data. Active attacks: involve some modification of tha data stream of the creation of a false stream (replay/masquerade/modification of messages/denial of service) CountermeasuresEconomy of mechanismThe design of security measures should be economical to develop, use and verify. Fail-safe designs Access decisions should be based on permission rather than exclusion Default to lack of access So if something goes wrong or is forgotten or isn’t done, no security lost. Complete mediationApply security on every access to a protected object. Every access must be checked against the access control mechanism. Open designthe design of a security mechanism should be open rather than secret.Kerckhoffs principle: A cryptographic system should be secure even if everything about the system, except the key, is public knowledge. Separation of privilegesProvide mechanisms that separate the privileges used for one purpose from those used for another. 提供将用于一个目的的特权与用于另一个目的的特权分开的机制。 Least privilege Every process and every user of the system should operate using the least set of privileges necessary to perform the task 系统的每个进程和每个用户都应该使用执行任务所需的最小权限集进行操作 Require another request to perform another type of access 要求另一个请求来执行另一种类型的访问 Least common mechanismThe design should minimize the functions shared by different users, providing mutual security. Coupling leads to possible security breaches. Psychological acceptability Mechanism must be simple to use 机制必须简单易用 Simple enough that people will use it without thinking about it Must rarely or never prevent permissible accesses 必须很少或从不阻止允许的访问 Computer security strategyA comprehensive security strategy involves three aspects: 复杂的安全策略有三个部分 Specification/policy Implementation/mechanisms prevention detection response recovery Correctness/assurance Assurance &amp; evaluationAssurance is expressed as a degree of confidence, not in terms of a formal proof that a design or implementation is correct. 保证被表达为一种信心的程度，而不是一个设计或实现是正确的正式证明。Evaluation is the process of examining a computer product or system with respect to certain criteria. Evaluation involves testing and may also involve formal analytic or mathematical techniques. 评估是根据一定的标准对计算机产品或系统进行检查的过程。评估包括测试，也可能涉及形式分析或数学技术。 Tools for security Cryptographic tools: Encryption, message authentication code, digital signature, etc. Access control: Only let authorized parties access the system User authentication Intrusion detection/prevention, firewall (IDS: intrusion detection system) (IPS: intrusion prevention system) Lecture 2. Fundamentals of cryptography(1)Classicial &amp; modern cryptography###Private-key encryption secure communication secure storage A private-key encryption scheme is defined by a message space 𝑀 and algorithms (𝐺𝑒𝑛, 𝐸𝑛𝑐, 𝐷𝑒𝑐): 𝐺𝑒𝑛 (key-generation algorithm): generates 𝑘 生成密钥算法 𝐸𝑛𝑐 (encryption algorithm): takes key 𝑘 and message 𝑚 ∈ 𝑀 as input; outputs ciphertext 𝑐 (𝑐 ← 𝐸𝑛𝑐!(𝑚)) 加密算法 𝐷𝑒𝑐 (decryption algorithm): takes key 𝑘 and ciphertext 𝑐 as input; outputs 𝑚 or “error” (𝐷𝑒𝑐!(𝑐) = 𝑚) 解密算法 For all 𝑚 ∈ 𝑀 and 𝑘 output by 𝐺𝑒𝑛, 𝐷𝑒𝑐!(𝐸𝑛𝑐!(𝑚)) = 𝑚 The shift cipher挪移加密，把字母表挪移对照，生成密文（把第二行向左移动k值） Sufficient key space principle The key space should be large enough to prevent “brute-force” exhaustive-search attacks 空间要大，避免暴力法破解 If an encryption scheme has a key space that is too small, then it will be vulnerable to exhaustive-search attacks 如果一个加密方案的密钥空间太小，那么它将容易受到耗尽搜索攻击 凯撒加密法是不安全的","link":"/2023/02/21/CAN304-Computer-Systems-Security/"},{"title":"CPT204 lecture note","text":"lecture的简单笔记记录 Lecture 1Basic Java Review, Checking 1, Testing 1 TypesA type is a set of values, along with operations that can be performed on those values 类型是一组值，以及可以对这些值执行的操作Java has 8 primitive types 8种原始类型boolean, byte, char, long, short, int, float, doubleJava has 2 object types 2种对象类型String, BigInteger OperationsOperations are functions that take input values and produce output values 操作符是接受输入值并产生输出值的函数There’re three different synataxes for an operation in Java: as an infix, prefix, or postfix operator 作为中缀、前缀或后缀操作符 (a + b) as a method of an object 作为对象的方法 (bigint1.add(bigint2)) as a function 作为函数 (Math.sin(x)) Some operations are overloaded, same operation name is used for different types 有些操作是重载的，不同类型使用相同的操作名e.g., arithmetic operators +, -, *, / are overloaded for numeric primitive types Static TypingJava is a statically-typed language. The types of all variables have to be known at compile time (before the program runs), and the compiler can therefore deduce the types of all expressions as well. For example, if a and b are declared as ints, then the compiler concludes that a+b is also an int. In fact, you will shortly see in our lab, IntelliJ environment does this while you’re still typing your code! Java是一种静态类型的语言。所有变量的类型必须在编译时(在程序运行之前)就知道，因此编译器也可以推断出所有表达式的类型。例如，如果a和b被声明为int型，那么编译器就会得出a+b也是int型。事实上，你很快就会在我们的实验室里看到，IntelliJ环境在你输入代码的时候就能做到这一点!In dynamically-typed languages like Python or Javascript, this kind of checking is deferred until runtime (while the program is running) 在动态类型语言如Python或Javascript中，这种检查被推迟到运行时(即程序运行时) Static CheckingStatic typing is a particular kind of static checking, which means checking for bugs at compile time. 静态类型是一种特殊类型的静态检查，这意味着在编译时检查bug例如输入&quot;5&quot; * &quot;6&quot;，静态输入会在你coding的时候就捕捉到错误，而不是到这一行被运行的时候再捕捉错误。 Lecture 2Checking 2, Testing 2, Immutability, List, Map CheckingThree kinds of automatic checking that a language can provide: static checking: the bug is found automatically before the program even runs 静态：程序开始前就被捕捉 dynamic checking: the bug is found automatically when the code is executed 动态：程序开始运行才被捕捉 no checking: the language doesn’t help you find the error at all. U have to watch for it yourself, or end up with wrong answers. no checking：程序不会帮忙捕捉，需要自己检查出来，但是不捕捉会产生错误结果。 不用说，静态地捕获bug比动态地捕获要好，而动态地捕获总比根本不捕获要好! Static Checkingstatic checking can catch: syntax errors, like extra punctuation or spurious words 语法错误，比如多余的标点符号或虚假的单词 wrong names, Math.sine(2) (the right name is sin) 名字错了 wrong number of arguments, Math.sin(30,20) 参数的数量错了 wrong argument types, Math.sin(“30”) 参数的数据类型错了 wrong return types, return “30”; from a function that’s declared to return an int 返回量的数据类型错了，应该返回int却返回了str Dynamic Checkingdynamic checking can catch: illegal argument values, for example, the integer expression x/y is only erroneous when y is actually zero 非法的实参值，例如，整数表达式x/y只有在y实际为零时才会出错;否则工作!所以在这个表达式中，被零除不是一个静态错误，而是一个动态错误 unpresentable return values, when the specific return value can’t be represented in the type 不可表示的返回值，当特定的返回值不能在类型中表示时 out-of-range index, using a negative or too-large index on a string 超出范围的索引，在字符串上使用负或过大的索引 calling a method on a null object reference 调用空对象的方法 No CheckingOne trap in Java — and many other programming languages — is that its primitive numeric types have corner cases that do not behave like the integers and real numbers we’re used to.As a result, some errors that really should be dynamically checked are not checked at all!Java(以及许多其他编程语言)中的一个陷阱是，其原始数字类型有一些不像我们所习惯的整数和实数那样的情况。因此，一些真正应该动态检查的错误根本没有被检查! Integer division, for example, 5/2 should equals 2.5 however the result is 2. Integer overflow, for example, 就是整数太大了或者太小了超过int的范围。 special values in floating-point types: Floating-point types like double types have several special values that aren’t real numbers: NaN (which stands for “Not a Number”), POSITIVE_INFINITY, and NEGATIVE_INFINITY. When you apply certain operations to a double that you’d expect to produce dynamic errors, like dividing by zero or taking the square root of a negative number, you will get one of these special values instead. 以下代码块的结果应该是no checking123double a = 7;double b = 0;double div = a/b; Two goals communicating with the computer communicating with other people Snapshot DiagramsSnapshot diagrams represent the internal state of a program at runtime – its stack (methods in progress and their local variables) and its heap (objects that currently exist) 快照图表示程序在运行时的内部状态——它的堆栈(正在进行的方法及其局部变量)和它的堆(当前存在的对象) Primitive Values原始值代表了bare constants，例如n = 5，这种情况直接用一个单箭头来表示赋值，就是字母n箭头指向5（n –&gt; 5） Object ValuesAn object value is a circle labeled by its type. 对象就是箭头指向圈。 Reassigning Variables vs Mutating Values When you assign to a variable, you’re changing where the variable’s arrow points – you can point it to a different value 当你给一个变量赋值时，你改变了变量的箭头指向——你可以给它指向一个不同的值 When you change the contents of a mutable value – such as an array or list – you’re changing references inside that value, this is called mutating the value 当你改变一个可变值的内容时——比如一个数组或列表——你改变了那个值内部的引用，这叫做改变值 string is an example of an immutable value这种不可变的type，在画图时使用两个圈表示，注意看上图的string。 Mutable ValuesStringBuilder is a mutable value that represents a string of characters StringBuilder是可以修改的 Immutable Referencesfinal int n = 5; 有final的说明是Immutable，这里的箭头用双线箭头表示 Pay attention not to confuse reference versus value, when we talk about mutability versus immutability 注意区别 Notice that we can have an immutable reference to a mutable value (for example: final StringBuilder sb) whose value can change even though we’re always pointing to the same object We can also have a mutable reference to an immutable value (for example: String s), where the value of the variable can change because it can be re-pointed to a different object Lecture 3Coding Rules, Testing 3, RecursionThere are sensible coding rules that help us to write good code: making it safe from bugs, easy to understand, and ready for change: Don’t Repeat Yourself (DRY) Comments where needed Fail fast Avoid magic numbers One purpose for each variable Use good names Don’t use global variables Return results, don’t print them Use whitespace for readability TestingDivide the input space into subdomains, each consisting of a set of inputs其中每个subdomains包含相似的输入，这些输入在函数内会有相似的输出然后对不同参数的subdomains进行排列组合 Lecture 4Testing 4, Linked List 1 Testing Black-box vs White-box Testing Unit vs Integration Testing Automated Regression Testing Testing Documents and Coverage Blackbox&amp;WhiteboxBlack box testing means choosing test cases only from the specification, not the implementation of the method 黑盒测试意味着只从规范中选择测试用例，而不是方法的实现就是我不需要知道功能是怎么实现的，只需要测试功能能不能正常使用，假如不能正常使用就告诉开发，约等于功能测试。white box testing 白盒测试就是从代码层面去分析代码是否可以正常运行 CoverageCoverage: how thoroughly it exercises the program 覆盖范围:它执行程序的彻底程度There are three common kinds of coverage: Statement coverage: is every statement run by some test case? 测试是否让每行代码都运行过 Branch coverage: for every if or while statement in the program, are both the true and the false direction taken by some test case? 每个分支是否都运行过一遍 Path coverage: is every possible combination of branches — every path through the program — taken by some test case? Path &gt; Branch &gt; Statement Lecture 5SpecificationA specification is like a contract for part of your program 一个规范就像是你程序的一部分的契约 saying what it can count on from the rest of the program 说什么它可以指望从其余的程序 and what it’s expected to do in return 以及期望它做什么作为回报 Why Specification? many of the nastiest bugs in program arise because of misunderstandings about behavior at the interface between two pieces of code 程序中许多最糟糕的错误都是由于对两段代码之间的接口行为的误解而产生的 Specifications are good for the client of a method because they spare the task of reading code 规范对方法的客户端是有益的，因为它们省去了阅读代码的任务 Spec and implementerSpecifications are good for the implementer of a method because they give the implementer freedom to change the implementation without telling clients 规范对方法的实现者是有益的，因为它们给了实现者在不通知客户的情况下更改实现的自由 Spec and Client The contract acts as a firewall between the client and the implementer 合同充当了客户端和实现者之间的防火墙 This firewall results in decoupling, allowing the code of the unit and the code of a client to be changed independently, so long as the changes respect the specification — each obeying its obligation 这种防火墙导致了解耦，允许单元代码和客户端代码独立地进行更改，只要这些更改遵守规范——每个都遵守自己的义务 Specification StructureA specification of a method consists of two clauses: a precondition, indicated by the keyword requires 是调用者的责任 a postcondition, indicated by the keyword effects 是实现者的责任 Java has a convention for documentation comments, in which parameters are described by @param clauses and results are described by @return and @throws clauses Put the preconditions into @param where possible precondition是放参数 Put postconditions into @return and @throws postcondition是放return值和抛出的异常 @后面都不需要数据类型，只需要变量名 Lecture 6Exception Null References","link":"/2022/04/04/CPT204-lecture-note/"},{"title":"CPT208 Design Life Cycle","text":"Human-Centric Computing The Design Life CycleIt’s a interface/interaction design - an iterative process:design –&gt; implementation –&gt; evaluation –&gt; design not always start with design maybe first figure out what people need/want (evaluation) maybe there was an initial system (implementation) quite expensive having to re-implement a (complex) system over and over better strategies needed-ideas? different types of “implementation” different degrees of evaluation 为什么要有interface design process? to avoid user frustration with the finished product to avoid unnecessary costs during product development 减小产品开发过程中不必要的开销 to avoid additional cost after product development 减小产品开发后的多余开销 reasons for going over budget user-requested changes overlooked tasks users did not understand their own requirements insufficient user-developer communication and understanding Foundations for designing interfaces Understanding users and their tasks Task-centered system design how to develop task examples how to evaluate designs through a task-centered walk-through Designing with the user User-centered design and prototyping methods for designed with the user low and medium fidelity prototyping Evaluating interfaces with users the role of evaluation in interface design how to observe people using systems to detect interface problems Considerations when designing interfacesdo I know who my user and what their tasks are? how much computer knowledge? novice? occasional user? regular user? expert? what do people want to achieve, what are the tasks? novel interfaces: what hardware I can expect? Storyline VisualizationDesign Principles D1 Lines in the same group should appear next to each other. D2 Otherwise, lines must be far away from each other. D3 A line must remain straight unless its group changes. Optimization Goals reducing line crossings reducing line wiggles reducing white space","link":"/2022/02/07/CPT208-Design-Life-Cycle/"},{"title":"吴恩达机器学习 Part2","text":"Model representation Cost function有时候也会被叫做平方误差代价函数 Gradient descent algorithm 梯度下降法learning rate后面的部分是derivative假如阿尔法太小，梯度就会减缓。假如阿尔法太大，梯度下降可能超过最小值。","link":"/2022/01/19/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-part2/"},{"title":"吴恩达机器学习 Part1","text":"Machine learning definitionWell-posed learning problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E. Machine learning algorithms: supervised learning 我们教计算机做某件事 unsupervised learning 计算机自己总结学会做某事 Others: Reinforcement learning, recommender systems. supervised learning想法是在监督学习中，对于数据集中的每个样本，我们想要算法预测并得到正确答案。分类问题 classification problem 回归问题 regression problem unsupervised learning把大量的数据给到computer 计算机自习学会做某事","link":"/2022/01/19/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Part1/"},{"title":"CS224n learning part2","text":"how do we represent the meaning of a words?Definition: meaning (webster dictionary) the idea that is represented by a word, phrase, etc. and so on. Commonest linguistic way of thinking of meaning: 最常见的意义思维方式 signifier &lt;====&gt; signified (idea or thing) = denotation main idea of word2vec1Predict between every word and its context words. Two algorithms Skip-grams (SG) Predict context words given target (position independent) Continuous Bag of Words (CBOW) Predict target word from bag of words context Two (moderately efficient) training methods Hierarchical softmax Negative sampling Details of Word2VecPredict surrounding words in a window of radius m of every word.For p(wt+j|wt) the simple first formulation iswhere o is the outside (or output) word index, c is the center word index, vc and uo are “center” and “outside” vectors of indices c and o.每个词都可以有两个向量（一个也可以 但是两个更简单） Sentence embeddingCompute sentence similarity using the inner product. 1234567S1: Mexico wishes to guarantee citizen's safety.S2: Mexico wishes to avoid more violence.Score: 4/5S1: Iranians Vote in Presidential ElectionS2: Keita Wins Mali Presidential ElectionScore: 0.4/5 Use as features for sentence classification. 语意感情分析 From Bag-of-words to Complex models Bag-of-words BoW1v(&quot;natural language processing&quot;) = 1/3(v(&quot;natural&quot;) + v(&quot;language&quot;) + v(&quot;processing&quot;)) Recurrent neural networks, recursive neural networks, convolutional neural networks…","link":"/2022/01/17/CS224n-learning-part2/"},{"title":"CS224n learning part1","text":"This is the introduction lecture of NLP (Netural language processing)NLP和深度学习入门。 What’s deep learning? 1Deep learning is a subfield of machine learning. Most machine learning methods work well because of human-designed representations and input features. 大多数机器学习方法都能很好地工作，因为有了人类设计的表示和输入特征。Machine learning becomes just optimizing weights to best make a final prediction. Representation learning attempts to automatically learning good features or representations 试图自动学习好的特征或表示 Deep learning algorithms attempt to learn (multiple levels of) representation and an output. 深度学习算法试图学习(多级)表示和输出。 Deep NLP = Deep Learning + NLPcombine ideas and goals of NLP with using representation learning and deep learning methods to solve them. Several big improvements in recent years in NLP with different levels: speech, words, syntax, semantics. tools: parts of speech, entities, parsing. application: machine translation, sentiment analysis, dialogue agents, question answering. Conclusion: Representation for all levels? Vectors","link":"/2022/01/17/CS224n-learning-part1/"},{"title":"INT201 W8","text":"这周换一个方法记录blog，以记录自己想记录的东西为主。 在language的大集合里，有一部分语言被作为regular languages，测试他们是否是regular languages的方法是使用DFA &amp; NFA &amp; RL，pumpling lemma得出了有一部分语言是unregular的，unregular的语言不可以用DFA NFA Regular expression去define。这是就需要Grammar（content free grammar） which可以define regular languages and unregular languages Content-free GrammarG = (V, A, S, P)V is a set of variables.A is constant, terminates 阿尔法贝塔S is a variable, state symobleP is a set of rules (production) eg: x -&gt; a a属于(VUA)^* 类似转移方程？都是有限集S –&gt; aSb content-free意味着ab对S没有影响L(G) = {w|wEA*, s-&gt;w}","link":"/2021/11/23/INT201-W8/"},{"title":"CAN201 W9","text":"Routing (2) - Distance vector algorithm Intra-AS routing in the Internet: OSPF Routing among the ISPs: BGP The SDN control plane ICMP SNMP 路由选择算法路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分： 集中式路由选择算法（centralized routing algorithm）用完整的全局的网络知识计算出从源到目的地之间的最低开销路径。也就是说假如要计算的时候需要知道所有的路径的距离才可以开始计算。具有全集状态信息的算法被称为链路状态（Link State, LS）算法。 分散式路由选择算法（decentralized routing algorithm）中，路由器以迭代，分布式的计算方法计算出最低开销路径。没有节点拥有关于所有网络的链路的开销的完整信息。距离向量算法（Distance-Vector, DV）。 第二种分类方法是 静态路由选择算法 （static routing algorithm） 动态路由选择算法 （dynamic routing algorithm） LS算法比如Dijkstra, Prim之类的 距离向量算法 DV比如Bellman-Ford OSPF","link":"/2021/11/11/CAN201-W9/"},{"title":"CPT203 W8","text":"这周的内容： UML类图 时序图 状态图 活动图 老师讲的ppt太寄了，建议自己学习。","link":"/2021/11/10/CPT203-W8/"},{"title":"CAN201 W8","text":"Terms of packet in different layers Application layer: message Transport layer: segment Network layer: datagram Link layer: frame TCP three-way handshake A -&gt; B: SYN (seq = x, ack = 0, L = 0) B -&gt; A: SYN ACK (seq = y, ack = x+1, L = 0) A-&gt;B: ACK (seq=x+1,ack=y+1,L=0) Flow Control vs. Congestion Control Host vs. Router 这周还是继续IP的学习 LectureIP编址：引论 IP地址：32位标示，对主机或者路由器接口编址 接口：主机/路由器和物理链路的连接处 路由器通常拥有多个接口 主机也可能有多个接口 IP地址和每一个接口关联 一个IP地址和一个接口相关联 路由器一般有两个到两个以上的IP地址。 这些接口是如何连接的？ 有线以太网链接到以太网网络交换机连接 无线WI-FI接口被WI-FI基站连接子网 subnet IP地址： 子网部分 subnet part - high order bits 主机部分 host part - low order bits 在同一子网的IP地址拥有相同的prefix 什么是子网 一个子网内的节点（主机或者路由器）他们的IP地址高位部分相同，这些节点构成的网络这一部分叫做子网 无需路由器介入，子网内的各主机可以在物理上相互直接到达 将每一个接口从主机或者路由器上分开，构成了一个个网络孤岛，每一个网络孤岛都是一个subnet。 IP地址分类 Class A: 126 networks, 16 million hosts 开头0 Class B: 16382 networks, 64K hosts 开头10 Class C: 2 million networks, 254 hosts 开头110 Class D: multicast 开头1110 Class E: reserved for future IP地址: CIDRCIDR: Classless Inter Domain Routing 无类域间路由（按需分配） Subnet portion of address of arbitrary length 子网部分可以在任意区域 Address format: a.b.c.d/x, where x is # bits in subnet portion of address 其中x是地址中子网号的长度子网掩码也是32位，假如是网络号部分那就是全是1，假如是主机号部分就都写0，再用点十计算。 如何获得IP地址Q:主机如何获得IP地址? 系统管理员将地址配置到一个文件中： wintel: control - panel -&gt; network -&gt; configuration -&gt; tcp/ip -&gt; properties UNIX: /etc/rc.config DHCP: Dynamic Host Configuration Protocol:从服务器中动态获得一个IP地址 “plug and play” DHCP: Dynamic Host Configuration ProtocolGoal: allow host to dynamically obtain its IP address from network server when it joins network Can renew its lease on address in use Allows reuse of addresses (only hold address while connected/“on”) Support for mobile users who want to join network (more shortly) DHCP overview: host broadcasts “DHCP discover” msg [optional] DHCP server responds with “DHCP offer” msg [optional] host requests IP address: “DHCP request” msg DHCP server sends address: “DHCP ack” msg DHCP can return more than just allocated IP address on subnet: Address of first-hop router for client 客户端第一跳路由器地址 Name and IP address of DNS sever DNS服务器的名称和IP地址 Network mask (indicating network versus host portion of address) 网络掩码(表示地址的网络与主机部分) DHCP: example 看ppt上有图 路由聚集（route aggregation）层次编址允许路由信息的有效广播：找到几个IP地址的相同前缀聚合详解超网技术（路由聚合技术）聚集可以提高寻找表项的速度，减少表项的数量。 NAT: network address translation网络地址转换所有离开本地网络的数据报具有一个相同的源地址NAT IP address: 138.76.29.7，但是具有不同的端口号。本网发送的数据报源地址是10.0.0.0/24，到达本网节点的目标地址为10.0.0.0/24。动机：本地网络只有一个有效IP地址： 不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备 – 省钱 可以在局域网改变设备的地址情况下而无需通知外界 可以改变ISP（地址变化）而不需要改变内部的设备地址 局域网内部设备没有明确的地址，对外是不可见的 – 安全 16 bit端口字段： 6万多个同时连接，一个局域网 对NAT是有争议的 路由器只应该对第三层做信息处理，而这里对端口号（4层）做了处理 违背了end-end原则 端到端原则：复杂性放到网络边缘 无需借助中转和变换，就可以直接传送到目标主机 NAT可能要被一些应用设计者考虑（P2P） 外网的机器无法连接到内网的机器上 地址短缺问题可以被IPv6解决 NAT穿越：如果客户端需要连接在NAT后面的服务器，如何操作 IPv6初始动机：32bit的地址空间将会很快用完 头部格式改变帮助加速处理和转发 TTL-1 头部checksum 分片 头部格式改变帮助QoS IPv6数据报格式： 固定的40字节头部 数据报传输过程中，不允许分片 Priority: 标示数据报的优先级Flow label: 标示数据报在一个“flow”Next header: 标示上层协议 和IPv4的其他变化 Checksum: 被移除掉，降低在每一段中的处理速度 Options: 允许，但是在头部之外，被”Next Header”字段标示 ICMPv6: ICMP的新版本 附加了报文类型 多播组管理功能 Transition from IPv4 to IPv6 Not all routers can be upgraded simultaneously No “flag days” How will network operate with mixed IPv4 and IPv6 routers? Tunneling: IPv6 datagram carried as payload in IPv4 datagram among IPv4 routers Generalized Forward and SDN路由的概念 路由：按照某种指标（传输延迟，所经过的站点数目等）找到一条从源节点到目标节点的较好路径 较好路径：按照某种指标较小的路径 指标：站数，延迟，费用，队列长度等，或者是一些单纯指标的加权平均 采用什么样的指标，标示网络使用者希望网络在什么方面表现突出，什么指标网络使用者较为重视 路由器-路由器之间的最优路径 = 主机队之间的最优路径 路由器连接子网，到路由器之间的跳数就一跳，必须要走 路由器到下一跳路由器（节点到节点）之间的最优路径找到了 也就找到了从源子网向目标子网所有主机对之前的最优路径 大大降低了路由计算的规模 在路由计算中按照子网到子网的路径计算为目标，而不是主机到主机 路由选择算法（routing algorithm）：网络层软件的一部分，完成路由功能 路由原则路由选择算法的原则： 稳定性 stability: 产生的路由不应该摇摆 公平性 fairness: 对每一个站点都公平 最优性 optimality: 某一个指标的最优，时间上，费用上，等指标，或综合指标：实际上，获得最优的结果代价较高，可能是次优的 迪杰斯特拉算法迪杰斯特拉算法详解+模版+例题","link":"/2021/11/08/CAN201-W8/"},{"title":"CAN201 W6","text":"Lecture记虽然笔记迟了，但是一定会补回来呀！这周第一部分是TCP congestion control。我有空再写笔记，我们先进入第二环节。也就是网络层 Network layer. 网络层服务 在发送主机和接收主机对之间发送段（segment） 在发送端把段封装到数据报（datagram）中 在接收端，将段上交给传输层实体 网络层协议存在于每一个主机和路由器（全部都有） 路由器检查每一个经过他的IP数据报头部 网络层功能： 转发：将分组从路由器的输入接口转发到合适的输出接口。路由：使用路由算法来决定分组从发送主机到目标接受主机的路径（路由选择算法和路由选择协议） 数据平面 本地，每个路由器功能 决定从路由器输入端口到达的分组如何转发到输出端口 转发功能： 传统方式：基于目标地址+转发表 SDN方式：基于多个字段+流表控制平面 网络范围内的逻辑 决定数据报如何在路由器之间路由，决定数据包从源到目标主机之间的端到端路径 2个控制平面方法： 传统的路由算法：在路由器中被实现 software-defined networking (SDN): 在远程的服务器中实现 传统方式：每-路由器控制平面（per-router）在每一个路由器中的单独路由器算法元件，在控制平面进行交互传统方式的路由和转发的相互作用 SDN方式：逻辑集中的控制平面一个不同的（通常是远程的）控制器和本地控制代理（CAs）交互传统方式是僵化的，不可以编程，SDN方式可以对网络进行编程操作。 网络服务模型从发送方主机到接收方主机传输数据报的“通道”，网络提供什么养的服务模型？对于单个数据报的服务： 可靠传送 延迟保证，如：少于40ms的延迟 对于数据报流的服务： 保序数据报传送 保证流的最小带宽 分组之间的延迟差 连接建立 在某些网络架构中是第三个重要的功能 ATM, frame relay, X.25 在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接（涉及到路由器） 网络层和传输层连接服务区别： 网络层：在2个主机之间，涉及到路径上的一些路由器 传输层：在两个进程之间，很可能只体现在端系统上（TCP连接） CBR:恒定速率; VBR:变化速率; ABR:可用比特率; UBR:不指名比特率; 路由器结构概况高层面（非常简化的）通过路由器体系架构 路由：运行路由选择算法/协议（RIP, OSPF, BGP）生存路由表 转发：从输入到输出链路交换数据报–根据路由表进行分组的转发 输入端口功能为什么输入端口有队列？（输入端口缓存） 当交换机构的速率小于输入端口的汇聚速率时–&gt;在输入端口可能要排队（排队延迟以及由于输入缓存溢出会造成丢失） Head-of-the-line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据向前移动在一个分组时间内，绿色分组遭到了堵塞。 通过内存交换第一代路由器 在CPU直接控制下的交换，采用传统的计算机。 分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口。 转发速率被内存的带宽限制（数据报通过BUS两遍）–&gt; 不足之处 一次只能转发一个分组 通过总线交换 数据报通过共享总线，从输入端口转发到输出端口 总线竞争：交换速度受限于总线带宽（但是现在只通过总线一次了） 一次处理一个分组 对于接入或企业级路由器，速度足够（但是不适合区域或者骨干网络） 通过互联网络（crossbar）交换 同时并发转发多个分组，克服总线带宽限制 Banyan（榕树）网络，crossbar（纵横）和其他的网络互联网被开发，将多个处理器连接成多处理器 当分组从端口A到达，转给端口Y：控制器短接相应的两个总线 高级设计：将数据报分片为固定长度的信元，通过交换网络交换 输出端口 当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存 由调度规则选择排队的数据报进行传输 输出端口排队 假设交换速率Rswitch是Rline的N倍（N：输入端口的数量） 当多个输入端口同时想输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存） 排队带来延迟，由于输出端口缓存溢出则丢弃数据报！ 调度机制那输出端口缓存溢出应该怎么调度呢？ 调度：选择下一个要通过链路的传输分组 FIFO (first in first out) scheduling: 按照分组来到的次序发送 丢弃策略：如果分组达到一个满的队列，哪个分组会被抛弃呢？ tail drop：丢弃刚到达的分组 priority：根据优先权丢失/移除分组 random：随机的丢失/移除 调度策略：优先权优先权调度：发送最高优先权的分组多类，不同类别有不同的优先权 类别可以依赖于标记或者其他的头部字段：IP source/dest, port, numbers, ds, etc. 先传高级别的队列中的分组，除非没有假如有红的就一直红的，一直到没有红的再传绿的。 调度策略：其他Round Robin (RR) scheduling:循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类。学过，看看复习一下。 Weighted Fair Queuing (WFQ): 一般化的RR 在一段时间内，每个队列得到的服务时间是：Wi/(XIGMA(Wi))*t，和权重成正比 每个类在每一个循环中获得不同权重的服务量 IP: Internet ProtocolIP协议在哪里？干啥？（数据层面的转发功能）在传输层和链路层之间的网络层。主机，路由器中的网络层功能有：路由协议（路径选择，RIP,OSPF,BGP），IP协议（地址约定，数据报格式，分组处理的约定），ICMP协议（错误报告，路由器信令） IP数据报格式 IP分片和重组(IP fragmentation, reassembly) 网络链路有MTU（最大传输单元）即链路层帧所携带的最大数据长度 不同的链路类型 不同的MTU 大的IP数据报在网络上分片“fragmented” 一个数据报被分割成若干个小的数据报 相同的ID 不同的偏移量 最后一个分片标记为0 重组只在最终的目标主机进行（为什么不在中间重组，因为路由器太忙了，还可能路由表会变，中间几个分组还可以丢失，所以不如直接在目标主机进行） IP头部的信息被用于标识，排序相关分片 4000字节数据报 –&gt; 20字节头部，3980字节数据 MTU = 1500 bytes 第一片：20字节头部+1480字节数据（偏移量：0） 第二片：20字节头部+1480字节应用数据（偏移量：1480/8=185） 第三片：20字节头部+1020字节应用数据（偏移量：2960/8=370） 偏移（以8字节为单位）= 1480/8 fragflag等于1说明后面还有切片，等于0说明这就是最后一个切片了 基于目的地转发转发表是由路由选择处理器计算和更新的，或者转发表接收来自远程SDN控制器的内容。对于这个例子，在路由器的转发表中没有必要有40亿个表项，所以我们把这个表写成一个只有四个表项的转发表：使用这种风格的转发表，路由器通过分组目的地址的前缀（prefix）与该表中的表项进行匹配；当有多个匹配时，该路由器使用最长前缀匹配规则（longest prefix matching rule）:即在该表中寻找最长的匹配项，并向与最长前缀匹配相关联的链路接口转发分组。实践中也经常使用三态内容可寻址储存器（Tenary Content Address Memory, TCAM）来查找表项。 内容可寻址（Content addressable）:当前地址到TCAM:检索地址在一个时钟周期，无论表大小 Cisco Catalyst:可以在TCAM中增加~1M的路由表项 Lab讲的assignment1的task sheet。没什么卵用。","link":"/2021/11/07/CAN201-W6/"},{"title":"CPT203 W6","text":"This’s the note of System Modeling. Context models Interaction models Structural models Behavioral models Model-driven engineering 这周各种东西要记的也太多了吧。。。 LectureBasic TermsSoftware Process Requirements Engineering 需求工程 System Modelling 系统建模 System Architecture 系统架构 System Design 系统设计 为什么modeling很重要？建模通过将复杂系统抽象为适当的细节级别来简化复杂系统垃圾的software development失败大多可以归结于: Poorly understood requirements 知之甚少的需求 Problems often discovered late in the development 问题往往在开发的后期发现 Complexity lead to performance issues 复杂性会导致性能问题 System modeling System modeling is the process of developing abstract models of a system, with each model presenting a different view or perspective of that system. 系统建模是开发系统抽象模型的过程，每个模型呈现系统的不同视图或透视图。 System modeling has now come to mean representing a system using some kind of graphical notation, which is now almost always based on notations in the Unified Modeling Language (UML). 系统建模现在已经意味着使用某种图形符号来表示系统，现在几乎总是基于统一建模语言(UML)中的符号。 System modelling helps the analyst to understand the functionality of the system and models are used to communicate with customers. 系统建模帮助分析人员了解系统的功能，并使用模型与客户进行沟通。 Existing and planned system models Models of the existing system are used during requirements engineering. They help clarify what the existing system does and can be used as a basis for discussing its strengths and weaknesses. These then lead to requirements for the new system. 在需求工程中使用现有系统的模型。它们有助于澄清现有系统的功能，并可作为讨论其优缺点的基础。这就导致了对新系统的需求。 Models of the new system are used during requirements engineering to help explain the proposed requirements to other system stakeholders. Engineers use these models to discuss design proposals and to document the system for implementation. 在需求工程期间使用新系统的模型，以帮助向其他系统涉众解释建议的需求。工程师使用这些模型来讨论设计建议，并记录系统的实施。 In a model-driven engineering process, it is possible to generate a complete or partial system implementation from the system model. 在模型驱动的工程过程中，可以从系统模型生成完整或部分的系统实现。 System perspective 系统的视角 An external perspective, where you model the context or environment of the system. 外部透视图，在其中建模系统的上下文或环境。 An interaction perspective, where you model the interactions between a system and its environment, or between the components of a system. 一个交互的视角，在那里你建模一个系统和它的环境之间的交互，或者一个系统的组件之间的交互。 A structural perspective, where you model the organization of a system or the structure of the data that is processed by the system. 结构视角，在其中对系统的组织或系统处理的数据结构进行建模。 A behavioral perspective, where you model the dynamic behavior of the system and how it responds to events. 行为视角，你可以建模系统的动态行为以及它如何响应事件。 UML diagram types Activity diagrams, which show the activities involved in a process or in data processing. Use case diagrams, which show the interactions between a system and its environment. Sequence diagrams, which show interactions between actors and the system and between system components. Class diagrams, which show the object classes in the system and the associations between these classes. State machine diagrams, which show how the system reacts to internal and external events. PS: 在用例图中，我们总是会选择的最简单的事件进行记录(as simply as possible)。而且在用例图中，事件并不是以flow的形式存在的(或是说存在flow的内容都被use case省略到一个事件里的？)。但是在activity diagram中，事件就是会有flow的形式存在。 Use of graphical models As a means of facilitating discussion about an existing or proposed system 作为促进对现有或拟议系统的讨论的一种手段 Incomplete and incorrect models are OK as their role is to support discussion. 不完整和不正确的模型是可以的，因为它们的作用是支持讨论。 As a way of documenting an existing system 作为一种记录现有系统的方法 Models should be an accurate representation of the system but need not be complete. 模型应该是系统的准确表现，但不必是完整的。 As a detailed system description that can be used to generate a system implementation 作为一个详细的系统描述，可以用来生成一个系统实现 Models have to be both correct and complete. 模型必须正确和完整。 PS: 这里需要注意，模型的正确与否和是否完整并没有一个固定的要求，不同的情况对模型的要求是不一样的。有的时候不完整或者不正确的模型就可以开始讨论了，有时候需要完全正确和完整。 The context of the MHC-PMS Context models Context models simply show the other systems in the environment, not how the system being developed is used in that environment. 上下文模型只是显示环境中的其他系统，而不是正在开发的系统如何在该环境中使用。 Used along with other models, such as business process models. 与其他模型一起使用，如业务流程模型。 UML activity diagrams may be used to define business process models. UML活动图可以用来定义业务流程模型。 Process model of involuntary detention Interaction models 互动模型 Modeling user interaction is important as it helps to identify user requirements. 用户交互建模非常重要，因为它有助于识别用户需求。 Modeling system-to-system interaction highlights the communication problems that may arise. 系统到系统交互建模强调了可能出现的通信问题。 Modeling component interaction helps us understand if a proposed system structure is likely to deliver the required system performance and dependability. 建模组件交互帮助我们理解所提议的系统结构是否可能交付所需的系统性能和可靠性。 Use case diagrams and sequence diagrams may be used for interaction modeling. 用例图和序列图可以用于交互建模。 Use case diagram Use cases are developed originally to support requirements elicitation and now incorporated into the UML. 用例最初是为了支持需求引出而开发的，现在被合并到UML中。 Each use case represents a discrete task that involves external interaction with a system. 每个用例代表一个离散的任务，它涉及到与系统的外部交互。 Actors in a use case may be people or other systems. 用例中的参与者可能是人或其他系统。 Represented diagramatically to provide an overview of the use case and in a more detailed textual form. 以图表形式表示，以更详细的文本形式提供用例的概述。 Transfer-data use caseA use case in the MHC-PMS“传输数据”用例的表格式描述 Tabular description of the ‘Transfer data’ use-caseUse cases in the MHC-PMS involving the role ‘Medical Receptionist’ Sequence diagrams Sequence diagrams are part of the UML and are used to model the interactions between the actors and the objects within a system. 序列图是UML的一部分，用于对系统中参与者和对象之间的交互进行建模。 A sequence diagram shows the sequence of interactions that take place during a particular use case or use case instance. 序列图显示了在特定用例或用例实例中发生的交互序列。 The objects and actors involved are listed along the top of the diagram, with a dotted line drawn vertically from these. 所涉及的对象和参与者在图表的顶部列出，并在垂直方向上画一条虚线。 Interactions between objects are indicated by annotated arrows. 对象之间的交互通过标注的箭头表示。 Sequence diagram for View patient information Structural models 结构模型 Structural models of software display the organization of a system in terms of the components that make up that system and their relationships. 软件的结构模型根据组成系统的组件及其关系来显示系统的组织。 Structural models may be static models, which show the structure of the system design, or dynamic models, which show the organization of the system when it is executing. 结构模型可以是静态模型，它显示系统设计的结构，也可以是动态模型，它显示系统执行时的组织。 You create structural models of a system when you are discussing and designing the system architecture. 在讨论和设计系统架构时创建系统的结构模型。 Class diagrams Class diagrams are used when developing an object- oriented system model to show the classes in a system and the associations between these classes. 在开发面向对象的系统模型时使用类图来显示系统中的类以及这些类之间的关联。 An object class can be thought of as a general definition of one kind of system object. 一个对象类可以被认为是一种系统对象的一般定义。 An association is a link between classes that indicates that there is some relationship between these classes. 关联是类之间的链接，表明这些类之间存在某种关系。 When you are developing models during the early stages of the software engineering process, objects represent something in the real world, such as a patient, a prescription, doctor, etc. 当你在软件工程过程的早期阶段开发模型时，对象代表了现实世界中的某些东西，如病人、处方、医生等。 这就是类图的作用，具体细节自行查询并学习（课件上有一些介绍），在大二的CPT105中学过如何绘制Java的UML类图。 Behavioral models 行为模型 Behavioral models are models of the dynamic behavior of a system as it is executing. They show what happens or what is supposed to happen when a system responds to a stimulus from its environment. 行为模型是系统在执行过程中动态行为的模型。它们显示了当系统对环境的刺激作出反应时发生了什么或应该发生什么。 You can think of these stimuli as being of two types: 这些刺激分为两种 Data Some data arrives that has to be processed by the system. 一些到达的数据必须被系统处理。 Events Some event happens that triggers system processing. Events may have associated data, although this is not always the case. 事件触发系统处理的事件。事件可能有相关的数据，尽管情况并非总是如此。 Data-driven modeling 数据驱动模型 Many business systems are data-processing systems that are primarily driven by data. They are controlled by the data input to the system, with relatively little external event processing. 许多业务系统是主要由数据驱动的数据处理系统。它们由输入到系统的数据控制，外部事件处理相对较少。 Data-driven models show the sequence of actions involved in processing input data and generating an associated output. 数据驱动模型显示了处理输入数据和生成相关输出所涉及的操作序列。 They are particularly useful during the analysis of requirements as they can be used to show end-to-end processing in a system. 它们在需求分析期间特别有用，因为它们可以用来显示系统中的端到端处理。 Activity diagram and sequence diagram are used in data-driven modeling. 数据驱动建模使用活动图和序列图。 Event-driven modeling 事件驱动模型 Real-time systems are often event-driven, with minimal data processing. For example, a landline phone switching system responds to events such as ‘receiver off hook’ by generating a dial tone. 实时系统通常是事件驱动的，数据处理很少。例如，固定电话交换系统通过产生拨号音来响应“接收机挂断”等事件。 Event-driven modeling shows how a system responds to external and internal events. 事件驱动模型演示了一个系统如何响应内部和外部的事件。 It is based on the assumption that a system has a finite number of states and that events (stimuli) may cause a transition from one state to another. 系统基于这样的推测：系统有有限数量的状态，并且事件(刺激)可能导致从一种状态到另一种状态的转换。 State machine diagram 状态机图 These model the behaviour of the system in response to external and internal events. 这些模型模拟系统在响应外部和内部事件时的行为。 They show the system’s responses to stimuli so are often used for modelling real-time systems. 它们显示系统对刺激的反应，因此经常用于建模实时系统。 State machine models show system states as nodes and events as arcs between these nodes. When an event occurs, the system moves from one state to another. 状态机模型将系统状态显示为节点，事件显示为节点之间的弧线。当事件发生时，系统从一种状态转移到另一种状态。 Statecharts are an integral part of the UML and are used to represent state machine models. 状态图是UML不可分割的一部分，用于表示状态机模型。 然后需要有说明状态的表格 Model-driven engineering Model-driven engineering (MDE) is an approach to software development where models rather than programs are the principal outputs of the development process. 模型驱动工程(MDE)是一种软件开发方法，在这种方法中，模型而不是程序是开发过程的主要输出。 The programs that execute on a hardware/software platform are then generated automatically from the models. 在硬件/软件平台上执行的程序会从模型中自动生成。 Proponents of MDE argue that this raises the level of abstraction in software engineering so that engineers no longer have to be concerned with programming language details or the specifics of execution platforms. MDE的支持者认为这提高了软件工程的抽象层次，这样工程师就不必再关注编程语言的细节或者执行平台的细节。 Usage of model-driven engineering Model-driven engineering is still at an early stage of development, and it is unclear whether or not it will have a significant effect on software engineering practice. 模型驱动工程仍处于开发的早期阶段，它是否会对软件工程实践产生重大影响还不清楚。 Pros 优点 Allows systems to be considered at higher levels of abstraction 允许在更高的抽象级别考虑系统 Generating code automatically means that it is cheaper to adapt systems to new platforms. 自动生成代码意味着系统适应新平台的成本更低。 Cons 缺点 Models for abstraction and not necessarily right for implementation. 模型用于抽象，但不一定适用于实现。 Savings from generating code may be outweighed by the costs of developing translators for new platforms. 为新平台开发翻译程序的成本可能超过了生成代码所节省的成本。 Types of model A computation independent model (CIM) 一个独立计算的模型 These model the important domain abstractions used in a system. CIMs are sometimes called domain models. 这些模型为系统中使用的重要领域抽象建模。cim有时被称为域模型。 A platform independent model (PIM) 平台无关模型 These model the operation of the system without reference to its implementation. The PIM is usually described using UML models that show the static system structure and how it responds to external and internal events. 这些模型模拟系统的运行，而不参考系统的实现。通常使用UML模型来描述PIM, UML模型显示静态系统结构以及它如何响应外部和内部事件。 Platform specific models (PSM) 平台特定型号 These are transformations of the platform-independent model with a separate PSM for each application platform. In principle, there may be layers of PSM, with each layer adding some platform-specific detail. 这些是平台独立模型的转换，每个应用平台都有一个独立的PSM。原则上，可以有多个PSM层，每一层都添加一些特定于平台的细节。 Agile methods and MDA The developers of MDA claim that it is intended to support an iterative approach to development and so can be used within agile methods. MDA的开发人员声称，MDA旨在支持迭代开发方法，因此可以在敏捷方法中使用。 The notion of extensive up-front modeling contradicts the fundamental ideas in the agile manifesto and I suspect that few agile developers feel comfortable with model- driven engineering. 广泛的预先建模的概念与敏捷宣言中的基本思想相矛盾，我怀疑很少有敏捷开发人员能够适应模型驱动的工程。 If transformations can be completely automated and a complete program generated from a PIM, then, in principle, MDA could be used in an agile development process as no separate coding would be required. 如果转换可以完全自动化，并且可以从PIM生成一个完整的程序，那么原则上，MDA可以在敏捷开发过程中使用，因为不需要单独的编码。 Executable UML The fundamental notion behind model-driven engineering is that completetly automated transformation of models to code should be possible. 模型驱动工程背后的基本概念是，完全自动化的模型到代码的转换应该是可能的。 This is possible using a subset of UML2, called Executable UML or xUML. 使用UML2的子集，称为可执行UML或xUML，这是可能的。 Features of executable UML To create an executable subset of UML, the number of model types has therefore been dramatically reduced to these 3 key types: 为了创建一个UML的可执行子集，模型类型的数量已经戏剧性地减少到以下3种关键类型 Domain models that identify the principal concerns in a system. They are defined using UML class diagrams and include objects, attributes and associations. 识别系统中主要关注点的领域模型。它们是使用UML类图定义的，包括对象、属性和关联。 Class models in which classes are defined, along with their attributes and operations. 定义类及其属性和操作的类模型。 State models in which a state diagram is associated with each class and is used to describe the life cycle of the class. 状态模型，其中状态图与每个类相关联，用于描述类的生命周期。 The dynamic behavior of the system may be specified declaratively using the object constraint language (OCL), or may be expressed using UML’s action language. 系统的动态行为可以使用对象约束语言(OCL)声明地指定，也可以使用UML的动作语言表达。 Key points A model is an abstract view of a system that ignores system details. Complementary system models can be developed to show the system’s context, interactions, structure and behavior. 模型是忽略系统细节的系统抽象视图。可以开发互补系统模型来显示系统的上下文、交互、结构和行为。 Context models show how a system that is being modeled is positioned in an environment with other systems and processes. 上下文模型显示了一个被建模的系统如何与其他系统和流程一起定位在环境中。 Use case diagrams and sequence diagrams are used to describe the interactions between users and systems in the system being designed. Use cases describe interactions between a system and external actors; sequence diagrams add more information to these by showing interactions between system objects. 用例图和序列图用于描述被设计的系统中用户和系统之间的交互。用例描述系统和外部参与者之间的交互;序列图通过显示系统对象之间的交互，为它们添加了更多的信息。 Structural models show the organization and architecture of a system. Class diagrams are used to define the static structure of classes in a system and their associations. 结构模型显示系统的组织和架构。类图用于定义系统中类的静态结构及其关联。 Behavioral models are used to describe the dynamic behavior of an executing system. This behavior can be modeled from the perspective of the data processed by the system, or by the events that stimulate responses from a system. 行为模型用于描述执行系统的动态行为。可以从系统处理的数据的角度，或者从刺激系统响应的事件的角度，对这种行为进行建模。 Activity diagrams may be used to model the processing of data, where each activity represents one process step. 活动图可以用来建模数据的处理，其中每个活动代表一个过程步骤。 State diagrams are used to model a system’s behavior in response to internal or external events. 状态图用于对系统响应内部或外部事件的行为进行建模。 Model-driven engineering is an approach to software development in which a system is represented as a set of models that can be automatically transformed to executable code. 模型驱动工程是一种软件开发方法，在这种方法中，系统被表示为一组可以自动转换为可执行代码的模型。 References XJTLU slides CPT203 Week6 期中加油","link":"/2021/10/21/CPT203-W6/"},{"title":"INT201 W5","text":"还没整明白，内容转自吴雨森的CSDN。INT201 决策，计算，语言 笔记","link":"/2021/10/18/INT201-W5/"},{"title":"CAN201 W5","text":"This is the note of CAN201 Week5.We will focus on Transport Layer.Roadmap Pipelined communication TCP: connection-oriented transport Principles of congestion control Lecturerdt3.0: stop-and-wait operation就是之前我们说的停等机制。3.0同时考虑到封包遗失与资料错误的情形，除了使用ACK机制，另外在传送端多了倒数计时器，封包送出去如果超过时间仍未收到ACK或是收到不正确编号的ACK，则再送出封包一次。 Piplined protocolsPipelining: sender allows multiple, “in-flight”, yet-to-be acknowledged pkts. Range of sequence numbers must be increased 序号的范围必须增加 Buffering at sender and/or receiver 发送端和/或接收端缓冲 Pipelining: increased utilization 管道增加利用率 滑动窗口协议(slide window) 发送缓存区 形式：内存中的一个区域，落入缓存区的分组可以发送 功能：用于存放已发送，但是没有得到确认的分组 必要性：需要重发时可用 发送缓存区大小：一次最多可用发送多少个未经确认的分组 停止等待协议=1 流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100% 发送缓冲区中的分组 未发送的：落入发送缓冲区的分组，可以连续发送出去； 已经发送出去的、等待对方确认的分组：发送缓冲区分组只有得到确认才能删除 发送窗口最大值小于等于发送缓存区的大小发送窗口每发送一个信息，就往前挪一个，一直挪到发送窗口的后沿，不能超过发送缓冲区。数据收到接受信号之后，就离开发送窗口，窗口移动到后面的数据上。接受窗口每次只能接受一个信息，接受完之后才能向后滑动，继续接受。 接受窗口接收窗口 (recieving window)=接受缓存区 接收窗口用于控制哪些分组可以被接收 只有收到的分组序号落入接受窗口才允许接收 若序号在接受窗口之外，则丢弃 接收窗口尺寸Wr=1，则只能顺序接收 (GBN协议) 接收窗口尺寸Wr&gt;1，可以乱序接收 (Selected repeat协议) 但提交给上层的分组，要按序 例子：Wr=1，在0的位置：只有0号分组可以接受：向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃： GBN和SR的相同和不同点GBN严格按照顺序进行窗口的移动，接收方没有缓存区和滑动窗口，所以会产生后面重复的发送。SR是无序的传送，不会出现重复的发送，只会发送出现问题的信息，在接收方建立缓存区和滑动窗口，帮助乱序的信息留下来。 GBN: 接收方拓展的FSM 只发送ACK：对顺序接受的最高序号的分组 可能会产生重复的ACK 只需要记住expectedseqnum: 接收窗口=1 对乱序的分组： 丢弃 （不缓存）接收方没有缓存 对顺序接受的最高序号的分组进行确认 - 累加确认 可能有丢失ack，但是只需要按照最后一个确认就可以了 SR: 选择重传 接收方对每个正确接受的分组，分别发送ACKn（非累计确认） 接受窗口&gt;1 可以缓存乱序的分组 最终讲分组按照顺序交付给上层 发送方只对那些没有收到ACK的分组进行重发-选择性重发：发送方为每个未确认的分组设定一个定时器 发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数 GBN发送窗口最大值是2^n-1，SR发送窗口最大值是2^(n-1) SR会出现一些问题，当窗口的大小不合适的时候：发送方无法确定发送的pkt和自己需要的是否匹配 TCP: connection-oriented transportTCP: overview Point-to-point: 点对点 one sender, one receiver Reliable, in-order byte steam: 可靠的按顺序的字节流 no “message boundaries” 没有报文边界 Pipelined: 有滑动窗口 TCP congestion and flow control set window size TCP拥塞控制和流量控制设置窗口大小 Full duplex data: 全双工数据 既有累加确认，两方也都有缓存区 bi-directional data flow in same connection 同一连接中的双向数据流 Connection-oriented: 会相关联 要握手 handshaking (exchange of control msgs) inits sender, receiver state before data exchange 握手(交换控制msg)在数据交换前初始化发送方、接收方状态 Flow controlled: 流控制 sender will not overwhelm receiver 发送方不会压倒接收方 TCP segment structures段是用于三次握手TCP seq. numbers, ACKsSequence numbers: 序列号 Byte stream “number” of first byte in segment’s data Acknowledgements: 确认号 Seq # of next byte expected from other side Cumulative ACK Q: How receiver handles out-of-order segments 接收器如何处理无序段A: TCP spec doesn’t say, - up to implementor TCP规范没有说，由实现者决定一个序列号和确认号的例子：一共发送了三个报文段。第一个报文段是由客户发给服务器，在他们的数据字段里包含一字节的C的ASCII码。然后第一个报文段的序号字段是42。由于客户还没有接受来自服务器的任何数据，因此该第一个字段的确认号字段就是79。第二个报文段是由服务器发往客户。首先为该服务器所受到的数据提供一个确认。通过在确认号字段中填入43，服务器告诉客户它已经成功接收到了字节42，正在等待43的出现。所以在第二个报文段的数据字段中填入的是C的ASCII码。第二个报文段的序号是79，它是该TCP连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节数据。值得注意的是，对客户到服务器的数据的确认被装载在一个字节的数据。承载服务器到容户的数据的报文段中；这种确认被称为是被捎带（piggybacked）在服务器到客户的数据报文段中的。第三个报文段是从客户发往服务器的。它的唯一目的是确认已从服务器收到的数据。（前面讲过，第二个报文段中包含的数据是字符C，是从服务器到客户的。）该报文段的数据字段为空（即确认信息没有被任何从客户到服务器的数据所捎带）。该报文段的确认号字段填入的是80，因为客户己经收到了字节流中序号为79及以前的字节，它现在正等待着字节80的出现。你可能认为这有点奇怪，即使该报文段里没有数据还仍有序号。这是因为TCP存在序号字段，报文段需要填入某个序号。Host A和Host B是相互发送的。 TCP round trip time, timeout往返时间的估计和超时这里产生的问题就是：如何设置TCP的超时时间？首先，必须要比RTT长，但是不同情况下的RTT差异很大；假如太短就会导致提前超时，造成不必要的重传；假如时间太长就会导致反应太慢而造成segment loss. Q: How to estimate RTT? 如何估计RTT呢？ SampleRTT: measured time from segment transmission until ACK receipt Ignore retransmissions SampleRTT will vary, want estimated RTT “smoother” Average several recent measurements, not just current SampleRTT 公式：EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT (a = 0.125) 如何设置timeout时间：估计RTT加上“安全边际”DevRTT = (1-b)*DevRTT + b*|SampleRTT-EstimatedRTT| (typically, b = 0.25)TimeoutInterval = EstimatedRTT + 4*DevRTT 4*DevRTT=“safety margin” TCP reliable data transfer TCP creates rdt service on top of IP’s unreliable service pipelined segments cumulative acks 累积ack single retransmission timer 单重传定时器 Retransmissions triggered by: 触发重传的事件 timeout events 超时事件 duplicate acks 复制ack TCP sender eventsData rcvd from app: Create segment with seq# 创建段与seq# seq# is byte-stream number of first data byte in segment seq#是段中第一个数据字节的字节流号 Start timer if not already running 开启计时器 Timeout: Retransmit segment that caused timeout 重发segment导致超时 Restart timer 重新启动计时器 Ack rcvd: If ack acknowledges previously unacked segments 如果ack确认先前未打包的段 Update what is known to be ACKed 更新已知被ack的内容 Start timer if there are still unacked segments 如果仍然有未打包的段开始定时器 TCP sender 这段自己看ppt，最重要的内容是TCP的三次握手和四次挥手。 Principles of congestion control看b站 笔记要抄的太多了 b站写的很详细。中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程 References XJTLU slides CAN201 中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程 计算机网络 自顶向下方法.原书第6版","link":"/2021/10/16/CAN201-W5/"},{"title":"CPT203 W5","text":"This is the note of CPT203 W5.This week is mainly about Human Aspect and SE Principles.其实感觉这周主要说的是如何处理团队中的人际关系问题。和如何提高团队的运作效率。 LectureCHARACTERISTICS OF A SOFTWARE ENGINEER Master the technical stuff, learn and apply the skills required to understand the problem, design an effective solution, build the software, and test it to develop the highest quality possible. Manage change, communicate with stakeholders, and use appropriate tools in the appropriate situations 掌握技术知识，学习和应用所需的技能，以理解问题，设计有效的解决方案，构建软件，并测试它，以开发最高质量。管理变更，与涉众沟通，并在适当的情况下使用适当的工具 But there are other things that are equally important. Erdogmus [Erd09] identifies seven traits that are present when an individual software engineer exhibits “superprofessional” behavior. 但还有其他同样重要的事情。Erdogmus指出了当一个软件工程师表现出“超级专业”的行为时，会出现七种特征。 SEVEN TRAITS OF EFFECTIVE SOFTWARE ENGINEER sense of individual responsibility 个人责任感 has an acute awareness of the needs of others 对他人的需要有敏锐的意识 honest and brave to face the truth 诚实而勇敢地面对真理 exhibits resilience under pressure 在压力下表现出弹性 has a heightened sense of fairness 有高度的公平感 exhibits attention to detail 表现出对细节的关注 pragmatic 务实 THE PSYCHOLOGY OF SOFTWARE ENGINEERING teams often establish artificial boundaries that reduce communication and, as a consequence, reduce the team effectiveness. 团队经常人为设定界限，减少沟通，结果降低了团队的效率。 a set of “boundaries spanning roles” that allow members of a software team to effectively move across team boundaries and hence improve team effectiveness 一套“跨越角色的边界”，允许软件团队成员有效地跨越团队边界，从而提高团队效率 (Ambassador, Scout, Guard, Sentry, Coordinator) THE SOFTWARE TEAM We tend to use the word team fairly loosely in the business world, calling any group of people assigned to work together a “team.” But many of these groups just don’t seem like teams. They don’t have a common definition of success or any identifiable team spirit. What is missing is a phenomenon that we call jell. - Tom DeMarco and Tim Lister [DeM98] A jelled team is a group of people so strongly knit that the whole is greater than the sum of the parts . . . Once a team begins to jell, the probability of success goes way up. The team can become unstoppable, a juggernaut for success . . . They don’t need to be managed in the traditional way, and they certainly don’t need to be motivated. They’ve got momentum. - Tom DeMarco and Tim Lister [DeM98] 一个凝聚的团队是一群紧密结合在一起的人，整体大于部分的总和 THE JELLED TEAM estabilsh a sense of purpose 建立目标感 inclucate a sense of involvement that allows every member to feel that his skillset and contributions are valued 融入一种参与感，让每个成员都感到自己的技能和贡献是有价值的 foster a sense of trust 培养信任感 encourge a sense of improvement 鼓励一种改进的感觉 diverse in the sense they combine a variety of different skill sets 多样化的意思是他们结合了各种不同的技能 PRINCIPLES THAT GUIDE SOFTWARE PROCESS The software process provides software engineer a road map for getting to a successful destination 软件过程为软件工程师提供了通往成功目的地的路线图 The following core principles can be applied to software process 以下核心原则可以应用到软件过程中 PRINCIPLES THAT GUIDE PRACTICE We said that software process provides software engineer a road map for getting to a successful destination. Practice provides software engineer with the detail you’ll need to drive along the road. 软件过程为软件工程师提供了通往成功目的地的路线图。实践为软件工程师提供了沿着道路行驶时需要的细节。 Software engineering practice has a single overriding goal—to deliver on-time, high-quality, operational software that contains functions and features that meet the needs of all stakeholders. To achieve this goal, you should adopt a set of core principles that guide your technical work. 软件工程实践有一个最重要的目标——交付准时、高质量、可操作的软件，其中包含满足所有涉众需求的功能和特性。为了实现这个目标，您应该采用一组指导技术工作的核心原则。 The following set of core principles are fundamental to the practice of software engineering. 下面的一组核心原则是软件工程实践的基础。 Divide and conquer 分而治之 Understand the use of abstraction 理解抽象的使用 Strive for consistency 努力保持一致性 Focus on the transfer of information 关注信息的传递 Build software that exhibits effective modularity 构建具有有效模块化的软件 Look for patterns 寻找模式 When possible, represent the problem and its solution from a number of different perspectives 如果可能，从多个不同的角度阐述问题及其解决方案 Remember that someone will maintain the software 会有人维护软件 在客户需求被分析和建模之前，需要通过沟通的渠道收集这些信息。 Listen 听 Prepare before you communicate 沟通前做好准备 Someone should facilitate the activity 应该有人来协助这项活动 Face-to-face communication is best 面对面的交流是最好的 Take notes and document decisions 做笔记，记录决定 Strive for collaboration 争取合作 Stay focus; modularizes your discussion 保持注意力;模块化讨论 Use drawing whenever something is unclear 如果有不清楚的地方，就画出来 Move on 不要停留太长时间在无意义的东西上 Negotiation is not a contest or a game. It works best when both parties win 谈判不是一场竞赛。当双方都赢的时候效果最好 计划活动包括一组管理和技术实践，使软件团队能够在实现其战略目标和战术目标的过程中定义路线图。 Understand the scope of the project 了解项目的范围 Involve stakeholders in the planning activity 让利益相关者参与规划活动 Recognize that planning is iterative 认识到计划是迭代的 Estimate based on what you know 基于你所知道的进行估计 Consider risk as you define your plan 在定义计划时考虑风险 Be realistic 认清现实 Adjust garnularity as you define the plan 在定义计划时调整粒度 Define how you intend to ensure quality 确定你打算如何确保质量 Describle how you intend to accommodate change 描述你打算如何适应变化 Track the plan frequently and adjust as required. 经常跟踪计划，并根据需要进行调整。 References XJTLU CPT203 Week5 slides","link":"/2021/10/14/CPT203-W5/"},{"title":"CPT205 W5","text":"This is the note of CPT205 Week5. This week is mainly about Viewing and Projection. Concepts of viewing and projections Types and advantages/disadvantages of projection 3D viewing co-ordinate parameters Orthogonal projection Frustum perspective projection OpenGL functions Sample code LectureClassic viewing Viewing requires three basic elements One or more objects A viewer with a projection surface 带有投影表面的视图 Projectors that go from the object(s) to the projection surface 从物体到投影表面的投影仪 Classical views are based on the relationship among these elements 经典的观点是基于这些元素之间的关系 The viewer picks up the object and orients the object in a way that it is to be seen. 观察者拿起对象，并以一种可以被看到的方式对对象进行定位。 Each object is constructed from flat principal faces 每个对象都是由平面主面构成的 Buildings, polyhedra, manufactured objects, etc. 建筑物、多面体、人造物体等。 Classic projection Planar geometric projection 平面几何投影 Standard projections project onto a plane. 标准投影投影到一个平面上。 Projectors are lines that either converge at a centre of projection or are parallel. 投影线是在投影中心相交或平行的线。 Such projections preserve lines but not necessarily angles. 这样的投影保留了直线，但不一定保留了角度。 Non-planar projections are needed for applications such as map construction. 地图制作等应用需要非平面投影。 Taxonomy of planar geometric projection Perspective vs parallel Computer graphics treats all projections in the same way and implements them with a single pipeline. 计算机图形以相同的方式处理所有投影，并使用单个管道实现它们。 Classical viewing has developed different techniques for drawing each type of projection. 古典观影已经发展了不同的技术来绘制每种类型的投影。 The fundamental distinction is between parallel and perspective viewing even though mathematically parallel viewing is the limit of perspective viewing. 基本的区别是平行观和透视观之间的区别，尽管数学上的平行观是透视观的极限。 说个简单的自己的理解：perspective就是肉眼看到的比较近距离的透视，所以会产生远景看起来比较小的情况；而parallel则是远距离看起来的情况，所以就会像正视图之类的一样看不到阴影。 Perspective projection Perspective projection generates a view of 3- dimensional scene by projecting points to the view plane along converging paths, causing the objects farther from the viewing position to be displayed smaller than the objects of the same size that are nearer to the viewing position. 透视投影通过沿着汇聚路径将点投影到视场平面上，使距离观看位置较远的物体比距离观看位置较近的相同大小的物体更小，从而生成三维场景的视图。 A scene generated using perspective projection appears more realistic since this is the way that human eyes and cameras form images. 使用透视投影生成的场景看起来更真实，因为这是人眼和相机形成图像的方式。 Parallel projection This method projects points on the object surface along parallel lines. 这种方法沿着平行线将点投射到物体表面上。 It is usually used in engineering and architecture drawings to represent an object with a set of views showing accurate dimensions. 它通常用于工程和建筑图纸，以一组显示精确尺寸的视图来代表一个物体。 Multiview Orthographic projectionThe projectors are orthogonal to projection surface. 投影仪正交于投影曲面。 The projection plane is parallel to the principal face. 投影面与主面平行。 Usually form front, top and side views. 通常形成正面，顶部和侧面视图。 Advantages and disadvantages Preserves both distances and angles 保持距离和角度 Shapes preserved 形状保存 Can be used for measurements 可用于测量 Building plans Manuals Cannot see what object really looks like because many surfaces are hidden from the view 无法看到物体的真实样子，因为许多表面被隐藏在视图中 Often the isometric view is added Axonometric projectionsAllow projection plane to move relative to the object.所以要注意观察到底能看到几个角度，这是三种axonometric projections的区别Advantages and disadvantages Lines are scaled (foreshortened) but can find scaling factors 线是缩放的，但可以找到缩放因子 Lines preserved but angles are not 保留线，但不保留角度 Projection of a circle in a plane not parallel to the projection plane is an ellipse 圆在不平行于投影平面的平面上的投影是椭圆 Can see three principal faces of a box-like object 能看到一个盒状物体的三个主要面 Some optical illusions possible 可能存在一些视错觉 Parallel lines appear to diverge 平行线似乎分开了 Does not look real because far objects are scaled the same as near objects 看起来不真实，因为远的对象缩放与近的对象相同 Used in CAD applications 用于CAD应用 Oblique projection投影仪与投影平面之间的任意关系。Advantages and disadvantages Can pick the angles to emphasise a particular face 可以选择角度来强调一个特定的脸 Architecture: plan oblique, elevation oblique Angles in faces parallel to the projection plane are preserved while we can still see “around” side. 与投影平面平行的面的角度被保留，而我们仍然可以看到“周围”的一面。 In the physical world, we cannot create oblique projections with a simple camera; possible with bellows camera or special lens (architectural) 在物理世界中，我们不能用一个简单的相机创建斜投影;可配波纹管相机或特殊镜头 Perspective projection投影仪会聚于投影中心。 Vanishing points Parallel lines (not parallel to the projection plane) on the object converge at a single point in the projection (the vanishing point).物体上的平行线(不平行于投影平面)收敛于投影中的一个点(灭点)。 Drawing simple perspectives by hand uses the vanishing point(s). 手动绘制简单的透视图使用消失点。 Three-point perspective No principal face parallel to the projection plane 没有平行于投影平面的主面 Three vanishing points for the cube 立方体的三个消失点 Two-point perspective One principal direction parallel to the projection plane 有一个平行于投影平面的主面 Two vanishing points for the cube 立方体两个消失点 One-point perspective One principal face parallel to the projection plane 有一个平行于投影平面的主面 One vanishing point for the cube 立方体一个消失点 Advantages and disadvantages Objects further from the viewer are projected smaller than the same sized objects closer to the viewer (diminution) 距离观察者更远的物体被投射得比距离观察者更近的相同大小的物体更小(缩小) Equal distances along a line are not projected into equal distances (non-uniform foreshortening). 沿直线等距离的投影不等于等距离(非均匀透视缩短)。 Angles preserved only in planes parallel to the projection plane. 仅在与投影平面平行的平面上保留的角。 More difficult to construct by hand than parallel projections (but not more difficult by computer). 手工构造比平行投影更困难(但用计算机构造并不困难)。 Computer viewing and projectionThere are three aspects of viewing process, all of which are implemented in the pipeline: Positioning the camera: Setting the model-view matrix Selecting a lens: Setting the projection matrix Clipping: setting the view volume 3D viewing co-ordinate parameters Orthogonal projection 正交投影 Orthogonal (or paralell) projection is a transformation of object descriptions to a view plane along lines parallel to the view-plane normal vector N. 正交(或平行)投影是将对象描述沿平行于视图平面法向量N的线转换到视图平面的一种方法。 It is often used to produce the front, side and top views of an object. 它通常用于生成对象的正面、侧面和顶部视图。 Engineering and architectural drawings commonly employ these orthographic projections since the lengths and angles are accurately depicted and can be measured from the drawings. 它通常用于生成对象的正面、侧面和顶部视图。 从一个正交投影体到参考系内的系统标准化立方体的标准化变换 Frustum perspective projection By adding near and far clipping planes that are parallel to the viewing plane, parts of the infinite perspective view volume are chopped off to form a truncated pyramid or frustum. These clipping planes can be optional for some systems. 通过添加与观察平面平行的近和远剪切平面，无限透视视图体的部分被切掉，形成一个截短的金字塔或截锥。对于某些系统来说，这些裁剪平面是可选的。 The near and far clipping planes can be used simply to enclose objects to be displayed. The near clipping plane can be used to take out large objects close to the viewing plane, which could be projected into unrecognisable shapes in the clipping window. Likewise, the far clipping plane can cut out objects that may be projected to small blots. 近和远剪切面可以用来简单地包围要显示的对象。近剪切面可以用来剔除靠近观察面的大物体，这些物体可以在剪切窗口中投影成无法识别的形状。同样，远剪切平面可以切割出物体，这些物体可能被投影到小的斑点上。 Some systems restrict the placement of the viewing plane relative to the near and far planes, and other systems allow it to be placed anywhere except at the position of the viewing origin (view point, viewing position, eye position or camera position). If the viewing plane is behind the projection reference point, objects are inverted on the view plane. 一些系统限制观察平面相对于近平面和远平面的位置，而其他系统允许它放置在任何位置，除了观察原点的位置(视点，观察位置，眼睛位置或相机位置)。 If the viewing plane is behind the objects, the objects are simply enlarged as they are projected away. 如果观察平面在投影参考点之后，物体在观察平面上被倒置。 When the projection reference point is very far away from the view plane, a perspective projection approaches to a parallel projection. 当投影参考点离视盘非常远时，透视投影接近平行投影。 simple perspective projection Centre of projection at the origin Projection plane z = d, d &lt; 0 OpenGL functionsgluLookAt(eye_position, look_at, look_up)Specify three-dimensional viewing parameters. glOrtho(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far)Specify parameters for a clipping window and the near and far clipping planes for an orthogonal projection. 为裁剪窗口和正交投影的近、远裁剪平面指定参数。 gluPerspective(GLfloat fov, GLfloat aspect, GLfloat near, GLfloat far)Specify field-of-view angle (fov which is a matrix) in the y- direction, the aspect ratio of near and far planes; It is less often used than glFrustum(). 指定y方向的视场角度(fov为矩阵)，即近平面和远平面的纵横比;它的使用频率低于glFrustum()。 References XJTLU CPT205 week5 slides","link":"/2021/10/12/CPT205-W5/"},{"title":"INT201 W4","text":"This’s the note of INT201 Week4.This week will focus on 正则语言的性质. Lecture Two characterisations of regular languagesA “regular language” means a language that can be defined using a regular expression. “正则语言”是指可以使用正则表达式定义的语言。Kleene’s theoremRegular languages are those languages that can be accepted by finite automata. 正则语言是可以被有限自动机接受的语言。任何NFA都有一个等价的DFA。因此，当我们讨论有限自动机可以接受的语言时，我们不需要指定我们讨论的是DFA还是NFA。我们通过展示如何从NFA转换成正则表达式，反之亦然来证明Kleene's theorem。 如何将正则表达式改编成NFARecall how r.e’s are defined. To show that any r.e. has an equivalent NFA: Construct a NFA that accepts any single one-letter word Given two NFAs, construct a new one that accepts the concatenation of their languages Given two NFAs, construct a new one that accepts the union of their languages Given any single NFA, construct a new one that accepts the closure of its language 编译原理正规表达式转NFA到DFA再化简 Cliam 1Let L1 and L2 be languages over an alphabet A. If there are finite automata accepting L1 and L2 then there is a finite automaton accepting L1L2. 假设L1和L2是A之上的语言，如果有有限自动机接受L1和L2，那么也有一个有限自动机接受L1L2。Proof: Claim 2Let L1 and L2 be languages over an alphabet A. If there are finite automata accepting L1 and L2 then there is a finite automaton accepting L1 ∪ L2. 假设L1和L2是字母表a上的语言，如果有接受L1和L2的有限自动机，那么就有接受L1∪L2的有限自动机。Example:Proof: The 2 constructions so far give a general way of constructing a finite automaton that accepts any finite language. A word in a finite language is built from a sequence of concatenations The language is built from a sequence of unions of sets of words.到目前为止，这两种构造给出了构造接受任何有限语言的有限自动机的一般方法。有限语言中的一个词是由一系列的连接词组成的。 Claim 3If language L is accepted by some finite automaton, then so is language L*. 如果语言L被某些有限自动机接受，那么语言L*也被接受。Proof: References XJTLU INT201 Week4 slides","link":"/2021/10/09/INT201-W4/"},{"title":"CAN201 W4","text":"This’s the note of introduction to networking Week4.This week we will talk about the transport layer in networking system. 传输层 Roadmap Transport-layer services Multiplexing and demultiplexing Connectionless transport: UDP Principles of reliable data transfer LectureTransport-layer servicesTransport services and protocols Provide logical communication between app processes running on different hosts 端与端之间 Transport protocols run in end systems 在这里我们可以发现，之前讲的五层模型只出现于端处，在路由上只有三层，没有五层。 Send side: breaks app msg into segments, passes to network layer 发送端:将应用程序消息分成段，传递到网络层 Rcv side: reassembles segments into messages Rcv端:将段重组为消息 Transport-layer protocols for Internet: TCP and UDP Network layer: logical communication between hosts 网络层:主机之间的逻辑通信。 Transport layer: logical communication between processes: Relies on, enhances, network layer services. 传输层:进程之间的逻辑通信:依赖、增强网络层服务。 假如把信息的传递表示称Ann家12个孩子和Bill家12个孩子的通信，那么Transport protocol就是Ann和Bill家负责收集和分发12封信的服务，而Network-layer protocol则是家庭与家庭之间的邮政服务。 Internet transport-layer protocols Reliable, in-order delivery (TCP) 可靠，有序交付 Congestion control 拥塞控制 Flow control 流量控制 Connection setup 建立连接 Unreliable, unordered delivery: UDP 不可靠，无序交付 多路复用解复用 No-frills extension of “best-effort” IP “尽最大努力”IP的无虚饰扩展 Services not available: 服务不可用 TCP和UDP都不可以 Delay guarantees 延迟保证 Bandwidth guarantees 带宽保证 Multiplexing and demultiplexing 多路复用和多路分用发送端：Multiplexing从多个socket接收消息，然后打包成一个segment发送出去。接收端：通过发送端封装上的头部信息把消息分发到每一个socket上。How demultiplexing works Host receives IP datagrams 主机接收IP数据报 Each datagram has source IP address, destination IP address 每个数据报都有源IP地址、目的IP地址 Each datagram carries one transport-layer segment 每个数据报携带一个传输层段 Each segment has source, destination port number 每个段都有源端口号、目的端口号 Host uses IP addresses &amp; port numbers to direct segment to suitable socket 主机使用IP地址和端口号直接段到合适的套接字 Connectionless demultiplexing (UDP)因为UDP是没有连接的，所以只要IP datagram里的目标IP地址和端口号是一样的，都会送到相同的socket中，不管这个datagram是否来自于同一个进程。 Connection-oriented demuxsocket被分开了，UDP里只要接受的IP和port不变，就用一个socket接受。但是TCP只要发送的IP和port不一样，即使接受的IP和port一样，也会重新开port。threaded server: 线程多进程 Connectionless transport: UDPUDP: User Datagram ProtocolFeature: Simple and straightforward Best effort Lost Connectionless No handshaking Each UDP segment handled independently of others: Out-of-order to APP UDP use: Streaming multimedia apps DNS Reliable transfer over UDP: Add reliability at application layer 应用层解决 Application-specific error recovery 错误恢复手段 UDP: segment header UDP checksumGoal: detect “errors” in transmitted segment 检测传输段中的“错误”Sender: Treat segment contents, including header fields, as sequence of 16-bit integers 将段内容(包括报头字段)作为16位整数序列处理 Checksum: addition (one’s complement sum) of segment contents 校验和:段内容的添加(一个的补和) 负责检查传输有没有出错 Sender puts checksum value into UDP checksum field 发送端将校验和值放入UDP校验和字段 Receiver: Compute checksum of received segment 计算接收报文段的校验和 Check if computed checksum equals checksum field value: 检查计算的checksum是否等于checksum字段值: NO - error detected YES - no error detected. But maybe errors nonetheless? 在信息发送过来的时候会携带一个checksum，然后接收到之后拿16bits相加，多出来的第一位加到结尾。得出一个sum，然后在根据sum全部翻转过来，得到checksum。最后对比算出来的checksum和发送过来的checksum，假如一样说明没有问题，假如不一样就说明接受或发送出现了问题。 Principles of reliable data transfer可靠数据传输的原理，参见书和ppt。rdt1.0, rdt2.0, rdt2.1, rdt3.0rdt 2.0是面对比特错误是使用的方法。假如收到的消息没有问题就发送ACK，有问题就发送NAK，然后发送者接收到返回的消息再继续进行下一阶段的发送，所以只需要两个状态就可以解决问题。rdt2.0 has a fatal flaw!What happens if ACK/NAK corrupted? 如果ACK/NAK损坏会发生什么 Sender doesn’t know what happened at receiver! 发送方不知道接收方发生了什么 Can’t just retransmit: possible duplicate 不能只是重传:可能重复 Handling duplicates: Sender retransmits current pkt if ACK/NAK corrupted Sender adds sequence number to each pkt Receiver discards (doesn’t deliver up) duplicate pkt 所以就多加了两个状态变成rdt2.1 在rdt2.2中去掉了NAK，只用ACK，假如checksum出现问题就反复回府之前的申请，直到可以进入下一个状态再继续。 rdt 3.0继续解决了丢包的情况：通过加上time设置。利用率低，因为是停等协议。 Lab1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# clientimport jsonfrom socket import *import argparsedef _argparse(): parser = argparse.ArgumentParser(description=&quot;This is description!&quot;) parser.add_argument('--ip', action='store', required=True, dest='ip', help='IP address') parser.add_argument('--input', type=str, required=True, dest='input', help='The path of input file') parser.add_argument('--port', type=int, required=True, dest='port', help='The port of server') return parser.parse_args()def main(): parser = _argparse() server_name = parser.ip server_port = parser.port clientSocket = socket(AF_INET, SOCK_STREAM) clientSocket.connect((server_name, server_port)) clientSocket.send(parser.input.encode()) feedback_command = clientSocket.recv(20480).decode() feedback = json.loads(feedback_command) print(feedback) clientSocket.close()if __name__ == '__main__': main()# serverimport jsonfrom socket import *import argparsedef _argparse(): parser = argparse.ArgumentParser(description=&quot;This is description!&quot;) parser.add_argument('--ip', action='store', required=True, dest='ip', help='IP address') parser.add_argument('--input', type=str, required=True, dest='input', help='The path of input file') parser.add_argument('--port', type=int, required=True, dest='port', help='The port of server') return parser.parse_args()def main(): parser = _argparse() server_port = parser.port server_socket = socket(AF_INET, SOCK_STREAM) server_socket.bind(('', server_port)) server_socket.listen(2) print('The server is ready to receive') while True: connectionSocket, addr = server_socket.accept() receive_command = connectionSocket.recv(20480).decode() receive_message = json.loads(receive_command) print(receive_message) print(type(receive_message)) connectionSocket.send(parser.input.encode()) connectionSocket.close()if __name__ == '__main__': main()","link":"/2021/10/02/CAN201-W4/"},{"title":"CPT203 W4","text":"The objectives of this week: understand the concepts of user and system requirements and why these requirements should be written in different ways; understand the differences between functional and nonfunctional software requirements; understand how requirements may be organized in a software requirements document; understand the principal requirements engineering activities of elicitation, analysis and validation, and the relationships between these activities; LectureSOFTWARE PROCESS Software Specification (This is what we mainly discussed about.) Software Design and Implementation Software Validation Software Evolution BACKGROUND The requirements for a system are the descriptions of what the system should do reflect the needs of customers for a system 系统的需求是对系统应该做什么的描述，反映了客户对系统的需求 The process of finding out, analyzing, documenting and checking these needs and constraints is called requirements engineering (RE) 发现、分析、记录和检查这些需求和约束的过程称为需求工程 The requirements can be described in a high-level, abstract statement of a service that a system should provide or a constraint on a system. At the other extreme, it is a detailed, formal definition of a system function. 需求可以在系统应该提供的服务或系统约束的高级抽象声明中描述。在另一个极端，它是详细的、正式的系统功能定义。 USER REQUIREMENTS AND SYSTEM REQUIREMENTS High-level description or detail description? 高级描述还是详细描述? As part of a contract for a large software development project, it must define its needs in a sufficiently abstract way 作为大型软件开发项目合同的一部分，它必须以一种足够抽象的方式定义其需求 Once a contract has been awarded, the contractor must write a system definition for the client in more detail so that the client understands and can validate what the software will do 一旦合同被授予，承包商必须为客户编写更详细的系统定义，以便客户理解并能够验证软件将做什么 Different level of details serve different purpose. User requirements and system requirements 不同层次的细节服务于不同的目的。用户需求和系统需求 User requirements - Statements in a natural language plus diagrams to describe the services and constraint of a system 用户需求:用自然语言加上图表来描述系统的服务和约束 System requirements - more detailed descriptions of the software system’s functions, services, and operational constraint 系统需求:对软件系统功能、服务和操作约束的更详细的描述 Requirements should state what the system should do and the design should describe how it does this. 需求应该说明系统应该做什么，设计应该描述它是如何做的。 User Requirements: Client Managers System End-Users Client Engineers Contractor Managers System Architects System Requirements: System End-Users Client Engineers System Architects Software Developers FUNCTIONAL &amp; NON-FUNCTIONAL REQUIREMENTS Software system requirements are often classified as functional requirements or nonfunctional requirements: 功能性需求和非功能性需求都是Software system requirements，功能性需求都是程序运行的最基本需求，非功能性是锦上添花的，例如搜索，软件运行速度之类的需求。 Functional requirements: These are statements of services the system should provide. How the services should react and behave in certain condition. In some cases, the functional requirements may also explicitly state what the system should not do. 功能需求这些是系统应该提供的服务声明。服务在特定条件下应该如何反应和行为。在某些情况下，功能需求还可能明确说明系统不应该做什么。 Non-functional requirements: These are constraints on the services or functions offered by the system. Non-functional requirements often apply to the system as a whole, rather than individual system features or services. 非功能需求这些是对系统提供的服务或功能的约束。非功能性需求通常作为一个整体应用于系统，而不是单独的系统特性或服务。但假如non functional requirement假如没有实现也可能会带来多个functional requirement的没有实现，最后导致系统无法正常使用。 The distinction between different types of requirement is not as clear-cut as these simple definitions suggest. 不同类型的需求之间的区别并不像这些简单定义所暗示的那样明确。 我觉得这样翻译ppt没有什么作用，主要的还是自己去看和理解吧。。。要是有空我再把这部分补上。 说一说use case diagram的事。在use case图中，中间的矩形代表的是app部分。左右两边的小人代表的是这个程序的使用者，而中间的圆形则代表的了程序中发生的事件。箭头的指向则代表了人物参加app中的此项活动进行。然而由于一个app中会有不同的事件发生。事件的关系一般有四种： association include extend generalization 假如A事件发生之后B事件一定会发生(属于A事件的子事件)，这种情况我们用虚线箭头从父事件连接子事件，并加上include，假如B事件发生之后A事件可能会发生，也可能不发生，我们用箭头从extend use case连接到base use case上，虚线上写上extend。Extend points是主要事件的细节解释。教你怎么画用例图（use case diagram） 找Actors：who use the systemwho maintain systemwho start &amp; stop system谁提供信息给sys什么外部系统和本系统相关联在用例图中，每个小圈圈就是一个事件。我们需要让use case diagram中的事件越简单越好，细节都是写在use case scenario description里面。 References XJTLU CPT203 slides (Week4) 教你怎么画用例图（use case diagram）","link":"/2021/09/29/CPT203-W4/"},{"title":"CPT205 W4","text":"This is the note of CPT205 Week5 Transformation Pipeline and Geometric Transformations 转换管道和几何转换 Transformation pipeline 转换管道 Standard transformations Translation 翻译 Rotation 旋转 Scaling 扩展 Reflection 反射 Shearing 剪切 Homogeneous co-ordinate transformation matrices 齐次坐标变换矩阵 Composite (arbitrary) transformation matrices from simple transformations 复合(任意)变换矩阵由简单变换 OpenGL functions for transformations 转换的OpenGL函数 LectureTransformation pipeline 转换管道 The Transformation Pipeline is the series of transformations (alterations) that must be applied to an object before it can be properly displayed on the screen. 转换管道是一系列转换(更改)，在对象可以正确地显示在屏幕上之前，必须对其应用。 The transformations can be thought of as a set of processing stages. If a stage is omitted, very often the object will not look correct. For example if the projection stage is skipped then the object will not appear to have any depth to it. 可以将转换视为一组处理阶段。如果省略了stage，对象通常看起来就不正确。 Once an object has passed through the pipeline it is ready to be displayed as either a wire-frame item or as a solid item. 一旦对象通过了管道，就可以将其显示为线框项目或实体项目。 Modelling Transformation - to place an object into the Virtual World. 建模转换：将一个对象放入虚拟世界。 Viewing Transformation - to view the object from a different vantage point in the virtual world. 观察变换-从虚拟世界的不同角度观察物体。 Projection Transformation - to see depth in the object. 投影变换-看到物体的深度。 Viewport Transformation - to temporarily map the volume defined by the “window of interest” plus the front and rear clipping planes into a unit cube. When this is the case, certain other operations are easier to perform. 视口变换-临时映射由“感兴趣的窗口”定义的体积，加上前面和后面的裁剪平面到一个单元立方体。在这种情况下，某些其他操作更容易执行。 Device Transformation - to map the user defined “window of interest” (in the virtual world) to the dimensions of the display area. 设备转换-将用户定义的“感兴趣的窗口”(在虚拟世界中)映射到显示区域的尺寸。 Purpose: 当对象从文件加载并准备好被处理时启动。当对象准备好要显示在计算机屏幕上时，我们就完成了。能够画出一个简单物体的图像，比如一个长方体，并直观地显示当它通过每个管道阶段时发生了什么。 Types of geometric transformation 2D translation向量形式 Translating a point from P(x, y) to P’(x’, y’) along vector T Importance in computer graphics – we need to only transform the two endpoints of a line segment and let the implementation draw the line segment between the transformed endpoints 矩阵形式where P(x, y) and P’(x’, y’) are the original and new positions, and T is the distance translated.吐槽：矩阵不就nm是向量吗？向量不就nm是矩阵吗？ 2D rotationRotating a point from P(x, y) to P’(x’, y’) about the origin by angle θ - radius stays the same, and angle increases by θ. 将一个点从P(x, y)旋转到P'(x', y')，绕原点旋转角度θ -半径不变，角度增加θ。where θ is the rotation angle and φ is the angle between the x-axis and the line from the origin to (x,y). θ是旋转角度，φ是x轴和向(x,y)的向量的角度。 Rotation about a fixed point rather than the origin. 绕不动点而不是原点旋转。 Move the fixed point to the origin 把不动点移到原点的位置 Rotate the object 选择对象 Move the fixed point back to its initial position 将固定点移回初始位置 M = T(pf) R(θ) T(-pf) 2D scalingWhen an object is scaled, both the size and location change. 就是把横坐标和纵坐标扩大相应的倍数。where P, and P’ are the original and new positions, and sx and sy (是x和y的变化比例) are the scaling factors along the x- and y-axes. 2D reflectionSpecial case of scaling - corresponding to negative scale factors. 2D shearingEquivalent to pulling faces in opposite directions. 相当于向相反的方向拉长面。假设simple shearing是沿着x轴的: 2D homogeneous co-ordinates在2D的平面上，平移是矩阵相加，旋转和缩放时矩阵相乘，因为这样太多麻烦，所以设计出了homogeneous coordinates，而它的目的只是为了更加方便地去用矩阵来计算图形的变换。那什么是齐次坐标呢？其实就是在原来2D的维度，再加上一个新的维度，多出来的维度的值永远是1 2D composite transformationwhere elements rs are the multiplicative rotation-scaling terms in the transformation (which involve only rotation angles and scaling factors); elements trs are the translation terms, containing combination of translation distances, pivot-point and fixed- point co-ordinates, rotation angles and scaling parameters. 式中元素rs为变换中的乘性旋转缩放项(只涉及旋转角度和缩放因子); 元素TRS是平移术语，包含平移距离、轴心点和定点坐标、旋转角度和缩放参数的组合。 3D translation3D translations and scaling can be simply extended from the corresponding 2D methods. 3D co-ordinate axis rotations从2D旋转方法扩展到3D旋转不那么简单(因为这是关于任意轴而不是任意点)。等价于在二维平面上以常数z(即绕原点)旋转。 General rotation about the originq绕任意轴的旋转可以分解为绕x、y和z轴的串联旋转。R(q) = Rz(qz) Ry(qy) Rx(qx)其中qx qy qz是欧拉角。旋转不能互换，尽管我们可以使用另一种顺序但不同角度的旋转。 3D scaling 3D composite transformation As with 2D transformation, a composite 3D transformation can be formed by multiplying the matrix representations for the individual operations in the transformation sequence. 与2D变换一样，通过将变换序列中各个操作的矩阵表示相乘，可以形成一个复合的3D变换。 There are other forms of transformation, namely reflection and shearing which can be implemented with the other three transformations. 还有其他形式的转换，即反射和剪切，可以与其他三种转换一起实现。 Translation, scaling, rotation, reflection and shearing are all affine transformations in that transformed point P’(x’,y’,z’) is a linear combination of the original point P(x,y,z). 平移，缩放，旋转，反射和剪切都是仿射变换，变换点P’(x’，y’，z’)是原始点P(x,y,z)的线性组合。 矩阵乘法没有交换律，但是有结合律。在建模中，我们通常从一个简单的物体开始，该物体以原点为中心，以一个轴为方向，并且具有标准尺寸。 OpenGL matrices见学校课件 Lab有空更新 Reference XJTLU slides CPT205 (Week4) 2D平面中关于矩阵（Matrix）跟图形变换的讲解","link":"/2021/09/28/CPT205-W4/"},{"title":"INT201 W3","text":"It’s the note of week3. (INT201 W3) LectureRegular expressions 正则表达式A regular expression (r.e.) is a way of describing a language. It can consist of a finite set of words {cat, dog, mouse, ε} which represents the 4 words that are listed. 正则表达式是描述语言的一种方式，它可以由一组有限的单词组成。 Then, there are 3 operators that can appear in r.e’s: they are 有3个操作符可以出现在re中 Union Concatenation Closure these operators allow you to glue together subexpressions to form larger expression. 这些操作符允许您将子表达式粘在一起，形成更大的表达式。 Union and ConcatenationUnion: Any r.e. represnets a set of words (its language) and we may use ∪ to connect 2 subexpressions into a larger regular expression {cat, dog, mouse, ε} ∪ {cat, cats} which represents the 5 words ε, cat, cats, dog, mouse. 就是一般的并集。 Concatenation: By joining two r.e’s together, we denote the set of words you can make by taking a word from the first r.e. and concatenating it to some word from the second r.e.,{over, under}{cooked, state, rate} denotes the words overcooked, undercooked, overstate, understate, overrate, underrate. 就是把两边的单词合并的集合。有先后次序的区别，**+就是union，乘号就是concatenation**。 Closure: If we take a regular expression and add the superscript *, we get a new r.e. that represents the set of all words you can make by taking any sequence of words from the original r.e. and concatenating them together. ({cat })∗ denotes the words ε, cat, catcat, catcatcat, catcatcatcat, ...Notice that using closure, you can define an infinite language! 注意，使用闭包，您可以定义无限语言! Common extensions to the notation 符号的通用扩展Let E denote a regular expression. (E)n denotes concatenations of n words generated by E. (Could be written EEE…E(n times)) 多次重复E (E)+ denotes concatenations of at least one word generated by E (Could be written EE∗ or E∗E). 由E生成的至少一个单词的连接 The above give no extra expressive power in terms of what languages can be described. Lexical tokens 词法记号We can use regular expressions for short, precise definitions of lexical tokens:“variable: string of letters/digits starting with a letter” r.e.: {a,b,...,z,A,B,...,Z} {a,b,...,z,A,B,...,Z, 0,1,2,...9}∗number in exponential/scientific notation 指数/科学记数法 (“1.16121122E-03” denotes 1.16121122 × 10−3, i.e. 0.00116121122): {1, 2, 3, ..., 9}.{0, 1, 2, ..., 9}8E{00,{ε, −}{{1, 2, ..., 9}{0, 1, 2, ..., 9}, {0, 1, 2, ..., 9}{1, 2, ..., 9}}} A language that is easier to describe using a regular expression.A language that is easier to describe using a DFA. Equivalences amongst regular expressions Reference XJTLU slides (INT201 W3)","link":"/2021/09/24/INT201-W3/"},{"title":"CPT205 W3","text":"This’s week we will discuss about Geometric Primitives. (几何图元)Applications Packages Tools –&gt; API Library –&gt; Algorithms Techniques Graphics Primitives Points Lines Polygons 多边形 Line Algorithms Digital Differential Analyser (DDA) Bresenham Algorithm Circles Antialiasing 反锯齿 Polygon Fill 多边形填充 Graphics Primitives with OpenGL glBegin(GL_POINTS); glBegin(GL_LINES) glBegin(GL_POLYGON); glBEgin(GL_QUAD) Lecture“Good” discrete lines 离散线 No gaps in adjacent pixels Pixels close to ideal line Consistent choices; same pixels in same situations Smooth looking Even brightness in all orientations Same line for P0P1 as for P1P0 Double pixels stacked up? Line algorithmsDrawing a hrizontal line from (x1,y) to (x2,y) are below DDADDA is digital differential algorithm Generation of circles略过 Lineraster points 栅格点: 就是一般的点jaggies 锯齿: 把点根据标准线连接在一起pixel space 像素空间: 这条线所占据的像素格 Antialiasing by area averaging通过面积平均反锯齿Colour multiple pixels for each x depending on coverage by ideal line.根据理想线的覆盖范围，为每个x的多个像素着色。 Geometric primitives 几何基本-多边形和三角形 The basic graphics primitives are points, lines and polygons 基本的图形原语是点、线和多边形 A polygon can be defined by an ordered set of vertices 一个多边形可以被定义为一组有序顶点的集合 Graphics hardware is optimised for processing points 图形硬件优化处理点 Complex objects are eventually divided into triangular polygons (a process called tessellation) 复杂的物体最终被分割成三角形的多边形 Because triangular polygons are always flat 三角形的多边形总是平的 Scan conversion 自动转换 also called rasterization 栅格化 The 3D to 2D projection givens us 2D vertices (points). Polygon fill 多边形填充 Rasterize edges into framebuffer. Find a seed pixel inside the polygon. Visit neighbours recursively and colour if they are not edge pixels. When vertices lie on the scanlines, cases (a) and (b) must be treated differently when using odd-even fill definition Case (a): zero or two crossings Case (b): one edge crossing Geometric primitives in OpenGLglBegin (prametres) GL_POINTS: individual points GL_LINES: pairs of vertices interpreted as individual line segments GL_LINE_STRIP: series of connected line segments GL_LINE_LOOP: same as above, with a segment added between last and first vertices GL_TRIANGLES: triples of vertices interpreted as triangles GL_TRIANGLE_STRIP: linked strip of triangles GL_TRIANGLE_FAN: linked fan of triangles GL_QUADS: quadruples of vertices interpreted as four-sided polygons GL_QUAD_STRIP: linked strip of quadrilaterals GL_POLYGON: boundary of a simple, convex polygon GL_POINTS123456// this code will draw a point located at (100,100)glBegin(GL_POINTS); glVertex2f(100.0f, 100.0f); ... // add more points if required glEnd( ); GL_LINES123456// this code will draw a line at starting and ending // coordinates specified by glVertex2fglBegin(GL_LINES); glVertex2f(100.0f, 100.0f); // origin of line glVertex2f(200.0f, 140.0f); // end point of lineglEnd( ); How to make lines efficient?1234567// this code will draw two lines &quot;at a time&quot; to save the time it takes to call glBegin and glEndglBegin(GL_LINES); glVertex2f(100.0f, 100.0f); // origin of the FIRST line glVertex2f(200.0f, 140.0f); // end point of the FIRST line glVertex2f(120.0f, 170.0f); // origin of the SECOND line glVertex2f(240.0f, 120.0f); // end point of the SECOND line glEnd( ); Triangle in OpenGL12345glBegin(GL_TRIANGLES); glVertex2f(-0.5,-0.5); glVertex2f(0.5,0.0); glVertex2f(0.0,0.5); glEnd(); glQuad_STRIPOrdering of coordinates very important","link":"/2021/09/23/CPT205-W3/"},{"title":"CAN201 W3","text":"This’s note is about the lecture and lab of Week2 CAN201.The lecture III - Application Layer. Domain Name System (DNS) P2P Applications Socket Programming 套接字编程 LectureDNSaka domain name system Application-layer protocol: DNS是一个应用层协议 C/S architeture client-server architeture 不是p2p的 UDP (port53) 传输方式(无保障 unreliable) 方便提取 不需要握手🤝 hosts, name servers communicate to resolve names (name/address translation) Distributed database implemented in hierarchy of many name servers 分布式数据库在多个名称服务器的层次结构中实现 分层化命名可以减小重名的可能性 分布数据库解决名字到ip解析的关系，方便维护 services, structureDNS services Hostname to IP address translation (A) 最重要的就是翻译功能 Host aliasing (cname) canonical, alias names 别名问题 Mail server aliasing (mx) Load distribution Replicated Web servers: many IP addresses correspond ot one name Why not centralize DNS? 为什么DNS要用分布数据库？ Single point of failure 单点故障 Traffic volume 交通量 Distant centralized database 远程集中式数据库 Maintenance 维护 a distributed, hierarchical databaseClient wants IP for www.amazon.com: Client queries root server to find com DNS server Client queries .com DNS server to get amazon.com DNS server Client queries amazon.com DNS server to get IP address for www.amazon.com root name servers contacted by local name server that can not resolve name root name server: contacts authoritative name server if name mapping not known get mapping returns mapping to local name server 域名的每一个点都是一层，根据这个点的内容来寻找对应的位置。 TLD, authoritative servers Top-level domain (TLD) servers: 顶级域名服务器 Responsible for com, org, net, edu, aero, jobs, museums, and all top-level country domains, e.g.: cn, uk, fr, ca, jp Network Solution maintains servers for .com TLD Educause for .edu TLD (https://net.educause.edu/) Authoritative DNS servers: 权威DNS服务器 Organization’s own DNS servers, providing authoritative hostname to IP mappings for organization’s named hosts 组织自己的DNS服务器，为组织的命名主机提供权威主机名到IP映射 Can be maintained by organization or service provider 可由组织或服务提供商维护 Local DNS name server Does not strictly belong to hierarchy Each ISP (residential ISP, company, university) has one Also called “default name server” When host makes DNS query, query is sent to its local DNS server Has local cache of recent name-to-address translation pairs (but may be out of date!) 本地缓存最近的名称-地址转换对 Acts as proxy, forwards query into hierarchy 充当代理，将查询转发到层次结构 DNS name resolution example两种查询方法 Host at XJTLU wants IP address for www.feimax.com Iterated query 迭代查询 contacted server replies with name of server to contact “I don’t know this name, but ask this server” 相当于不知道之后指路，让用户去问其他服务器 Recursive query 递归查询 Puts burden of name resolution on contacted name server Heavy load at upper levels of hierarchy 一条路走到底，再走回来 caching, updating records缓存，升级记录 Once (any) name server learns mapping, it caches mapping Cache entries timeout (disappear) after some time (TTL) 缓存条目超时后一段时间 TLD servers typically cached in local name servers 经常会缓存顶级服务器，所以根服务器不常被访问 thus root name servers not often visited Cached entries may be out-of-date if name host changes IP address, may not be known Internet-wide until all TTLs expire 如果主机名更改了IP地址，可能在所有ttl过期之前都不知道 Update/notify mechanisms proposed IETF standard 更新/通知机制提议的IETF标准 RFC 2136 DNS recordsDNS: distributed database storing resource records (RR)RR format: (name, value, type, ttl) Loop up a domain nameThere’re several ways to deal with. Use nslookup command. Use whois command. DNS protocol, messageQuery and reply messages, both with same message format. 查询和回复消息，都使用相同的消息格式。 Inserting records into DNS Example: new startup “feimax.com” Register name feimax.com at DNS register Normally, you don’t need to set up the NS record Insert A record for the IP address of your host Insert MX record for email Domain name is a scarce resource! 稀缺资源 Pure P2P architecture no always-on server arbitrary end systems directly communicate peers change IP addressesExamples: file distribution, streaming, VoIP File distribution: client-server vs P2PQ: how much time to distribute file (size F) from one server to N peers？Peer upload/download capacity is limited resource.Example:client upload rate = u, F/u = 1hour, u_s = 10u, d_min &gt;= u_s File distribution time: client-server server transmission: must sequentially send (upload) N file copies: time to send one copy: F/u_s time to send N copies: NF/u_s 发送N个file的大小再除服务器的带宽 client: each client must download file copy d_min = min client download rate max client download time: F/d_min 最慢的那个用户下载文件所用的时间 后来会线性增长 File distribution time: P2P server transmission: must sequentially send (upload) at least one file copies: time to send one copy: F/us 服务器也是有文件的，假如网络里没有人参与p2p那就是服务器直接向唯一的用户分发。 client: each client must download file copy min client download time: F/dmin clients: as total must download NF bits max upload rate (limiting max download rate) is us + Sui 所有的客户端也可以作为服务器上传 P2P file distribution: BitTorrent 文件分发：比特流 File divided into 256Kb chunks 文件分成碎片 Peers in torrent send/receive file chunks Peer joining torrent: has no chunks, but will accumulate them over time from other peers registers with tracker to get list of peers, connects to subset of peers While downloading, peer uploads chunks to other peers Peer may change peers with whom it exchanges chunks Peers may come and go Once peer has entire file, it may leave or remain in torrent BitTorrent: requesting, sending file chunksRequesting chunks: at any given time, different peers have different subsets of file chunks Periodically, Alice asks each peer for list of chunks that they have Alice requests missing chunks from peers, rarest first Sending chunks: tit for tat Alice sends chunks to those four peers currently sending her chunks at highest rate other peers are choked by Alice (do not receive chunks from her) re-evaluate top 4 every 10 secs every 30 secs: randomly select another peer, starts sending chunks “optimistically unchoke” this peer newly chosen peer may join top 4 Higher upload rate: find better trading partners, get file faster! Socket Programming 套接字编程Two socket types for two transport services UDP: unreliable datagram TCP: reliable, byte stream-oriented Application Example: client reads a line of characters (data) from its keyboard and sends data to server server receives the data and converts characters to uppercase server sends modified data to client client receives modified data and displays line on its screen Socket programming with UDPUDP: no “connection” between client &amp; server No handshaking before sending data Sender explicitly attaches IP destination address and port # to each packet Receiver extracts sender IP address and port # from received packet UDP: transmitted data may be lost or recieved out-of-orderApplication viewpoint UDP provides unreliable transfer of groups of bytes (“datagrams”) between client and server 详细见ppt Lab File Operation Text file – Write / Read Binary file – Write /Read Networking Programming Using Socket UDP Server and Client TCP Server and Client Openopen method is exploit to operate files: 1f = open(file='filename.xxx', mode='r') File open modes12345678‘r’ open for reading (default)‘w’ open for writing, truncating the file first‘x’ create a new file and open it for writing‘a’ open for writing, appending to the end of the file if it exists‘b’ binary mode, used for media files't' text mode (default)'+' open a disk file for updating (reading and writing)'U' universal newline mode (deprecated) Write12f.write(Str) # Write a str to a filef.writelines(StrList) # Write a list of str to a file Read123f.read(n) # read n chars(including \\n), n=-1 means read allf.readline() # read one line (including \\n)f.readlines() # return a list of all lines Text file appending123f = open('/Users/fei/lesson1.txt', 'a') # open the filef.write('Bye.\\n') # add text into the filef.close() # close the file Binary file read123f.read(n) # read n bytes(including \\n), n=-1 means read all f.readline() # read one line (including \\n)f.readlines() # return a list of all lines Binary file write1f.write(bytes) # Write some bytes to a file Binary file operation is very powerful, but we don’t go deep today. Socket programmingUDP12345678910111213# Server sidefrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_DGRAM)server_socket.bind(('', server_port))print('The server is ready to receive')while True: message, client_address = server_socket.recvfrom(20480) modifiedMessage = message.decode().upper() server_socket.sendto(modifiedMessage.encode(), client_address) 123456789101112131415# Client sidefrom socket import *server_name = '127.0.0.1' # 127.0.0.1 is your local IP address# Others should not use this IP. You need to use ipconfig(win)# or ifconfig(linux, macos) to get you IP address in the networkserver_port = 12000clientSocket = socket(AF_INET, SOCK_DGRAM)message = input('Input lowercase sentence:')clientSocket.sendto(message.encode(), (server_name, server_port))modifiedMessage, serverAddress = clientSocket.recvfrom(20480)print(modifiedMessage.decode())clientSocket.close() TCP123456789101112131415# Server sidefrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_STREAM)server_socket.bind(('', server_port))server_socket.listen(1)print('The server is ready to receive')while True: connectionSocket, addr = server_socket.accept() sentence = connectionSocket.recv(20480).decode() capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence.encode())connectionSocket.close() 1234567891011# Client Sidefrom socket import *serverName = '127.0.0.1'serverPort = 12000clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName,serverPort))sentence = input('Input lowercase sentence:')clientSocket.send(sentence.encode())modifiedSentence = clientSocket.recv(20480)print('From Server:', modifiedSentence.decode())clientSocket.close() LabTCP12345678910111213141516171819202122232425262728293031323334353637383940# Server side# TCPfrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_STREAM)server_socket.bind(('', server_port))server_socket.listen(2)print('The server is ready to receive')while True: connectionSocket, addr = server_socket.accept() xjtlu1 = connectionSocket.recv(20480) # 接受xjtlu文件 f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu1.jpg', 'wb') # 保存至xjtlu1 保存图片用wb f.write(xjtlu1) connectionSocket.send(xjtlu1) # 由服务器端发送至客户端 f.close()connectionSocket.close()# Client Side# TCPfrom socket import *serverName = '127.0.0.1'serverPort = 12000clientSocket = socket(AF_INET, SOCK_STREAM)clientSocket.connect((serverName, serverPort))f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu.jpeg', 'rb') # 打开xjtlu文件 打开图片用rbimage_data = f.read() # 赋值到image_data里f.close()clientSocket.send(image_data) # 发送至服务器modifiedImage = clientSocket.recv(20480) # 接受服务器发来的xjtlu1xjtlu2 = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu2.jpg', 'wb')xjtlu2.write(modifiedImage) # 保存至xjtlu2xjtlu2.close()clientSocket.close() UDP1234567891011121314151617181920212223242526272829303132333435363738# Server side# UDPfrom socket import *server_port = 12000server_socket = socket(AF_INET, SOCK_DGRAM)server_socket.bind(('', server_port))print('The server is ready to receive')while True: xjtlu1, client_address = server_socket.recvfrom(20480) f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu1.jpg', 'wb') f.write(xjtlu1) server_socket.sendto(xjtlu1, client_address) f.close()# Client side# UDPfrom socket import *server_name = '127.0.0.1' # 127.0.0.1 is your local IP address# Others should not use this IP. You need to use ipconfig(win)# or ifconfig(linux, macos) to get you IP address in the networkserver_port = 12000clientSocket = socket(AF_INET, SOCK_DGRAM)# message = input('Input lowercase sentence:')f = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu.jpeg', 'rb')image_data = f.read()f.close()clientSocket.sendto(image_data, (server_name, server_port))modifiedImage, serverAddress = clientSocket.recvfrom(20480)xjtlu2 = open('/Users/chenzhengde/PycharmProjects/CAN201Lab3/xjtlu2.jpg', 'wb')xjtlu2.write(modifiedImage)xjtlu2.close()clientSocket.close() Reference XJTLU slides (Week3)","link":"/2021/09/23/CAN201-W3/"},{"title":"CPT203 W3","text":"This week we will focus on two topics: Scrum Framework Agile Methods - Background Scrum FrameworkScrum isn’t a standard process.Scrum is a framework for organizing and managing work.Scrum是一个敏捷开发框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发周期包括若干个小的跌代周期，每个小的的跌代周期称为一个Sprint，每个Sprint的建议长度2到4周。The Scrum values, principles, and practices would be the key structural components. You can customize inside the structure of Scrum, adding fixtures and features until you have a process that works for you. Scrum is a simple, people-centric framework based on the values of honesty, openness, courage, respect, focus, trust, empowerment, and collaboration. The Scrum practices themselves are embodied in specific roles, activities, artifacts, and their associated rules. Scrum RolesScrum development efforts consist of one or more Scrum teams. Each made up of three Scrum roles: product owner, ScrumMaster and the development team. The product owner is responsible for what will be developed and in what order. 产品负责人负责开发什么以及以什么顺序开发。 The Scrum Master is responsible for guiding the team in creating and following its own process based on the broader Scrum framework. Scrum Master负责指导团队基于更广泛的Scrum框架创建并遵循自己的流程。 The development team is responsible for determining how to deliver what the product owner has asked for. 开发团队负责确定如何交付产品所有者所要求的内容。 Product OwnerThe single authority responsible for deciding which features and functionality to build and the order in which to build them. The product owner maintains and communicates to all other participants a clear vision of what the Scrum team is trying to achieve. The product owner is responsible for the overall success of the solution being developed or maintained.负责决定构建哪些特性和功能以及构建它们的顺序的单一权威。产品负责人维护Scrum团队想要实现的目标，并与其他所有参与者进行沟通。产品负责人负责开发或维护的解决方案的整体成功。说到底Product Owner就是老板，只负责提供所有的要求和开发顺序。 不完全是老板，他需要和老板沟通。基于增量开发。 To make sure that the most valuable work is always performed. 确保最有价值的工作总是被完成 The product owner actively collaborates with the ScrumMaster and development team. 产品负责人积极与ScrumMaster和开发团队合作 Must be available to answer questions soon after they are posed. 必须能在问题被提出后马上回答 ScrumMasterHelps everyone involved understand and embrace the Scrum values, principles, and practices. Acts as a coach, providing process leadership and helping the Scrum team and the rest of the organization develop their own high performance, organization-specific Scrum approach. The ScrumMaster helps the organization through the challenging change management process that can occur during a Scrum adoption.帮助参与的每个人理解并接受Scrum价值观、原则和实践。作为教练，提供过程领导，帮助Scrum团队和组织的其他成员开发他们自己的高效的、针对组织的Scrum方法。ScrumMaster帮助组织完成在采用Scrum过程中可能发生的具有挑战性的变更管理过程。 ScrumMaster有工头那味了 As a facilitator, the ScrumMaster helps the team resolve issues and make improvements to its use of Scrum. 作为一个推动者，ScrumMaster帮助团队解决问题并改进Scrum的使用。 Also responsible for protecting the team from outside interference and takes a leadership role in removing impediments that inhibit team productivity. 还负责保护团队不受外界干扰，并在消除阻碍团队生产力的障碍方面发挥领导作用。 The ScrumMaster has no authority to exert control over the team, so this role is not the same as the traditional role of project manager or development manager. ScrumMaster没有权力对团队施加控制，所以这个角色与传统的项目经理或开发经理的角色不同。 The ScrumMaster functions as a leader, not a manager. ScrumMaster是一个领导者，而不是管理者。 Development Team Scrum defines the role of a development team, which is simply a diverse, cross-functional collection of people who are responsible for designing, building, and testing the desired product. The development team self-organizes to determine the best way to accomplish the goal set out by the product owner. The development team is typically five to nine people in size. Its members must collectively have all of the skills needed to produce good quality, working software. For development efforts that require much larger team size, team members can be organized into several teams with each team nine or fewer team members. Scrum定义了开发团队的角色，开发团队是一个多元化的、跨职能的团队，负责设计、构建和测试所需的产品。开发团队自组织以确定实现产品所有者设定的目标的最佳方法。开发团队的规模通常是5到9人。它的成员必须集体拥有生产高质量、可工作的软件所需的所有技能。对于需要更大团队规模的开发工作，可以将团队成员组织成几个团队，每个团队有9个或更少的团队成员。Development Team低端码农了属于是 Scrum Activities and Artifacts基于增量开发，整个大圈就是一个scrum Forecast? Commitment?It is a forecast because the estimate might change as more information becomes known during the course of the sprint. Some also believe that a commitment on the part of the team will cause the team to sacrifice quality to meet the commitment. Or will cause the team to “under-commit” to guarantee that the commitment is met.它是一种预测，因为在sprint过程中，随着更多的信息被了解，估计可能会发生变化。有些人还认为，团队的承诺将导致团队牺牲质量来满足承诺。或者会导致团队“承诺不足”，以保证承诺得到满足。 Using the forecast to derive a commitment. Commitments support mutual trust between the product owner and the development team as well as among the development team. Commitments support reasonable short-term planning and decision making within an organization. When performing multiteam product development, commitments support synchronized planning.利用预测得出一个承诺。承诺支持产品所有者和开发团队之间以及开发团队之间的相互信任。承诺支持组织内合理的短期计划和决策。当执行多团队产品开发时，承诺支持同步计划。 Product Backlog 产品待办事项列表The product owner, with input from the rest of the Scrum team and stakeholders, is ultimately respnsible for determining and managing the sequence of works (product backlog items) and communicating it in the form of a prioritized (or ordered) list known as the product backlog.产品负责人根据Scrum团队其他成员和涉众的意见，最终负责确定和管理产品待定项的顺序，并以优先级列表的形式(即产品待定项列表)进行沟通。 High-value items appear at the top of the product backlog and the lower-value items appear toward the bottom. The product backlog is constantly evolving artifact. Items can be added, deleted, and revised by the product owner as business conditions change, or as the Scrum team’s understanding of the product grows. In pratice, many teams use a relative size measure such as story points or ideal days to express the item size. PBI Example User Story: online user registration Description: as a user, I want to be able to register online, so that I can perform online shopping. Acceptance Criteria: User can register only if the user fills in all required fields The email used in the registration must not be a free email User will receive a notification email after successful registration Product Backlog Grooming 梳理产品待办事项列表The activity of creating and refining product backlog items, estimating them, and priortizing them is known as grooming. 创建和细化产品待办事项列表项、评估它们并对它们进行优先级排序的活动称为梳理。优先级从Feature A–&gt;Feature C逐渐降低。 Sprint 冲刺In Scrum, work is performed in iterations or cycles of up to a calendar month called sprints. 每个sprint的周期时间都是相同的。The work completed in each sprint should create something of tangible value to the customer or user. Sprints are timeboxed so they always have a fixed start and end date, and generally they should all be of the same duration. A new sprint immediately follows the completion of the previous sprint.在每个“冲刺”中完成的工作应该为客户或用户创造一些有形的价值。sprint是有时间框的，所以它们总是有一个固定的开始和结束日期，通常它们都应该具有相同的持续时间。在前一个冲刺完成之后，马上会有一个新的冲刺。 召开Sprint Plan Meeting，确定这个Sprint的目标、演示日期、要完成的Backlog、Backlog的优先级等； 进入冲刺开发周期，在这个周期内，每天要召开Daily Stand-up Meeting； 整个冲刺周期结束，召开Sprint Review Meeting，将成果演示给Product Owner； 团队成员最后召开Sprint Retrospective Meeting，总结问题和经验. Sprint PlanningA product backlog may represent many weeks or months of work. To complete all the items in the product backlog, a series of sprints are to be carried out. To determine the most important subset of product backlog items to build in the next sprint, the product owner, development team, and ScrumMaster perform sprint planning.一个产品待办事项列表可能代表数周或数月的工作。为了完成产品待办事项列表中的所有项目，需要进行一系列的“冲刺”。为了确定下一个sprint中要构建的产品待定项的最重要子集，产品所有者、开发团队和ScrumMaster执行sprint计划。 During sprint planning, the product owner and development team agree on a sprint goal that defines what the upcoming sprint is supposed to achieve. Based on the sprint goal, the development team reviews the product backlog and determines the high priority items that the team can realistically accomplish in the upcoming sprint while working at a sustainable pace.在“冲刺”计划中，产品负责人和开发团队就“冲刺”目标达成一致，该目标定义了即将到来的“冲刺”应该实现什么。基于“冲刺”目标，开发团队审查产品待办事项列表，并确定在即将到来的“冲刺”中团队可以实际完成的高优先级项目，同时以“可持续的速度”工作。Many development teams break down each targeted feature into a set of tasks. The collection of these tasks, along with their associated product backlog items, forms a second backlog called the sprint backlog.The team provides an estimate (typically in hours) of the effort required to complete each task. 总的来说，选择一个产品待办事项列表项(最重要项)，将该项分解为任务，并确定所选的项是否合理地适合sprint(与同一sprint的其他目标项相结合)。如果它确实适合，并且有更多的能力来完成工作，那么重复这个循环，直到团队没有能力做更多的工作。 Sprint ExecutionOnce the Scrum team finishes sprint planning and agrees on the content of the next sprint, the development team performs all of the task-level work necessary to get the features done. 一旦Scrum团队完成了“冲刺”计划，并就下一个“冲刺”的内容达成一致，开发团队就会执行完成特性所需的所有任务级工作。“done” means there is a high degree of confidence that all of the work necessary for producing good-quality features has been completed. “完成”意味着有高度的信心，生产高质量功能所需的所有工作已经完成。Team members define their own task-level work and then self organize in any manner they feel is best for achieving the sprint goal. 团队成员定义他们自己的任务级工作，然后以他们认为最适合实现sprint目标的方式进行自我组织。 Daily ScrumNot a problem-solving activity. Talk about problems after the daily scrum and do so with a small group of interested member. Not a traditional status meeting. Communicate the status of sprint backlog items among the development team members. It is an inspection, synchronization, and adaptive daily planning activity that helps a self-organizing team do its job better. 在日常的scrum之后和一小群感兴趣的成员讨论问题。不是传统的地位会议。在开发团队成员之间沟通sprint待定项的状态。它是一种检查、同步和自适应的日常计划活动，帮助自组织团队更好地完成工作。 Definition of DoneSprint results as a potentially shippable product increment, meaning that whatever the Scrum team agreed to do is really done according to its agreed upon definition of done. This definition specifies the degree of confidence that the work completed is of good quality and is potentially shippalbe. A bare-minimum definition of done should yield a complete slice of product functionally that is designed, built, integrated, tested and documented. Sprint的结果是一个潜在的可交付产品增量。“完成”的最小定义应该产生设计、构建、集成、测试和文档化的产品功能的完整部分。 “pontentially shippable” does not mean that what got built must actually be shipped. 潜在的交付并不代表项目必须交付，交付的决定属于商业决定(business decision)会因此各种决定而改变。例如: Do we have enough features or enough of a customer workflow to justify a customer deployment? 我们是否有足够的特性或足够的客户工作流来证明客户部署的合理性? Can our customers absorb another change given that we just gave them a release two weeks ago? 我们两周前刚刚发布了一个版本，我们的客户能接受另一个变化吗? Sprint ReviewAt the end of sprint there are two additional inspect-and-adapt activities, sprint review (sprint评审) and sprint retrospective (sprint回顾). Sprint review is to inspect and adapt the product that is being built. Sprint评审是检查和调整正在构建的产品。 演示，获得feedback。 Critical to this activity is the conversation that takes place among its participants, which include the Scrum team, stakeholders, sponsors, customers and interested members of other teams. Focused on reviewing the just-completed features in the context of the overall development effort. Everyone in attendance gets clear visibility into what is occurring and has an opportunity to help guide the forthcoming development to ensure that the most business-appropriate solution is created.这个活动的关键是参与者之间的对话，参与者包括Scrum团队、利益相关者、赞助者、客户和其他团队感兴趣的成员。着重于在整个开发工作的上下文中回顾刚刚完成的特性。参加会议的每个人都能清楚地了解正在发生的事情，并有机会帮助指导即将进行的开发，以确保创建最适合业务的解决方案。 Sprint RetrospectiveThis is the second inspect-and-adapt activity at the end of the sprint. 第二个总结活动在sprint结束时。Frequently occurs after the sprint review and before the next sprint planning. 经常发生在“冲刺”评审之后和下一个“冲刺”计划之前。Sprint retrospective is an opportunity to inspect and adapt the process. Sprint回顾是一个检查和调整过程的机会。The development team, ScrumMaster, and product owner discuss what is and is not working with Scrum and associated technical practices. 开发团队、ScrumMaster和产品负责人讨论什么是Scrum，什么不是Scrum，以及相关的技术实践。The focus is on the continuous process improvement. 重点是持续的过程改进。At the end of a sprint retrospective the Scrum team should have identified and committed to a practical number of process improvement actions. 在sprint回顾的最后，Scrum团队应该确定并承诺一些实际的过程改进行动。 Sprint Review和Sprint Retrospective都是在每一个sprint结束后发生的，他俩应该是紧挨在一起进行的，只是会议的内容和参会人员有所不同。每天的任务结束一直会进行的是daily scrum。 Agile Methods 敏捷方法 Agile methods Plan-driven and agile development 其实这部分和Scrum Framework的位置我放反了，但是就先这么看着吧。 Background大公司需要产品的时候，愿意权衡软件质量和需求，以更快地部署他们需要的软件。因为不可能推导出一套完整的稳定的软件需求。最初的需求不可避免地会发生变化。最后为了尽快交付系统，让用户获得经验，发现更清晰的真实需求由于外部因素，需求可能会迅速和不可预测地变化。 Content Some of the agile methods Extreme programming (Beck, 1999; Beck, 2000) Scrum (Cohn, 2009; Schwaber, 2004; Schwaber and Beedle, 2001) Crystal (Cockburn, 2001; Cockburn, 2004) Adaptive Software Development (Highsmith, 2000) DSDM (Stapleton, 1997; Stapleton, 2003) Feature Driven Development (Palmer and Felsing, 2002) These agile methods are all based around the notion of incremental development and delivery with different processes 这些敏捷方法都是基于增量开发和不同过程交付的概念 However, they share a set of principles, based on the agile manifesto, and so have much in common. 基于敏捷宣言共享了一套原则，因此有很多共同点。 The software is not developed as a single unit but as a series of increments, with each increment including new system functionality.Fundamental characteristics: scrum是基于敏捷开发 The processes are interleaved. Minimum documentation 文件减到最小 只有需求文档，剩下的文档用可读易懂的代码代替 Developed in a series of versions, or increments, with system stakeholders involvement. System user interfaces are often developed using an interactive development system that allows the interface design to be quickly created The philosophy behind agile methods is reflected in the agile manifesto that was agreed on by many of the leading developers of these methods. Individuals and interactions over processes and tools 个人和互动高于过程和工具 Working software over comprehensive documentation 工作软件胜过全面的文档 Customer collaboration over contract negotiation 客户合作高于合同谈判 Responding to change over following a plan 响应计划的变更 Most software projects include practices from plan-driven and agile approaches. 大多数软件项目包括来自计划驱动和敏捷方法的实践。 Tutorial Explain why the rapid delivery and deployment of new systems is often more important to businesses than the detailed functionality of these systems. 为什么快速交付和部署新系统往往比这些系统的详细功能更重要A: A conventional waterfall or specification-based process is usually prolonged and the final software is delivered to the customer long after it was originally specified. In a fast-moving business environment, this can cause real problems. By the time the software is available for use, the original requirements may have changed so radically that the software is effectively useless. Therefore, for business systems in particular, development processes that focus on rapid software development and delivery are essential. 传统的瀑布式或基于规格说明的过程通常会延长，最终的软件在最初指定之后很长时间才交付给客户。在快速变化的商业环境中，这可能会导致真正的问题。当软件可以使用时，原始的需求可能已经发生了根本的变化，以至于软件实际上是无用的。因此，特别是对于业务系统，专注于快速软件开发和交付的开发过程是必不可少的。 Explain how the principles underlying agile methods lead to the accelerated development and deployment of software. 敏捷开发的原则 Individual and interactions over processes and tools. 流程和工具之上的个人和交互 Working software over comprehensive documentation. 工作软件胜过全面的文档 Customer collaboration over contract negotiation. 客户合作高于合同谈判 Responding to change over following a plan. 响应计划的变更 When would you recommend against the use of an agile method for developing a software system? 什么时候你会建议不要使用敏捷方法来开发软件系统 Agile methods should probably not be used when the software is being developed by teams who are not co-located. If any of the individual teams use agile methods, it is very difficult to coordinate their work with other teams. Furthermore, the informal communication which is an essential part of agile methods is practically impossible to maintain unless they are being supported by collaboration tools such as online meeting. 当软件由不在同一地点的团队开发时，可能不应该使用敏捷方法。如果任何一个团队使用敏捷方法，那么就很难与其他团队协调工作。此外，非正式交流是敏捷方法的重要组成部分，除非得到在线会议等协作工具的支持，否则实际上是不可能维护的。 Agile methods should probably also be avoided for critical systems where the consequences of a specification error are serious. In those circumstances, a system specification that is available before development starts makes a detailed specification analysis possible. 对于规范错误后果严重的关键系统，可能也应该避免使用敏捷方法。在这些情况下，在开发开始之前可用的系统规范使详细的规范分析成为可能。 However, some ideas from agile approaches such as test first development are certainly applicable to critical systems. 然而，敏捷方法中的一些想法，如测试优先开发，肯定适用于关键系统。 To reduce costs and the environmental impact of commuting,your company decides to close a number of offices and to provide support for staff to work from home. However, the senior management who introduce the policy are unaware that software is developed using agile methods, which rely on close team working and pair programming. Discuss the difficulties that this new policy might cause and how you might get around these problems. 引入这一策略的高级管理人员并不知道软件是使用敏捷方法开发的，这种方法依赖紧密的团队合作和结对编程。讨论这个新政策可能导致的困难，以及如何解决这些问题。A: When a company is driven by a close team and is divided they will be unable to have daily meetings, which can cause issues with communication, programming in pairs would not be possible, a communication gab would be created, productivity will slow down due to communication issues, and detecting errors would be quite difficult. These problems can be avoided by creating merging offices together so pair programming and daily communication can be established. If that is not possible, a communication platform consisting of webcams, desktop viewing software, and microphones should be created to allow better communication. 当一个公司是由亲密的团队,他们将无法日常会议,这可能会导致问题沟通、成对编程不可能,一个通信唠叨会被创建,生产力将减缓由于沟通问题,和检测错误是相当困难的。这些问题可以通过在一起创建合并办公室来避免，这样就可以建立结对编程和日常通信。如果这是不可能的，应该创建一个由网络摄像头、桌面查看软件和麦克风组成的通信平台，以便更好地进行通信。 References XJTLU slides CPT203 Week3 什么是敏捷开发之Scrum框架，如何入门？ - 项目管理进阶的回答 - 知乎 Sprint Review vs Sprint Retrospective","link":"/2021/09/22/CPT203-W3/"},{"title":"INT201 W2","text":"This is the note of INT201 Week2. The lecture is still focusing on decision, computation and language. Alphabet A,A* = {alll strings consisting symbols from A}A subset L of A* is called a languageQuestion: For a language L, does exist an algorithm to check for any x, if x is in L? Nondeterministic finite automata 非确定性有限自动机Recall: we took original DFA definition and extended that definition to allow some transitions to be undefined. Nondeterministic Finite Automata (NFA) are a futher extension… 我们采用了原始的DFA定义并扩展了该定义以允许未定义一些转换。非确定性有限自动机是一个进一步的扩展。 describing a formal language (may be simpler than equivalent DFAs) 描述一种形式语言 conversion between finite automata and regular expressions 有限自动机和正则表达式之间的转换 “nondeterministic” – an input string does not determine the final state. 一个输入字符串不能决定最终状态。This is because given a current state and an input letter, we may specify a set of allowable new states, not just one. 这是因为给定一个当前状态和一个输入字母，我们可以指定一组允许的新状态，而不仅仅是一个。DFA和NFA的区别在于转移函数的类型。不同于DFA对于同一个输入和同一个状态只有一个转移，NFA对于同一输入和同一状态可以有多个或零个转移。DFA的转移必须是一对一的，NFA中的状态转移以集合的形式展现。Then we say that a NFA accepts an input word w if there exists a sequence of transitions labelled by symbols in w, starting from initial state and ending at some accepting state. 然后我们说一个NFA接受一个输入词w，如果存在一个以w标记的转换序列，从初始状态开始到某个接受状态结束。 通过CSDN上的一篇文章系统的了解了一下NFA和DFA当输入一个数值的时候，DFA可以转移到固定的状态，但是NFA不可以转移到确定的状态 The formal definitionLet P(S) denote the set of all subsets of a set S. A nondeterministic finite automaton (or NFA) is a quintuple A = (Q,A,φ,i,T) where Q is a finite nonempty set whose members are called states of the automaton. A is a finite nonempty set called the alphabet of the automaton. φ is a map from Q × A to P(Q) called the transition function of the automaton. i is a number of Q and is called the initial state. T is a nonempty subset of Q whose members are called terminal states or accepting states. Notation建议直接看ppt 假设，在一个DFA中，我们可以通过以单词w的字母标记的转换从状态p到状态q，然后我们说状态p和状态q由标记为w的路径连接。如果w = abc两个中间状态是r1和r2，我们可以把它写成In a NFA, if φ(p,a) = {q,r} we could write DFA是一种NFA的约束形式，DFA进行转换的结果集的大小被约束为1或0，因此，DFA接受的语言都被NFA接受。NFA优缺点: NFA相对于对应的DFA，需要更少的状态，但是这样就会增加搜索的时间。DFA比较快，但不提供Backtrack（回溯）功能，NFA比较慢，但提供了Backtrack功能。 Reference XJTLU MC PowerPoint slides (Week2) bilibili: NFA to DFA","link":"/2021/09/20/INT201-W2/"},{"title":"CPT205 W2","text":"This’s the note of CPT205 W2. The topics for this week: Computer representation of objects Cartesian co-ordinate system Points, lines and angles Trigonometry 三角函数 Vectors (unit vector) and vector calculations (addition, subtraction, scaling, dot product, cross product) 矢量和矢量计算 Matrices (dimension, transpose, square/symmetric/identity, inverse) and matrix calculations (addition, subtraction, multiplication) 矩阵和矩阵计算 因为矩阵的知识快忘光了，所以矩阵的部分写的比较多。 LectureComputer representation of objects Cartesian co-ordinate system都是笛卡尔平面直角坐标系的知识，不会的建议重开。 Points, lines and angles同上。 Trigonometry同上。 Vectors同上。 Matrices Techniques for applying transformations use matrices. 应用变换的技术使用矩阵。 A matrix is simply a set of numbers arranged in a rectangular format. 矩阵是一组按矩形形式排列的数字。 Each number is known as an element. 每个数字都是一个元素。 Capital letters are used to represent a matrix. 用大写字母表示矩阵。 Bold letters when printed (M), or underlined when written. 打印时加粗或下划线。 A matrix has dimensions that refer to the number of rows and the number of columns it has. 矩阵的维数指的是它的行数和列数 Dimensions of matricesThe dimensions of Matrix are (x * y). x is the number of rows in matrix and y is the columns.$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$The dimensions of this matrix are (2*3). Transpose matrixWhen a matrix is rewritten so that its rows and columns are interchanged, then the resulting matrix is called the transpose of the original. 当一个矩阵被改写使它的行和列互换时，得到的矩阵叫做原矩阵的转置。The original A:$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$The transpose matrix of A:$$ \\begin{bmatrix} 1 &amp; 4 \\\\ 2 &amp; 5 \\\\ 3 &amp; 6 \\\\ \\end{bmatrix}$$ Square and symmetric matrices A square matrix is matrix where the number of rows equals the number of columns. 行列数量相同的是方阵。 A symmetric matrix is a square matrix where the rows and columns are such that its transponse is the same as the original matrix. 对角线对称的方阵是对称矩阵。 Identity matricesAn identity matrix, I is a square matrix with zeros everywhere except its diagonal elements which have a value of 1. 单位矩阵就是对角线是1，剩下的都是0的方阵。 Adding matrices Matrices A and B may be added if they have the same dimensions. That is, the corresponding elements may be added to yield a resulting matrix. The sum is commutative, i.e. A + B = B + A 加法交换律 Subtracting matricesMatrix B may be subtracted from matrix A if they have the same dimensions, i.e. the corresponding elements of B may be subtracted from those of A to yield a resulting matrix.The result is not commutative. Reversing the order of the matrices yields different results, i.e. A - B ≠ B -A ⚠️减法🈚️交换律! Multiplying matrices By a constant By a matrix - The rule for multiplying one matrix to another is simple: if the number of columns in the first matrix is the same as the number of rows in the second matrix, the multiplication can be done. 也就是必须要是(x * y)&amp;(y * z)，计算结果是(x * z)。 Matrix multiplication is not commutative. Reversing the order of the matrices yields different results. ⚠️矩阵的乘法也是没有交换律的！交换相乘的两个矩阵的位置会产生不同的结果。 Inverse matricesIf two matrices A and B, when multiplieid together, results in an indentity matrix I, then matrix A is the inverse of matrix B and vice versa, i.e.$$A * B = B * A = I$$$$A = B^{-1} and B = A^{-1}$$两个矩阵相乘是一个单位矩阵那这两个矩阵就是逆矩阵。 LabThe tutorial explains the C/C++ basics that will be used in CPT205 Computer Graphics.跟着lab做问题不大，注意一个cpp的project中只有可以有一个main方法，这是和py不一样的地方。学校给的那个lab代码需要引入math才可以正常操作。引入库的时候需要手动输入，复制粘贴的时候会出现无法读取的问题 #include &lt;GL/freeglut.h&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#define FREEGLUT_STATIC #include &lt;GL/freeglut.h&gt; #include &lt;math.h&gt;void define_to_OpenGL(); /////////////////////////////////// int main(int argc, char** argv) { glutInit(&amp;argc,argv); // Task 2 glutInitWindowSize(600, 400); // 整个window的大小 glutInitWindowPosition(50, 50); // window的左上角对于屏幕左上角的坐标 glutCreateWindow(&quot;Graphics Primitives&quot;); // 初始化一个窗口 glutDisplayFunc(define_to_OpenGL); glutMainLoop(); // 实现循环} /////////////////////////////////// void define_to_OpenGL() { glClearColor(1,1,1,1); glClear(GL_COLOR_BUFFER_BIT); // The stuff to appear on screen goes here // Task 2 Set the Dimensions glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(-100,500,-200,200); // window的原点设定，因为window是600*400，所以这里的x1x2y1y2分别代表了左下角的点和右上角的点。 // Task 3 Draw the Axes glLineWidth(1.0); glColor3f(1.0,0.0,0.0); glBegin(GL_LINES); glVertex2f(0.0,0.0); // start location glVertex2f(450.0,0.0); // end location glVertex2f(0.0,-150.0); // start location glVertex2f(0.0,150.0); // end location glEnd(); // Task 4 Draw a Dot at the Origin glPointSize(10); glColor3f(1.0,0.0,1.0); glBegin(GL_POINTS); glVertex2f(0.0,0.0); glEnd(); // Task 5 Plot a Sine Wave // draw a sine wave int i; float x,y; glColor3f(0.0,0.0,1.0); glPointSize(1); glBegin(GL_POINTS); for(i=0;i&lt;361;i=i+1) { x = (float)i; y = 100.0 * sin(i*(2*3.14/360.0)); //角度360转弧度2Π，sin函数里面放的是弧度 glVertex2f(x,y); } glEnd(); // Tasks 6 Draw a Triangle // Tasks 7 Draw A Multi-coloured Triangle // Tasks 8 Draw a Single-coloured Triangle glShadeModel(GL_FLAT); //turn off the smoothing capability glBegin(GL_TRIANGLES); glColor3f(1, 0, 0); glVertex2f( -50, 50 ); glColor3f(0, 1, 0); glVertex2f( -50, 0 ); glColor3f(0, 0, 1); glVertex2f( 0, 0 ); glEnd(); glFlush(); // 这两个是让图像显示到屏幕上} References XJTLU CPT205 slides (Week2)","link":"/2021/09/20/CPT205-W2/"},{"title":"CPT203 W2","text":"This note is about the Lecture 2 of CPT203. This week we will focus on three following spots. understand the concepts of software processes and software process models; introduced to three generic software process models and when they might be used; know about the fundamental process activities of software requirements engineering, software development, testing, and evolution; IntroductionA software process is a set of related activities that leads to the production of a software product. These activites may involve the development of software from scratch 软件从零开始 by extending and modifying existing systems 扩展和修改现有系统 by configuring and integrating off-the-shelf software or system components 通过配置和集成现成的软件或系统组件 Software processes must include four activites that are fundamental to software engineering: software specification 软件规范 software design and implementation 软件设计与实现 software validation 软件验证 software evolution 软件进化They’re complex activities and include sub-activities.There’re also supporting process activities such as documentation and software configuration management. 还有支持过程活动，如文档和软件配置管理。 Software processes are categorized as either plan-driven or agile processes. 软件过程分为计划驱动过程和敏捷过程两种。 Plan-driven processes are processes where all of the process activities are planned in advance and progress is measured against this plan. 计划驱动的过程是指所有过程活动都提前计划，并根据该计划衡量进度的过程。 In agile processes, planning is incremental and it is easier to change the process to reflect changing customer requirements. 在敏捷过程中，计划是增量的，更容易改变过程以反映客户需求的变化。 Software Process ModelsA software process model is a simplified representation of a software process.软件过程模型是软件过程的简化表示。 The models in our discussionThe waterfall model 瀑布模型This takes the fundamental process activites of specification, development, validation, and evolution and represents them as separate process phases such as requirements specification, software design, implementation, testing, and so on. 它将基本的过程活动(如规格说明、开发、验证和演进)表示为独立的过程阶段，如需求规格说明、软件设计、实现、测试等等。 Incremental development 增量开发This approach interleaves the activities of specification, development, and validation. The system is developed as a series of versions (increments), with each version adding functionality to the previous version.这种方法将规范、开发和验证活动交织在一起。系统被开发为一系列版本(增量版本)，每个版本向前一个版本添加功能。 Reuse-oriented software engineering 面向重用的软件工程This approach is based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.这种方法是基于大量可重用组件的存在。系统开发过程关注于将这些组件集成到系统中，而不是从头开始开发它们。 These models are not mutually exclusive and are often used together, especially for large systems development. 这些模型不是相互排斥的，而且在大型系统开发中经常一起使用。 The waterfall modelThis model is known as the ‘waterfall model’ or software life cycle 生命循环. This is an example of a plan-driven process 计划驱动流程.该模型直接反应了以下的活动 Requirements analysis and definition 需求分析和定义 System and software design 系统和软件设计 Implementation and unit testing 实现和单元测试 Integration and system testing 集成和系统测试 Operation and maintenance 操作维护 In principle, the result of each phase is one or more documents that are approved (‘signed off’). The following phase should not start until the previous phase has finished. In practice, these stages overlap and feed information to each other. The software process is not a simple linear model but involves feedback from one phase to another. Documents produced in each phase may then have to be modified to reflect the changes made.原则上，每个阶段的结果是一个或多个文件被批准。在下一阶段应该直到前一阶段结束后才开始。实际上，这些阶段相互重叠并提供信息。软件过程不是一个简单的线性模型，而是涉及从一个阶段到另一个阶段的反馈。每个阶段产生的文件可能需要修改以反映所做的更改。 Because of the costs of producing and approving documents, iterations can be costly and involve significant rework. Therefore, after a small number of iterations, it is normal to freeze parts of the development, such as the specification, and to continue with the later development stages. Problems are left for later resolution, ignored, or programmed around. This premature freezing of development tasks may mean that the system won’t deliver what the users are expecting.由于生产和批准文件的成本，迭代可能是昂贵的，并涉及重大的返工。因此，在少量的迭代之后，冻结开发的某些部分(如规范)并继续进行后期的开发阶段是正常的。问题被留到以后解决，或者被忽略，或者被编程处理。开发任务的过早冻结可能意味着系统无法交付用户所期望的内容。 During the final life cycle phase (operation and maintenance) the software is put into use. Errors and omissions in the original software requirements are discovered. Program and design errors emerge and the need for new functionality is identified. The system must therefore evolve to remain useful. Making these changes (software maintenance) may involve repeating previous process stages.在软件生命周期的最后阶段(操作和维护)，软件投入使用。发现原始软件需求中的错误和遗漏。出现程序和设计错误，识别新功能的需求。因此，系统必须不断发展才能保持有用。进行这些更改(软件维护)可能涉及重复前面的过程阶段。 In the Waterfall Model, documentation is produced at each phase. This makes the process visible so managers can monitor progress against the development plan. Its major problem is the inflexible partitioning of the project into distinct stages. Commitments must be made at an early stage in the process, which makes it difficult to respond to changing customer requirements. In principle, the waterfall model should only be used when the requirements are well understood and unlikely to change radically during system development.在瀑布模型中，每个阶段都会生成文档。这使得过程可见，以便管理人员可以根据开发计划监控进度。它的主要问题是不灵活地将项目划分为不同的阶段。必须在流程的早期阶段做出承诺，这使得很难响应客户不断变化的需求。原则上，瀑布模型只应该在需求被很好地理解并且不太可能在系统开发过程中发生根本变化的情况下使用。 Incremental development Incremental development is based on the idea of developing an initial implementation, exposing this to user comment and evolving it through several versions until an adequate system has been developed. Specification, development, and validation activities are interleaved rather than separate, with rapid feedback across activities. Incremental software development, which is a fundamental part of agile approaches, is better than a waterfall approach for most business, e-commerce, and personal systems.增量开发基于这样的想法:开发一个初始实现，将其公开给用户评论，并通过几个版本对其进行改进，直到开发出一个合适的系统。规范、开发和验证活动是交错而不是分离的，活动之间有快速的反馈。增量软件开发是敏捷方法的基本部分，对于大多数业务、电子商务和个人系统来说，增量软件开发比瀑布方法要好。 By developing the software incrementally, it is cheaper and easier to make changes in the software as it is being developed. Each increment or version of the system incorporates some of the functionality that is needed by the customer. Generally, the early increments of the system include the most important or most urgently required functionality. This means that the customer can evaluate the system at a relatively early stage in the development to see if it delivers what is required. If not, then only the current increment has to be changed and, possibly, new functionality defined for later increments.通过增量式开发软件，在开发过程中对软件进行更改更便宜也更容易。系统的每个增量或版本都包含了客户需要的一些功能。通常，系统的早期增量包括最重要或最迫切需要的功能。这意味着客户可以在开发的相对早期阶段评估系统，看看它是否交付了所需的内容。如果没有，那么只需要更改当前的增量，并且可能为以后的增量定义新的功能。 Incremental development has three important benefits, compared to the waterfall model: 相比于瀑布模型的优势 The cost of accommodating changing customer requirements is reduced. 降低了适应客户需求变化的成本。 It is easier to get customer feedback on the development work that has been done. 对于已经完成的开发工作，更容易获得客户的反馈。 More rapid delivery and deployment of useful software to the customer is possible, even if all of the functionality has not been included. 即使没有包含所有的功能，也可以更快速地向客户交付和部署有用的软件。 From a management perspective, the incremental approach has two problems: the process is not visible. 流程不可视 system structure tends to degrade as new increments are added. 系统结构会随着增量的增加而降低 Other problems with incremental development includes: large organizations have bureaucratic procedures that have evolved over time and there may be a mismatch between these procedures and a more informal iterative or agile process. 大型组织的官僚程序随着时间的推移而演变，在这些程序和更非正式的迭代或敏捷过程之间可能存在不匹配。 Formal procedures are required by external regulations (e.g., accounting regulations) The problems of incremental development become particularly acute for large, complex, long-lifetime systems, where different teams develop different parts of the system. Large systems need a stable framework or architecture and the responsibilities of the different teams working on parts of the system need to be clearly defined with respect to that architecture. This has to be planned in advance rather than developed incrementally.对于大型、复杂、长生命周期的系统，增量开发的问题变得特别尖锐，在这些系统中，不同的团队开发系统的不同部分。大型系统需要一个稳定的框架或体系结构，不同团队在系统部分的工作职责需要根据该体系结构明确定义。这必须提前计划，而不是渐进地开发。 Reuse-oriented software engineering In the majority of software projects, there are some forms of informal software reuse. This informal reuse takes place irrespective of the development process that is used. In the 21st century, software development processes that focus on the reuse of existing software have become widely used. Reuse-oriented approaches rely on a large base of reusable software components and an integrating framework for the composition of these components.在大多数软件项目中，有一些非正式的软件重用形式。这种非正式的重用与所使用的开发过程无关。在21世纪，注重现有软件重用的软件开发过程得到了广泛的应用。面向重用的方法依赖于大量的可重用软件组件和用于这些组件组合的集成框架。 Three types of software component that may be used in a reuse-oriented process: Web services that are developed according to service standards and which are available for remote invocation. 根据服务标准开发并可用于远程调用的Web服务。 Collections of objects that are developed as a package to be integrated with a component framework such as .NET or J2EE. 对象的集合被开发成一个包，与组件框架集成。 Stand-alone software systems that are configured for use in a particular environment. 配置为在特定环境中使用的独立软件系统。 Advantages reducing the amount of software to be developed and so reducing cost and risks. 减少需要开发的软件数量，从而降低成本和风险。 usually also leads to faster delivery of the software. 通常也会导致更快的软件交付。 However, requirements compromises are inevitable and this may lead to a system that does not meet the real needs of users. Furthermore, some control over the system evolution is lost as new versions of the reusable components are not under the control of the organization using them.然而，需求妥协是不可避免的，这可能导致系统不能满足用户的实际需求。此外，由于可重用组件的新版本不在使用它们的组织的控制之下，对系统演化的一些控制就会丢失。 Software process activitiesThere’re four types of software process activites. Software Specification Software Design and Implementation Software Validation Software Evolution 真实的软件过程是技术、协作和管理活动的交错序列，其总体目标是指定、设计、实现和测试一个软件系统。在不同的开发过程中，规范、开发、验证和演进这四个基本过程活动的组织方式不同。 In the waterfall model, they are organized in sequence. 在瀑布模型中，它们是按顺序组织的。 In incremental development they are interleaved. 在增量开发中，它们是交错的。 How these activities are carried out depends on the type of software, people, and organizational structures involved. 这些活动如何进行取决于所涉及的软件、人员和组织结构的类型。 Software specification 软件规格说明Software specification or requirements engineering is the process of understanding and defining 软件规格说明或需求工程是理解和定义的过程 what services are required from the system 系统需要哪些服务 identifying the constraints on the system’s operation and development. 识别系统运行和发展的制约因素 Requirements engineering is a particularly critical stage of the software process as errors at this stage inevitably lead to later problems in the system design and implementation. 需求工程是软件过程中一个特别关键的阶段，因为这一阶段的错误不可避免地会导致系统设计和实现中的后续问题。 The activities of analysis, definition, and specification are interleaved. 分析、定义和规范的活动是交错的。 The requirements engineering process aims to produce an agreed requirements document that specifies a system satisfying stakeholder requirements. 需求工程过程的目的是产生一个商定的需求文档，指定一个满足涉众需求的系统。 规格一般分为两层级细节。Requirements are usually presented at two levels of detail. End-users and customers need a high-level statement of the requirements; 终端用户和客户需要高层次的需求说明; system developers need a more detailed system specification. 系统开发人员需要一个更详细的系统规范。 There are four main activities in the requirements engineering process: 在工程过程需求中一般有四种活动 Feasibility study 可行性研究 Requirements elicitation and analysis 需求提取和分析 Requirements specification 需求规范 Requirements validation 需求验证 Software design and implementationThe implementation stage of software development is the process of converting a system specification into an executable system. It always involves processes of software design and programming but, if an incremental approach to development is used, may also involve refinement of the software specification. A software design is a description of the structure of the software to be implemented, the data models and structures used by the system, the interfaces between system components and, sometimes, the algorithms used. 软件开发的实现阶段是将系统规范转换为可执行系统的过程。它总是涉及到软件设计和编程的过程，但是，如果使用增量开发方法，也可能涉及到软件规范的细化。软件设计是描述要实现的软件的结构、系统使用的数据模型和结构、系统组件之间的接口，有时还包括使用的算法。 设计师不会立即完成设计，而是反复开发设计。他们在开发设计的过程中添加了正式性和细节，不断回溯以纠正早期的设计。 Design activities Architectural design, where you identify the overall structure of the system, the principal components (sometimes called sub-systems or modules), their relationships, and how they are distributed. 架构设计，确定系统的整体结构、主要组件，它们之间的关系以及它们是如何分布的。 Interface design, where you define the interfaces between system components. This interface specification must be unambiguous. 接口设计，定义系统组件之间的接口。这个接口规范必须是明确的。 Component design, where you take each system component and design how it will operate. 组件设计，将每个系统组件设计成如何运行。 a simple statement of the expected functionalities. 对预期功能的简单说明 a list of changes to be made to a reusable component. 可重用组件的更改列表 a detailed design model (model-driven approach). 详细的设计模型 Database design, where you design the system data structures and how these are to be represented in a database. 数据库设计，即设计系统数据结构以及如何在数据库中表示这些结构。 The detail and representation of the design output vary considerably. For critical systems, detailed design documents setting out precise and accurate descriptions of the system must be produced. 对于关键系统，必须编制详细的设计文件，对系统进行精确的描述。 If a model-driven approach is used, these outputs may mostly be diagrams. 如果使用模型驱动的方法，这些输出可能主要是图。 Where agile methods of development are used, the outputs of the design process may not be separate specification documents but may be represented in the code of the program. 在使用敏捷开发方法的情况下，设计过程的输出可能不是单独的规格文件，而是在程序代码中表示。 Software validation There’re three testing process: 三种test process Development testing 开发测试 - The components making up the system are tested by the people developing the system. Each component is tested independently, without other system components. System testing 系统测试 - System components are integrated to create a complete system. This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems. Acceptance testing 验收测试 - This is the final stage in the testing process before the system is accepted for operational use. The system is tested with data supplied by the system customer rather than with simulated test data. Tutorial questionsQ: Giving reasons for your answer based on the type of system being developed, suggest the most appropriate generic software process model that might be used as a basis for managing the development of the following systems. A system to control anti-lock braking in a car A virtual reality system to support software maintenance A university accounting system that replaces an existing system An interactive travel planning system that helps users plan journeys with the lowest environmental impact A: Anti-lock braking system. This is a safety-critical system so requires a lot of up-front analysis before implementation. It certainly needs a plan-driven approach to development with the requirements carefully analysed. A waterfall model is therefore the most appropriate approach to use, perhaps with formal transformations between the different development stages. Virtual reality system. This is a system where the requirements will change and there will be an extensive user interface components. Incremental development with, perhaps, some UI prototyping is the most appropriate model. An agile process may be used. University accounting system. This is a system whose requirements are fairly well-known and which will be used in an environment in conjunction with lots of other systems such as a research grant management system. Therefore, a reuse-based approach is likely to be appropriate for this. Interactive travel planning system. System with a complex user interface. An incremental development approach is the most appropriate as the system requirements will change as real user experience with the system is gained. PS: To be honest, I am quite confused about this reference answer cus NEITHER OF THESE ANSWERS is in the slides. So just have a glance at the answer, it’s common to stuck on these questions. Q: Explain why incremental development is the most effective approach for developing business software systems. Why is this model less appropriate for real-time systems engineering?A: Business software systems usually complex, software intensive, and frequently being changes when business goals or processes are changed. So incremental development is better. 业务目标或过程发生变化时经常发生变化。所以增量开发更好。Real-time systems usually involve many hardware components which are not easy to change and cannot be incremental. Also real-time systems usually safety critical which needed be built based on well planned process. 实时系统通常包含许多硬件组件，这些硬件组件不容易更改，也不能增量。此外，实时系统通常是安全的关键，需要建立在良好的计划过程。 Q: Consider the reuse-based process model. Explain why it is essential to have two separate requirements engineering activities in the process.A:In a reuse based process, you need two requirements engineering activities because it is essential to adapt the system requirements according to the capabilities of the system/components to be reused. These activities are: An initial activity where you understand the function of the system and set out broad requirements for what the system should do. These should be expressed in sufficient detail that you can use them as a basis for deciding of a system/component satisfies some of the requirements and so can be reused. 一个初步的活动，在这个活动中，您了解系统的功能，并为系统应该做什么设定广泛的需求。这些应该以足够详细的方式表达，以便您可以将它们作为决定系统/组件是否满足某些需求的基础，从而可以重用。 Once systems/components have been selected, you need a more detailed requirements engineering activity to check that the features of the reused software meet the business needs and to identify changes and additions that are required. 一旦选择了系统/组件，您需要一个更详细的需求工程活动来检查重用软件的特性是否满足业务需求，并确定所需的更改和添加。 Q: Suggest why it is important to make a distinction between developing the user requirements and developing system requirements in the requirements engineering process.A:There is a fundamental difference between the user and the system requirements that mean they should be considered separately. The user requirements are intended to describe the system’s functions and features from a user perspective and it is essential that users understand these requirements. They should be expressed in natural language and may not be expressed in great detail, to allow some implementation flexibility. The people involved in the process must be able to understand the user’s environment and application domain. 用户需求旨在从用户的角度描述系统的功能和特性，用户理解这些需求是至关重要的。总的来说就是用户没有方法表达的太清楚，需要开发人员理解用户的需求。 The system requirements are much more detailed than the user requirements and are intended to be a precise specification of the system that may be part of a system contract. They may also be used in situations where development is outsourced and the development team need a complete specification of what should be developed. The system requirements are developed after user requirements have been established. 系统需求要比用户需求详细得多，并且要成为系统合同的一部分的系统的精确规范。当开发被外包，并且开发团队需要一个完整的关于应该开发什么的规范时，也可以使用它们。系统需求是在建立用户需求之后开发的。 References XJTLU MC PowerPoint Slides (CPT203 Week2 Lecture2)","link":"/2021/09/20/CPT203-W2/"},{"title":"CAN201 W2","text":"This is the note of CAN201(introduction to networking). This lecture is mainly discussing about Application Layer. 应用程序层 Principle of network application Web application Email The lab of this week is about Introduction of Python. LectureRich network applications Communication: Email, IM, SNS Web: countless Internet games: countless Video based: TikTok VoIP / Meeting: Zoom P2P file sharing: BitTorrent, Thunder… Architectures for applications Client-server peer to peer 所有的applications都是这两个架构 Client-server architecture Server Always-on host 不间断的主机 Permanent IP address 永久ip地址 High performance 高性能 / Distributed computing Clients Link to the server for service 连接服务器进行服务 May be intermittently connect to the internet 可能是间歇性连接到互联网 Dynamic IP address 动态ip地址 Do not communicate directly with each other P2P architecture No always-on server is needed Arbitrary end systems directly exchange data Peers request service from other peers, provide service in return to other peers Self scalability new peers bring new service capacity, as well as new service demands Peers are intermittently connected Dynamic IP addresses How to communicate over the network?Host –&gt; Sockets 插座 –&gt; NetworkA program with: identifier protocol.IP地址标记主机，port标记主机里的进程。 Host - Program process: a program running within a host processes in different / same hosts: socket can be used to exchange messages Processes in the same host: Inter-process communication defined by OS CS architecture: Client process: initiates communication Server process: waits to be contacted P2P architecture: client process / server process on the same host Addressing processes Host device has unique 32-bit IPv4 and/or 128-bit IPv6 Process network identifier: IPv4:port 192.168.1.100:80 [IPv6]:port [240e:3a1:4cb1:69d0:f40c:4269:74a2:7ea3]:80 App-layer protocol defines Types of messages exchanged request, response Message syntax what fields in messages &amp; how fields are delineated Message semantics: meaning of information in fields Message timing: when and how 一共两种协议Open protocols: 公开协议 Defined in RFCs Allows for interoperability e.g., HTTP, SMTP, FTP Closed protocols: 私有协议 e.g., Skype, Games, you own protocols… Transport service requirementsThere’re 4 requirements in transport service: 必须遵守 (应用协议) data integrity throughput timing security Internet transport protocols services (传输层协议) TCP 传输控制协议 UDP 用户数据报协议 TCP service Reliable transport between sending and receiving process 发送和接收过程之间的可靠传输 Flow control 流量控制: sender won’t overwhelm receiver 发送方不会淹没接收方 Congestion control 拥塞控制: throttle sender when network overloaded 当网络过载时限制发送者 Does not offer 不提供: timing, minimum throughput guarantee, security 记时，最低吞吐量保证，安全性 Connection-oriented 面向连接: setup required between client and server processes 需要在客户端和服务器进程之间进行设置 Internet transport protocols servicesThe problems with UDP service: unreliable data transfer between sending and recieving process Does not offer: reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup. 不提供: 可靠性,流量控制,拥塞控制,时间,吞吐量保证,安全性或连接设置 Securing TCPSecure Sockets Layer - SSL TCP &amp; UDP No encryption 无加密 Cleartext psws 明文程序状态字 –&gt; Internet SSL Provides encrypted TCP connection 提供加密TCP连接 Data integrity 数据完整性 End-point authentication 端点认证 SSL is at app layer Apps use SSL libraries, that “talk” to TCP SSL socket API Cleartext psw 明文程序状态字 –&gt; encrypted psw –&gt; Internet Web applicationWeb, HTTP and WWW World Wide Web: WWW HTTP: Hypertext Transfer Protocol Web page consists of base HTML-file which includes several referenced objects, addressable by a URL 网页上的每一个对象都通过url进行寻址 HTTP overviewHTTP: hypertext transfer protocol 超文本传输协议 Application layer protocol 应用层协议 Client/server model Client: browser that requests, receives, (using HTTP protocol) and show Web objects (Render) Server: Web server sends (using HTTP protocol) objects in response to requests Uses TCP: Client initiates TCP connection (creates socket) to server, port 80 客户端发起TCP连接到服务器，端口80 Server accepts TCP connection from client 服务器接受来自客户端的TCP连接 HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server) 在浏览器和Web服务器之间交换HTTP消息 TCP connection closed TCP连接关闭 HTTP is “stateless”: server maintains no information about past client requests. HTTP是“无状态的”:服务器不维护关于过去客户端请求的信息。 Protocols that maintain “state” are complex! past history (state) must be maintained. if server/client crashed, their view of “state” may be inconsistent, must be reconciled. 如果服务器/客户端崩溃，他们的“状态”视图可能不一致，必须协调 Non-persistent HTTP 非持久性HTTP At most one object sent over TCP connection 最多一个对象通过TCP连接发送 Downloading multiple objects required multiple connections 下载多个对象需要多个连接 Persistent HTTP 持久HTTP Multiple objects can be sent over single TCP connection between client, server 客户端和服务器之间可以通过单个TCP连接发送多个对象 Non-response time Persistent HTTPNon-persistent HTTP issues Requires 2 RTTs per object 每个对象需要2个rtt OS overhead for each TCP connection 每个TCP连接的操作系统开销 Browsers often open parallel TCP connections to fetch referenced objects 浏览器经常打开并行TCP连接来获取引用的对象 Persistent HTTP issues Server leaves connection open after sending response 服务器在发送响应后保持连接打开 Subsequent HTTP messages between same client/server sent over open connection 在同一个客户端/服务器之间通过开放连接发送的后续HTTP消息 Client sends requests as soon as it encounters a referenced object 客户端一遇到引用对象就发送请求 As little as one RTT for all the referenced objects 对于所有引用的对象，只有一个RTT Persistent HTTP is not perfect HTTP request message Two types of HTTP messages: request, response HTTP 1.x request message: ASCII (human-readable format) general format HTTP 1.1 methodWhat do we need from a web protocol?Get, Create, Modify, Delete —- resource / data / information HTTP 1.0 1.1 Additional methodsGet, Post, Put, Delete, Patch —- Safe MethodsHead, Trace, Options, Connect —- Idempotent Methods 幂等方法 HTTP response status codes Status code appears in 1st line in server-to-client response message. Some sample codes: 200 OK 301 Move Permanently 400 Bad Request 404 Not Found 505 HTTP Version Not Supported User-server state: cookies many web sites use cookie four components: cookie header line of HTTP response message HTTP响应消息的cookie报头行 cookie header line in next HTTP request message 下一个HTTP请求消息中的cookie头行 cookie file kept on user’s host, managed by user’s browser cookie文件保存在用户的主机上，由用户的浏览器管理 back-end database at web site 网站的后端数据库 Example:Bob always access Internet from PC and visits Taobao site for first time. When initial HTTP requests arrives at site, site creates: unique ID –&gt; cookie, entry in backend database for ID. cookiesWhat cookies can be used for: cookies可以用来做什么 authorization 授权 shopping carts 购物车 recommendations 建议 user session state 用户会话状态 How to keep “state”: Protocol endpoints: maintain state at sender/receiver over multiple transactions 协议端点:在多个事务中维护发送方/接收方的状态 Cookies: http messages http消息 Cookies and privacy: cookies permit sites to learn a lot about you; remember to clean your cookies. Cookies允许网站了解更多关于你的信息。 Web Caches web缓存(Proxy server代理服务器)Goal: satisfy client request without involving origin server 满足客户端请求而不涉及原始服务器 User sets browser: Web accesses via cache 用户设置浏览器:通过缓存访问Web Browser sends all HTTP requests to cache 浏览器将所有HTTP请求发送到缓存 object in cache: cache returns object 缓存返回对象 else cache requests object from origin server, then returns object to client 从源服务器缓存请求对象，然后返回对象给客户端 Cache acts as both client and server 缓存既是客户端也是服务器端 server for original requesting client 服务器为原始请求客户端 client to origin server 客户端到源服务器 Typically cache is installed by ISP (university, company, residential ISP) 缓存通常由ISP安装 Why web caching? reduce response time for client request 减少客户的要求的反应时间 reduce traffic on an institution’s access link 减少机构访问链接的流量 internet dense with caches: enable “poor” content provides to effectively deliver content (so too does P2P file sharing) 使“糟糕的”内容提供商能够有效地传递内容 cache exampleAssumptions: avg object size: 100K bits avg request rate from browsers to origin servers: 15/sec avg data rate to browsers: 1.50 Mbps 100k*15 RTT from institutional router to any origin server: 2 sec access link rate: 1.54 Mbps Consequences: LAN utilization: 0.15% access link utilization = 99% 1.50/1.54 无限拥塞，以分钟做为单位 total delay = Internet delay + access delay + LAN delay = 2 sec + minutes + usecs conditional GET Goal: don’t send object if cache has up-to-date cached version no object transmission delay lower link utilization cache: specify date of cahced copy in HTTP request If-modified-since: server response contains no object if cached copy is up-to-date: HTTP/1.0 304 Not Modified EmailHow Email Works: A user (Alice) sends an email message and connects to an SMTP (Simple Mail Transfer Protocol) server as configured in her email client or Mail User Agent (MUA). 用户发送电子邮件消息并连接SMTP服务器配置在她的电子邮件客户端或邮件用户代理。 On the SMTP server, a Mail Transfer Agent (MTA) looks at the recipient address and looks up the domain part of the address to determine its destination. 在SMTP服务器上，邮件传输代理查看收件人地址并查找地址的域部分以确定其目的地。 After querying a Domain Name System (DNS) server for the name of the Mail eXchanger (MX) for the recipient’s domain name… 在DNS服务器上查询收件人域名的Mail exchange名称后 …the SMTP server will send the message to that server via the SMTP protocol. SMTP服务器将通过SMTP协议将消息发送到该服务器。 The receiving server will store the message and make it available to the recipient (Bob), who can access it via web, POP, or IMAP. 接收服务器将存储消息并使其对接收方可用，接收方可以通过web、POP或IMAP访问该消息。 Email ProtocolsComponents: mail user agent 先从mua发送到ms 然后ms发送到另外一个ms ms再送到收件人的mua mail server 邮件服务器 SMTP (protocol) Delivery: SMTP: simple mail transfer protocol[RFC2821, Apr. 2001] Receive: POP3 - Post Office Protocol - Version 3[RFC1939, May 1996] IMAP - Internet Message Access Protocol[RFC3501, Mar. 2003] Exchange ActiveSync – Microsoft’s protocol[from 2002] Lab1234567891011121314151617import re # 为正则表达式引入的re库input_str = input(f'input: ')# 通过正则表达式，提取出两种形式的数字，第一种是整数，第二种是带小数点的数字numbers = re.findall(r&quot;\\d+\\.?\\d*&quot;, input_str)number_list = []location_list = []for number in numbers: if '.' in number: number_list.append(float(number)) else: number_list.append(int(number))number_list.sort()# .sort()方法没有返回值，所以不能直接用print()输出，假如是sorted就可以直接输出print(number_list)for number in number_list: location_list.append([input_str.index(str(number)), len(str(number))])print(location_list) References XJTLU MC PowerPoint slides (CAN201 Week2 Lecture2 &amp; Lab2) 计算机网络 自顶向下方法.原书第6版","link":"/2021/09/17/CAN201-W2/"},{"title":"Python爬虫入门","text":"这学期暑假的时候，打开了Learning mall下载下学期的课件，但是却发现LM并没有批量下载功能，最后只能通过一个一个点击来下载。无疑这是一个体验非常不好的过程。所以想写一个爬虫来下载learning mall的课件和资料。遇到的问题是learning mall是需要登陆才能下载的，登陆无疑是爬虫操作中的一个较难解决的问题。这篇文章会通过爬豆瓣图片的过程和爬learning mall来讲解如何使用Python爬虫解决生活实际问题。 需要准备的工具有: Pycharm, Chrome(安装插件XPath helper) 抓取豆瓣图片爬虫过程分为四步 找到数据 发送地址请求 数据解析 数据保存 目前爬的这个豆瓣页面不需要登陆，但是需要翻页，后面会尝试爬learningmall的课件，那个需要虚拟登陆，但是应该不需要翻页。我们在爬的过程中一定要注意是适度，要是爬的过分可能会导致别人的网页崩溃，就直接进局子了。 找到数据 第一步是先要找到数据，请求URL地址。 第二步是随机大概我们要爬取的一个文件，通过开发者模式打开之后，找到header底下的User-Agent。 我们要通过User-Agent来伪装我们的访问，防止被直接Forbidden 403反爬。 以我的电脑为例: 12url = f'https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=0&amp;sortby=like&amp;size=a&amp;subtype=a'headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36'} 发送地址请求 声明变量response，利用requests库的get提取页面的内容并保存在response中。 声明html_data，把response转换成text格式储存进去。 可以通过print来看一下我们保存的内容是否包含了我们想要抓去的内容。 html_data需要我们用正则表达式来表达: 123response = requests.get(url=url, headers=headers) # 把请求伪装成一般的浏览器html_data = response.textprint(html_data) # 正则 数据解析XPath helper的用法: 打开Chrome 安装XPath helper 打开开发者模式，通过分析html标签，找到我们需要的位置 //表示定位标签，/表示前面标签的下级标签，定位到具体元素的时候用@ 我们获得html_data需要定位哪些内容是我们需要爬取的内容，这是就需要用到XPath helper。 安装parsel库，通过这个库转化html_data的数据类型。 用XPath定位分析html标签，找到我们需要的内容的具体url位置。 把这些具体的二级页面的url储存在href_list里。 对于href_list中的二级页面，我们利用分析一级页面的方法再次分析一次，找到要下载的资源具体的URL链接放入img_list。 这时候我们已经可以打印出来我们需要的图片具体的url了。 12345678910111213selector = parsel.Selector(html_data) # 转换数据类型href_list = selector.xpath('//div[@class=&quot;cover&quot;]/a/@href').getall()print(href_list)for href in href_list: # 发送图片链接的请求 print(f'当前图片页面地址:', href) response_2 = requests.get(url=href, headers=headers).text # 第二次数据解析 解析图片的url地址 selector_2 = parsel.Selector(response_2) img_list = selector_2.xpath('//div/a[@class=&quot;mainphoto&quot;]/img/@src').getall() print(img_list) 数据保存既然所以我们需要的内容都已经保存在img_list里了，因为我们这次下载的是图片，所以就最后的结果放在img文件夹里。 用for循环遍历img_list里的每一个元素。 为了不让程序爬的太快被封，我们加上一段sleep，减缓一下爬取的速度。 通过split分割并用最后一段命名文件名。 保存文件至img文件夹。 12345678for img in img_list: img_data = requests.get(url=img, headers=headers).content # 这里的数据是二进制 所以用content time.sleep(1) # 延时1秒 刚开始是5秒 但是速度太慢了 file_name = img.split('/')[-1] # 准备文件名 通过 / 分割 把分割出来的最后一部分作为文件名 with open('img/' + file_name, mode='wb') as f: f.write(img_data) print('保存成功:', file_name) 实现翻页但是这还没有结束，因为这样的爬虫只能爬到第一页的图片，而我们想要他爬到的所有的图片，所以我们需要添加上翻页的功能。 page2的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=30&amp;sortby=like&amp;size=a&amp;subtype=a page3的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=60&amp;sortby=like&amp;size=a&amp;subtype=a page26的url: https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start=750&amp;sortby=like&amp;size=a&amp;subtype=a 所以估计page1的url就是把30改为0，事实也确实如此，所以我们在整个程序的开头套上一个page作为for循环。爬取的内容一共只有26页，所以我们设置边缘也就是0-750。 1234page_num = 0for page in range(0, 751, 30): # 每30翻一页 一共750页 page_num += 1 print(f'----------正在爬取第{page_num}页----------') 豆瓣爬虫总结这样我们就实现了完整的豆瓣爬图片的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243import time # 延时用的 爬的太快了容易被发现 把别人网站爬塌了就进局子了import requests # 第三方模块 terminal: pip install requestsimport parsel # 第三方模块 terminal: pip install parselpage_num = 0for page in range(0, 751, 30): # 每30翻一页 一共750页 page_num += 1 print(f'----------正在爬取第{page_num}页----------') # 1. 找到数据 请求url地址 url = f'https://movie.douban.com/celebrity/1016673/photos/?type=C&amp;start={page}&amp;sortby=like&amp;size=a&amp;subtype=a' # 随便找到一个图片 开发者模式打开之后找到`header`下的`User-Agent` headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36'} # 2. 发送地址请求 response = requests.get(url=url, headers=headers) # 把请求伪装成一般的浏览器 html_data = response.text # print(html_data) # 正则 # 3. 数据解析 selector = parsel.Selector(html_data) # 转换数据类型 href_list = selector.xpath('//div[@class=&quot;cover&quot;]/a/@href').getall() # print(href_list) for href in href_list: # 发送图片链接的请求 print(f'当前图片页面地址:', href) response_2 = requests.get(url=href, headers=headers).text # 第二次数据解析 解析图片的url地址 selector_2 = parsel.Selector(response_2) img_list = selector_2.xpath('//div/a[@class=&quot;mainphoto&quot;]/img/@src').getall() # print(img_list) for img in img_list: img_data = requests.get(url=img, headers=headers).content # 这里的数据是二进制 所以用content # 4. 数据保存 time.sleep(1) # 延时1秒 刚开始是5秒 但是速度太慢了 file_name = img.split('/')[-1] # 准备文件名 通过 / 分割 把分割出来的最后一部分作为文件名 with open('img/' + file_name, mode='wb') as f: f.write(img_data) print('保存成功:', file_name) 下面将会介绍如何爬取learningmall中的课件和资料。 Learning Mall 爬虫To be continued… References Python爬虫教程入门教程：从零带你采集某度约会吧上全部小姐姐高清图片，爱了嘛？","link":"/2021/09/12/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"title":"CAN201 W1","text":"This is the note of CAN201(introduction to networking). The lecture of W1 is mainly discussing about Internet. What’s the Internet? Network edge and core Network performance Protocol layers and service models Network security 这星期主要是对这学期所要学习的内容大致的介绍，由预习笔记改编完成。The lab of this week is about Python I - IDE and Interpreter. LectureWhat’s the Internet?Many forms: application, hardware, ongoing… How does the Internet work?People access Internet with Wi-Fi, 4G and so on.Medium: optical fiber光纤, metal, radio…Methods: Packet switches 分组交换 Protocols协议: TCP/IP, HTTP, 802.11 Framework: Layered(from global to local): ISO/OSI - 7, IP stack - 5 Protocols协议Protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt.协议定义格式，在网络实体之间发送和接收消息的顺序，以及在消息传输和接收时所采取的动作。Network protocols: Machines rather than humans All communication activity in Internet governed by protocols. 所有互联网上的活动都收到协议的控制。 How to build the Internet world?Infrastructure 基础设施 Communication Channel 沟通渠道 Provided by ISP 由ISP提供 Computing Service Servers or Cloud Provided by institutions or Cloud Service Provider 由机构或云服务提供商提供 Applications A variety of applications with nice GUI 应用程序 Provided by many companies and developers 公司和开发者 StandardsIETF (Internet Engineering Task Force)https://www.ietf.org/This’s their website. Network edge and coreNetwork edge = Host: 主机 Clients: PCs, Mobile phones, Smart Servers: normally hosted in data centers Physical media to access networks: Wired or wireless communication links Network core: Interconnected routers 互联路由器 Network of networks Access networks and physical mediaHow to connect end systems to edge router? 如何连接终端系统到边缘路由器 Residential access nets 住宅 Institutional access networks 机构 Mobile access networks 移动设备 Keep in mind: Bandwidth (bits per second) of access network? 网络的访问带宽 Shared or dedicated? 共享还是专用 Dial-up Internet accessDial-up Internet access is a form of Internet access that uses the facilities of the public switched telephone network (PSTN) to establish a connection to an Internet service provider (ISP) by dialing a telephone number on a conventional telephone line. Dial-up connections use modems to decode audio signals into data to send to a router or computer, and to encode signals from the latter two devices to send to another modem.拨号互联网接入是利用公共电话交换网(PSTN)的设施，通过在传统电话线上拨打电话号码，与互联网服务提供商(ISP)建立连接的互联网接入形式。拨号连接使用调制解调器将音频信号解码成数据发送到路由器或计算机，并将后两个设备发出的信号编码发送到另一个调制解调器。带宽: 56 Kbps Digital subscriber lineaka DSL 数字用户线Telephone line based: to central office DSL Access Multiplexer aka DSLAM data over DSL phone line goes to internet voice over DLS phone line goes to telephone net 带宽: Upstream transmission rate &lt; 2.5 Mbps (typically &lt; 1Mbps) 上行传输速率 Downstream transmission rate &lt; 24 Mbps (typically &lt; 10Mbps) 下行传输速率 ADSL = Asymmetric Digital Subscriber Line 非对称数字用户线路 Access network: cable network (TV net based)接入网:有线网络(基于电视网络)key technology: Frequency division multiplexing (FDM) 频分复用 Different channels transmitted in different frequency bands 不同的信道在不同的频段传输 HFC: hybrid fiber coax 混合光纤同轴电缆 Asymmetric: 30Mbps downstream transmission rate, 2 Mbps upstream transmission rate. 非对称:下行速率为30Mbps，上行速率为2mbps。 Access network: fiber to the home光纤到家 Access network: home network Enterprise access networks (Ethernet)以太网（企业用）Typically used in companies, universities, etc.10 Mbps, 100Mbps, 1Gbps, 10Gbps transmission rates.Today, end systems typically connect into Ethernet switch. 终端系统通常连接到以太网交换机。 Wireless access networksShared wireless access network connects end system to router ,via base station, aka “access point”. 共享无线接入网将终端系统连接到路由器，通过基站，也就是“接入点”。 Physical mediatwisted pairtwo insulated copper wires 双绝缘铜线 category 5:100 Mbps, 1 Gbps Ethernet category 6:10 Gbps coaxial cabletwo concentric copper conductors 两根同心铜导线 bidirectional 双向 broadband: multiple channels on cable 宽带 fiber optic cableglass fiber carrying light pulses, each pulse a bit 玻璃纤维携带光脉冲，每个脉冲一点 high-speed operation: high-speed point-to-point transmission 点对点高速传输 low error rate: repeaters spaced for apart, immune to eletromagnetic noise 中继器间隔，不受电磁噪声影响 radioSignal carried inelectromagnetic spectrum 电磁波谱中携带的信号 No physical “wire” bidirectional 双向Propagation environment effects: 传播环境影响 Reflection Obstruction by objects 物体的阻碍 Interference! 干扰 Radio link types: Wireless LAN (e.g., WiFi) 54 Mbps – 9.6Gbps Wide-area (e.g., cellular) 4G cellular: ~ 100 Mbps 5G cellular: ~ 1Gbps Satellite Kbps to 45Mbps channel (or multiple smaller channels) Starlink ~ 1440Mbps 270 msec end-end delay Network Core Mesh of interconnected routers. 互连路由器的网状结构 Packet-switching: 分组交换 Hosts break application-layer messages into small packets. 主机将应用层消息分解成小数据包 Packages are forwarded from one router to the next, across links on path from source to destination. 包从一个路由器转发到下一个路由器，在从源到目的地的路径上跨越链接 Two key network-core functions Routing: determines source- destination route taken by packets (routing algorithms) 路由:确定数据包采取的源-目的路由。 Forwarding: move packets from router’s input to appropriate router output. 转发:将数据包从路由器的输入端移动到相应的路由器输出端。 Packet Switchingstore-and-forward queueing delay, lossif arrival rate (in bits) to link exceeds transmission rate of link for a period of time: 如果一段时间内到达链路的速率超过了链路的传输速率 packets will queue, wait to be transmmitted on link 报文将排队，等待链路传输 packets can be dropped (lost) if memory (buffer) fills up 如果内存(缓冲区)被填满，包会被丢失 Circuit switching dedicated resources专用资源: no sharing circuit-like (guaranteed) performance 电路性能 Circuit segment is idle if not used by call (no sharing) 如果没有调用，电路段空闲 Commonly used in traditional telephone networks FDM &amp; TDM Packet VS CircuitPacket switching allows more users to use network! 分组交换允许更多的用户使用网络。Is packet switching a “winner?” PS advantages: resource sharing simpler, no call setup PS drawbacks: excessive congestion possible: delay and loss protocols needed for reliable data transfer, congestion control How to provide circuit-like behavior PS? Bandwidth guarantees New methods should be developed Internet: Network of networks End systems connect to Internet via access ISPs (Internet Service Providers) 终端系统通过接入isp(互联网服务提供商)连接到互联网 residential, company and university ISPs Access ISPs in turn must be interconnected. 接入isp也必须相互连接 so that any two hosts can send packets to each other Resulting network of networks is very complex evolution was driven by economics and national policies Q: Given millions of access ISPs, how to connect them to together?Option 1: connect each access ISP to every other access ISPA: connecting each access ISP to each other directly doesn’t scale: O(N2) connections. 将每个访问ISP直接连接到彼此并不具有伸缩性:O(N2)连接。 Option 2: connect each access ISP to one global transit ISP Network performancePackage Loss, Delay and Bandwidth How do loss and delay occur? Four sources of packet delay dproc: nodal processing 节点处理 check bit errors 检查位错 determine output link 确定输出环节 typically &lt; msec dqueue: queueing delay 队列延迟 time waiting at output link for transmission 输出链路等待传输的时间 depends on congestion level of router 取决于路由器的拥塞水平 dtrans: transmission delay L: packet length (bits) R: link bandwidth (bps) dtrans = L/R dprop: propagation delay: d: length of physical link s: propagation speed (~2.9x10^8 m/sec) dprop = d/s dtrans and dprop very different. Queueing delay Packet Loss丢包 Queue (aka buffer) preceding link in buffer has finite capacity 队列前的链接在缓冲区有有限的容量 Packet arriving to full queue dropped (aka lost) 到达队列满的数据包被丢弃 Lost packet may be retransmitted by previous node, by source end system, or not at all 丢失的数据包可以由前一个节点、源端系统重传，或者根本不重传 Throughput吞吐量Definition: rate (bits/time unit) at which bits transferred between sender/receiver 在发送方/接收方之间传输比特的速率Two kinds of throughput: instantaneous瞬时: rate at given point in time 给定时间点的速率 average平均: rate over longer period of time 较长时期内的比率 服务器传送bits到管道里，管道带着fluid以Rsbits/sec速度运行，穿过buffer之后以Rcbits/sec速度运行，最后到达用户处 Internet ScenarioPer-connection end-end throught: min{Rc,Rs,R/10}In practice: Rc or Rs is often bottleneck. Protocol layers and service modelsInternet protocol stack五层结构！！！ ISO/OSI reference model Encapsulation封装Why layering? 为什么要分层 divide complex systems to simple components 把复杂的系统分割成简单的部分 easy to maintenance 易于维护 flexible for updating 可以灵活的升级 Network securityQ: Field of network security how bad guys can attack computer networks how we can defend networks against attacks how to design architectures that are immune to attacks Q: Internet not originally designed with (much) security in mind Original vision: “a group of mutually trusting users attached to a transparent network” Internet protocol designers playing “catch-up” Security considerations in all layers Types Malware恶意软件: virus, worm, spyware 病毒、蠕虫、间谍软件 DDoS: Distributed denial of service attack 分布式拒绝服务攻击 Packet “sniffing” 包嗅探 LabTask: Install Python and PyCharm Build a virtual Python runtime environment using Virtualenv Write a hello world code in a python script file (.py file) in PyCharm Study variables and print in Python – number / string / list / dict Study conditionals in Python Study loops – for and while 这就没必要写了，INT104都学过了。就是打出一个”Hello World”就没有了。 123456def print_hi(name): print(f'Hi, {name}')if __name__ == '__main__': print_hi('Pycharm') References XJTLU MC PowerPoint slides (CAN201 Week1 Lecture1 &amp; Lab1) 计算机网络 自顶向下方法.原书第6版","link":"/2021/09/10/CAN201-W1/"},{"title":"CPT205 W1","text":"This is the note of CPT205(Computer Graphics).包括了Lecture还有Lab的内容，是在预习笔记上增加了一些内容。 The lecture of this week is mainly discussing about Introduction: hardware and software. LectureWhat is Computer graphics?‘Computer Graphics’ is concerned with all aspects of producing pictures or images using a computer. There are three closely related meanings, each representing a different perspective on the same thing. the images that you see on the computer screen the computer code that is used to create the images a mathematical model of the real-world (which is sometimes called the virtual world) When working at the most advanced levels of Computer Graphics, the computer graphics specialist will create a virtual world implement the virtual world in computer code run the code to see life-like images on the computer screen How do the individual subjects relate?Two subjects are at the heart of computer graphics: 2D Computer Graphics 3D Computer Graphics What are the application areas? Display of information Design Simulation and animation User interfaces Hardware and Software Graphics Hardware Input, Processing and Output Devices Framebuffers Pixels and Screen Resolution Graphics Software Techniques (Algorithms, Procedures) Programming Library / API (OpenGL, JOGL and so on) Not our focus: High level Interactive Systems (Maya, Studio Max, Unity, AutoCAD and so on) Graphics devices Input Devices Processing Devices Output Devices In this order! FramebufferWhat is framebuffer?A block of memory, dedicated to graphics output, that holds the contents of what will be displayed. What is pixel?An element of the framebuffer. Framebuffer in memoryIf we want a framebuffer of 640 pixels by 480 pixles.How many bits should we allocate?framebuffer = 640*480 bitsQ: What do more bits get you?A: More values to be stored at each pixel. bit depthNumber of bits allocated per pixel in a buffer. How much memory we allocate to store the color at each pixel?Common Aswer: 32bits RGBA 32 bits perpixel (true colour) 8 bits for red, green, blue and alpha potential for 256 reds, greens and blues total colours: 16,777,216 (more than the eye can distinguish) Data type refresher7 types of data type refresher: bit - a 0 or 1. Can represent 2 unique values. byte - 8 bits or 256 values. word - 32 bits or 4,294,967,296 values. int - 32 bits. float - 32 bits. double - 64 bits. unsigned byte - 8 bits. How much memory is on our graphic card?三种，分别是: 640 * 480, 1024 * 768, 1600 * 1200 640 * 480 * 32 bits = 1,228,800 bytes 1024 * 768 * 32 bits = 3,145,728 bytes 1600 * 1200 * 32 bits = 7,680,000 bytes Framebuffer -&gt; monitorThe values in the framebuffer are converted from a digital (1s and 0s representation, the bits) to an analog signal that goes out to the monitor. This is done automatically (not controlled by your code), and the conversion can be done while writing to the framebuffer. 帧缓冲区中的值被从数字转换为输出到监视器的模拟信号。这是自动完成的，转换可以在写入framebuffer时完成。 Image quility issues Screen resolution Colour Refresh rate Brightness Contrast Sensitivity of display to viewing angle PixelsPixel: The most basic addressable image element in a screen CRT: Colour triad (RGB phosphor dots) LCD: Single colour element Screen resolution: measure of number of pixels on a screen. (m by n) m: Horizontal screen resolution n: Vertical screen resolution Video formats NTSC: 525x480,30f/s, interlaced PAL: 625x480,25f/s, interlaced VGA: 640x480,60f/s, non-interlaced SVGA: 800x600,60f/s, non-interlaced RGB: 3 independent video signals and synchronisation signal, vary in resolution and refresh rate. 3个独立的视频信号和同步信号，不同的分辨率和刷新率。 Raster display 光栅/显像 Cathode Ray Tubes 阴极射线管 (CRTs), most “tube” monitors you might see. Used to be very common, but big and bulky. Liquid Crystal Displays 液晶显示器 (LCDs), there are two types transmissive (laptops, those snazzy new flat panel monitors) and reflective (wrist watches). Cathode ray tubes (CRTs)Strong electrical fields and high voltage. 强电场和高电压 Very good resolution. 非常好的分辨率 Heavy, not flat. 重，不平 Liquid crystal displays (LCDs)Flat 平 Light weight 轻重量 Low power consumption 低能耗 Graphics softwareHow to talk to the hardware?Algorithms, Procedures, Toolkits &amp; Packages(Low Level –&gt; High Level) Programming APIwhich helps to program in labs OpenGL (our focus) JOGL (Open GL for Java) etc. Special purpose softwarenot so important in our module Excel, Mathlab… AutoCAD, Studio Max… LabUnderstand how to create 2D and 3D graphic images using C++ and OpenGL graphics library.我用的是MacOS，所以戏比较多。 安装虚拟机选择的是Parallels，目前使用的是试用版。下载之后点击安装win10，再安装visual studio。 配置第一个OpenGL 解压freeglut至文件夹 Visual Studio打开创建空白文件 (C++) 修改配置 (细节见Lab文件) 点击运行 1234567891011121314151617181920212223242526272829#define FREEGLUT_STATIC // Define a static library for calling functions#include &lt;GL/freeglut.h&gt; // Include the header filevoid renderScene(void) // Function for geometric creation{ // Clear the buffer to the predefined color and depth value glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //Move origin of current user coordinate system to the screen center: similar to a reset operation glLoadIdentity(); glBegin(GL_TRIANGLES); // Start draw TRIANGLE function glVertex3f(-0.5, -0.5, 0.0); // Set coordinates of first vertex glVertex3f(0.5, 0.0, 0.0); // Set coordinates of second vertex glVertex3f(0.0, 0.5, 0.0); // Set coordinates of last vertex glEnd(); // End draw TRIANGLE function glutSwapBuffers(); // Refresh the screen to display the graphics}int main(int argc, char* argv[]) // Standard main function{ glutInit(&amp;argc, (char**)argv); // Initialization // Define display mode: depth buffer, double buffer and RGBA color glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA); glutInitWindowPosition(100, 100); // Define the location of the window glutInitWindowSize(320, 320); // Define the size of the window glutCreateWindow(&quot;Hello OpenGL&quot;); // Create a window called “Hello OpenGL” glutDisplayFunc(renderScene); // Set the first function glutMainLoop(); // Enter the GLUT event processing loop return 0; // Return an integer value} Reference XJTLU MC PowerPoint slides (CPT205 Lecture1 &amp; Lab1)","link":"/2021/09/08/CPT205-W1/"},{"title":"CPT203 W1","text":"This is the note of CPT203 (Software Engineering I). The lecture of W1 is mainly discussing about Intro to Software Engineering. Understand what software engineering is and why it is important. Understand that the development of different types of software systems may require different software engineering techniques. Understand some ethical and professional issues that are important for software engineers. I will add the tutorial to the note later. (if there is a tutorial on Thursday) 本笔记基于预习笔记增加了一些内容。 Chapter 1 is recommended for reference. BasicWhat’s a computer software?Computer software is the product that software professionals build and then support over the long term. It encompasses computer programs and associated documentation that execute within a computer of any size and architecture. Software products may be developed for a particular customer or may be developed for a general market. 计算机软件是软件专业人员构建并长期支持的产品。它包括在任何大小和结构的计算机中执行的计算机程序和相关的文档。软件产品可能是针对特定客户开发的，也可能是针对一般市场开发的。 Why is it important?Hence it affects nearly every aspect of our lives and has become pervasive(无处不在的) in our commerce, our culture, and our everyday activities. 影响人们生活的各个方面… What is software engineering?Software engineering is an engineering discipline (工程学科) that is concerned with all aspects of software production. 软件工程是一门涉及软件生产的各个方面的工程学科。 What is software system? More than a program System that operate throughout the entire organization People, documentation, training, technical support, software evolution Progamming和software development是有很大区别的，program可能就是几行很短的程序，而software development则是很多program的集合，他们在一起构成了一个完整的software。 IntroductionSoftware engineering is essential for the functioning of national and international societies. 不可缺少的。 Software failure &amp; successSoftware engineering is criticized as inadequate for modern software development. 被批评不适合现代软件开发。(wtf哪什么适合?) Two factors of failures increasing demands 增加的需求 low expectations 低期望值 However, we’re still gonna learn these shits.😅 Professional software development Amateur People in business write spreadsheet programs to simplify their jobs scientists and engineers write programs to process their experimental data hobbyists write programs for their own interest and enjoyment Professional vast majority of software development is a professional activity where software is developed for specific business purposes, for inclusion in other devices, or as software products such as information systems, CAD systems, etc. intended for use by someone apart from its developer is usually developed by teams rather than individuals It is maintained and changed throughout its life. Four important attributesFour important attributes that all professional software (课后习题) Maintainability 可维护性 Dependability and security 可靠性和安全性 Efficiency 效率 Acceptability 可接受性 Two kinds of software products Generic software products 通用软件产品 Customized software products 定制软件产品 The distinction between these system product types is becoming increasingly blurred. 两者之间的界限越来越模糊。 Software deterioration软件恶化软件是逻辑的而不是物理的系统元素，所以软件不会磨损。因此软件的故障率曲线应该是如图所示的“理想曲线”的形式，但实际上，在其生命周期内，软件将经历变化。当进行更改时，很可能会引入错误，导致故障率曲线出现如“实际曲线”所示的峰值。 Software engineeringSoftware engineering is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. 软件工程是一门工程学科，它涉及软件生产的各个方面，从系统规范的早期阶段到系统投入使用后的维护。 Engineering discipline工程纪律就是软件工程师工作的纪律规定。 All aspects of software production软件工程不仅仅涉及软件开发的技术过程。它还包括诸如软件项目管理和支持软件生产的工具、方法和理论的开发等活动。 Challenges for developing systemsWhat challenges for heterogeneity, business and social change and trust and security, identify other problems? (课后习题) Developing systems that are energy-efficient. Developing validation techniques for simulation systems Developing systems fro multicultural use Developing systems that can be adapted quickly to new business needs Designing systems for outsourced development Developing systems that are resistant to attack Developing systems that can be adapted and configured by end-users Finding ways of testing, validating and maintaining end-user developed systems Software engineering approachesA software process is a sequence of activities that leads to the production of a software product. 在软件工程中使用的系统方法被称为software process。 Four fundamental activities: Software specification 软件规范 Software development 软件开发 Software validation 软件验证 Software evolution 软件进化 Software engineering diversityDifferent types of systems need different development processes. Software engineering is a systematic approach to the production of software that takes into account practical cost, schedule, and dependability issues, as well as the needs of software customers and producers. 软件工程是软件生产的一种系统方法，考虑实际成本、进度和可靠性问题，以及软件客户和生产商的需求。 How this systematic approach is actually implemented varies dramatically depending on the organization developing the software, the type of software, and the people involved in the development process. 根据软件开发的组织、软件的类型以及参与开发过程的人员的不同，这种系统方法的实际实现方式有很大的不同。 Two major approaches: Sequential 顺序 Iterative 迭代 Software engineering ethics You must also behave in an ethical and morally responsible way if you are to be respected as a professional engineer. 作为一名专业工程师，如果你想受到尊重，你的行为必须符合道德规范和负责任的态度。 You should not use your skills and abilities to behave in a dishonest way or in a way that will bring disrepute to the software engineering profession. 你不应该使用你的技能和能力以一种不诚实的方式行事，或者以一种会给软件工程专业带来声誉的方式行事。 在某些领域，可接受的行为标准不受法律约束，而是受到更模糊的职业责任概念的约束。 Confidentiality 保密 Competence 能力 Intellectual property rights 知识产权 Computer misuse 计算机滥用 References XJTLU MC PowerPoint Slides (CPT203 Week1) SOFTWARE ENGINEERING Ninth Edition –Ian Sommerville","link":"/2021/09/07/CPT203-W1/"},{"title":"INT201 W1","text":"This is the note of INT201(Decision Computation and Language). The lecture of this week is mainly discussing about Preliminaries: principal mathematical ideas necessary to understand the material of the course. 根据预习的笔记修改了一些内容。 Decision, Computation and LanguageThis module is about the theory of computation and answering the question: “What are the fundamental capabilities and limitations of computers?”这个模块是关于计算理论的，并回答这个问题:“计算机的基本能力和局限性是什么?”The central theme: Are the languagues, their membership problems can not be solved (computed) Algorithmically. Lecture 1LanguageFormal languages have the property that there is a precise rule that governs what strings belong to the language.正式语言包括了programming languages, database query languages, various file formats.然而English, Mandarin这种并不是Formal languages. what the module is about notations for representing formal languages. These give us ways to define them precisely ways to build compilers that recognise the languages ways to check whether a string of symbols belongs to a language whether two alternative descriptions of languages are actually the same language tools to analyse languages natural languages (NL): want to recognise valid sentence 自然语言 programming languages (PL): want to recognise valid program 编程语言 Some notations/methods for describing a language (other than explicitly listing it) include finite state automaton 有限状态自动机 regular expressions 正则表达式 context-free grammar 上下文无关语法 pushdown Automation 叠加自动化 Turing machine 图灵机 Observations 语法可以生成毫无意义的句子。 可以生成任意长的句子。 语义可以根据语法来确定，例如由单词“and”组成的子句的逻辑连接。 语法可以扩展到处理从句、副词等。 你不能完全用这种方式定义自然语言句子，但你可以用这种方式定义编程语言。 Stages of compilation lexical analysis: divide sequence of characters into tokens, such as variable names, operators, labels. In a natural language tokens are strings of consecutive letters (easy to recognise!) 将字符序列划分为符号 parsing: identify relationships between tokens 辨别符号之间的关系 code generation: generate object code 集成目标代码 code optimisation 代码优化 lexical analysis 词法分析1pay=salary+(overtimerate*overtime); Break into tokens as follows: 123456789pay=salary+( overtimerate*overtime); 这就是一个把句子拆开成token的过程 Parse Tree Definitions and notationNothing serious, man. Languagesε is nothing and it’s a word. This’s not an empty set. Empty set is a language.A language (or formal language) over alphabet A is a subset of A*.L1L2 ={w1w2: w1 ∈ L1 and w2 ∈ L2}. L1L2是两个集合中的所有元素两两组合之后的集合L* = {w1w2…wn: n ≥ 0 and w1,w2,…wn ∈ L} L*是一个集合元素中任意组合 Lecture 2Deterministic Finite Automata 确定性有限自动机Can be used a model for what happens during lexical analysis — scan program from beginning to end and divide it into tokens. 可以用一个模型来描述词法分析过程中发生的事情——从头到尾扫描程序，并将其划分为标记。Finite automata are used to specify tokens of programming languages. 有限自动机用于指定编程语言的标记。Also used in “model checking”, reasoning about systems with objective of proving they satisfy useful properties. 也用于“模型检验”，即以证明系统满足有用性质为目标的推理。Also used in statistical models for analysing biological and textual sequences. 也用于分析生物和文本序列的统计模型。DFA适用的对象: 任意有限长的字符串 任意无限长的有限字符串组成的列表 DFA适用的匹配模式: 保证某个字符出现次数不多于几次；保证字符串长度不超过多少；保证字符b永远出现在字符a后DFA不适用的匹配模式：如：字符串列表中a开头的字符串数量多于b开头的字符串；字符串回文；有意义的算数表达式 不知道为什么这个让我想到了BST。可能这就是为什么说DFA可以用于”模型验证”。 A deterministic finite automaton (DFA) has 5 components: Q is a finite nonempty set whose members are called states of the automaton; Q是一个有限的非空集，其成员称为自动机的状态; A is a finite nonempty set called the alphabet of the automaton; A是一个有限的非空集被叫做字母表的自动机; φ is a map from Q × A to Q called the transition function of the automaton; φ是一个从Q × a到Q的映射，称为自动机的转移函数; i is a member of Q and is called the initial state; i是Q的一个元素，称为初始状态; T is a nonempty subset of Q whose members are called terminal states or accepting states. T是Q的一个非空子集，其成员称为终端状态或接受状态。 因此，假如Q = {q0,q1,q2}，所以q0是初始状态，唯一的接受状态是q1，也就是说终结状态T是q1。接受语言L(有01子串的串的语言)的自动机A的完整描述是A = ({q0,q1,q2},{0,1},φ,q0,{q1})。φ是转移函数。 State of a machine tells you something about the prefix that has been read so far. If the string is a member of the language of interest, the state reached when the whole string has been scanned will be an accepting state (a member of T ). 机器的状态告诉您有关到目前为止已读取的前缀的一些信息。如果字符串是感兴趣的语言的成员，当整个字符串被扫描时达到的状态将是接受状态。Transition function φ tells you how state should change when an additional letter is read by the DFA转移函数φ告诉你当DFA读取一个额外的字母时状态应该如何变化。DFA常被描述为一个有标记的有向图。 Initially the state is i and if the input word is w = a1a2 …an then, as each letter is read, the state changes and we get q1, q2, . . . , qn defined by 假如w按照要求的顺序输入，state就会根据下面图示进行变化。 转化图的例子右下角的出口箭头和同心圆(concentric circles)都表示终端态input word 110100| symbol | 1 | 1 | 0 | 1 | 0 | 0 || —– | —– | —– | —– | —– | —– | —– || state | i | t | t | t | t | t | 简化If φ is a partial function (not defined for some state/letter pairs), then the DFA rejects an input if it ever encounters such a pair. 如果简化自动机，将不能达到最终态的途径状态去掉，只考虑根据当前状态和这一次扫描的字符能否达到最终态，如果不能就拒绝，这里描述为undefined未定义。This convention often simplifies the definition of a DFA. In the previous example we could use transition table只有cat和dog可以到达最终态，剩下的都被简化掉了。 An important observationAny DFA that uses the convention that an undefined transition leads to a rejection, can be converted to a DFA that uses a total transition function (that is, one that is defined for all combinations of input symbols and states). The convention is useful, but it does not add extra expressive power. 任何使用未定义转换导致拒绝约定的DFA，都可以转换为使用总转换函数(即为所有输入符号和状态组合定义的转换函数)的DFA。这种约定是有用的，但并没有增加额外的表达能力。 Any finite language is accepted by some DFAGeneral rule: i is the initial state. For each prefix p of a word in the list, include state sp with the idea that the machine should be in state sp after p has been read. i是初始状态。对于列表中每个单词的前缀p，包含状态sp，即在读取p之后，机器应该处于状态sp。这和DFA算法的原理是有关系的，DFA的本质是根据初始状态，通过一系列事件转化为另外一种状态的过程。即:state --&gt; event --&gt; state. 确定：状态以及引起状态转换的事件都是可确定的，不存在“意外”。 有穷：状态以及事件的数量都是可穷举的。 练习见CSDN博主「sanmusen_wu」的原创文章: INT201 决策，计算，语言 笔记 References XJTLU MC PowerPoint slides (INT201 Lecture1 &amp; Lecture2) CSDN博主「sanmusen_wu」的原创文章: INT201 决策，计算，语言 笔记","link":"/2021/09/07/INT201-W1/"},{"title":"hexo部署步骤变化","text":"Problem今天写完blog上传的时候，发现原来的GitHub输入用户名再输入密码push的方式没用了，报错如下: 1234567891011remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: unable to access 'https://github.com/chenzhengde/chenzhengde.github.io.git/': The requested URL returned error: 403FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/chenzhengde/Library/Mobile Documents/com~apple~CloudDocs/大三上学期/myblog/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:400:28) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) { code: 128 }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html Solution经过Google发现，原来从8月13日起GitHub不在接受GitHub.com上的Git操作验证账户密码。必须使用基于令牌的身份验证进行操作。没有办法就去生成了一个personal token存放在印象笔记里。然后使用MacOS的钥匙串，进入GitHub所储存的密码，把含有互联网密码的密码全部改成了personal token。现在的上传步骤: Github用户名 Personal token 正常钥匙串密码 References Mac が覚えている GitHub のパスワードをパーソナルアクセストークンに変更する Git password authentication is shutting down","link":"/2021/08/14/hexo%E9%83%A8%E7%BD%B2%E6%AD%A5%E9%AA%A4%E5%8F%98%E5%8C%96/"},{"title":"icarus使用知识","text":"前几天用yilia改subnav，莫名其妙的又把yilia改出问题了，这次干脆直接把主题换掉了，一步到位。不得不说icarus确实是个非常优秀的主题，首先图标就是调用的GitHub上的fontawesome库，再也不用自己调整图标了😅 有空再研究研究图片的设置了。 I. 安装icarusGithub链接: https://github.com/ppoffice/hexo-theme-icarusIcarus网站链接: https://ppoffice.github.io/hexo-theme-icarus/安装过程和教程里写的差不多，但是有的时候会提示node缺少依赖，需要按照要求安装相对应的依赖，就可以解决这个问题。这时候就可以发现多在myblog目录下多了一个_config.icarus.yml文件，这个文件就是负责配置icarus主题的。（这个配置文件的位置和yilia的配置文件不一样，需要注意一下）老版的icarus下载的时候是自带这个文件的，但是新版的（version4.0.0）现在好像没有了，当运行的时候假如检测到没有会自动生成，所以不用担心。 II. _config.icarus.yml配置这个配置文件一般就在myblog下，假如没有的话可以去myblog\\themes\\icarus\\下看有没有_config.yml文件。There’re many kinds of setting in this doc. Most have been explained clearly. variantTwo kinds of variants: “default” &amp; “cyberpunk”. I picked default one cus it’s easier to read and customize. logoThis part is for setting up the logo in the website header. Pic and str are available. headfaviconKeeping the old favicon. Url and pic are both available here. other optionsI didn’t edit other options. Since there’s no need for these options currently. navbarmenuThe horizontal menu on the top of the website. I deleted about button. linksThe GitHub icon on the right-top of web. footerThree icons on the right-bottom of web. articleCode highlight and readtime settings are in this part. I think it’s nice for now, so didn’t edit them. searchNo edit. comment经过考虑选择了Facebook的评论插件，先用用再说。 share用的是sharethis插件。进去之后选择Start with Share Buttons，然后开始自定义按钮并登陆该网站（提醒一下自己使用163邮箱登录的）。最后，从HTML代码段中复制src中的URL地址到分享按钮配置中。 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://platform-api.sharethis.com/js/sharethis.js#property=6113d16f12036d00122e6422&amp;product=inline-share-buttons&quot; async=&quot;async&quot;&gt;&lt;/script&gt; donate有一说一不大好意思开这个功能，先不开吧。 sidebar两边的sidebar都是可以移动的，这样看起来页面会充实一些，不会太空。 widgets这里是页面左右组件，在个人介绍页面上最爽的就是可以通过调用GitHub的fontawesome库，这样可以添加很多subnav的标志。假如设置了gravatar链接，会优先提取邮箱的头像作为avatar，所以那里不要设置邮箱。 plugins &amp; providersNo edit. III. markdown新增加知识icarus主题需要在markdown文件里设置toc: true。这样才可以正常在左侧sidebar显示目录。设置中的categories可以设置文章的分类。顶端设置中 1234567title: icarus使用知识date: 2021-08-11 10:42:54tags: [hexo, icarus, blog]toc: truecategories: [blog note]thumbnail: #侧边栏缩略图cover: #文章封面图","link":"/2021/08/11/icarus%E4%BD%BF%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"title":"flutter运行说明","text":"flutter前端项目库的调用操作，就从0开始呗。其实这个框架还有dart语言都还挺不错的，有时间可以细细的学一下。这种一次性可以开发多个客户端的语言也该还是有很大前景的。 Install Flutter unzip 'the position of package' export PATH=pwd/flutter/bin:$PATH flutter doctor Build Clone repo git clone https://github.com/projectName/projectName.git Run flutter pub get to install dependencies Run flutter pub run build_runner watch to generate code Run flutter run For Flutter newbieA few resources to get you started if this is your first Flutter project:Lab: Write your first Flutter appCookbook: Useful Flutter samplesFor help getting started with Flutter, view our online documentation, which offers tutorials, samples, guidance on mobile development, and a full API reference. Some shitty informationEverything in Flutter is a widget.主页储存在\\lib\\main.dart里，语料卡片在\\lib\\compoents\\ExtentGrid.dart里目前对于页面在手机上的想法是，通过获得设备屏幕的宽度，依照宽度来决定首页的布局，假如屏幕宽度大于500px就使用默认的布局方式，假如小于500px就去掉两边的留白，直接把语料卡片的大小设置为屏幕的大小。通过对已经写过的代码的分析，dart可以使用if, else if, else语句 ReferencesDart Cheat Sheet","link":"/2021/08/03/flutter%E8%BF%90%E8%A1%8C%E8%AF%B4%E6%98%8E/"},{"title":"yilia已知问题和部分解决方案","text":"目前blog出现了一些问题，有的已经解决，在这里有解决的方法，还有一些没有解决需要继续研究。不需要继续研究了，框架已经从yilia换成了icarus。 I. 文章内目录文章内目录自带的颜色很丑，是一种怪异的蓝色，现在已经改成了橘色。大部分相关的设置都可以搜索tooltip搜索到，但是在目录的旁边有一个冒泡的符号颜色一直不能修改，原因是这个符号是一个icon，颜色是自带的，不是加上去的，所以已经把background-image修改成了none。该问题已解决。 II. subnav设置yilia自带的subnav有很多社交网络可以选择，但是我想加一个instagram上去。按照网上的教程已经把svg文件打包成功了，但是在console里调用npm run dev的时候一直报缺少sass错误。安装sass也没有成功。该问题待解决 III. left-col-headerleft-col-header就是在左侧头上上面的那一小块区域。在电脑上的显示大小是300px*180px。图片的设置在/themes/yilia/main.0cf68a.css中，调整background-image后面的url就可以了。但是这个图片在手机端上显示的有重复，还没有得到解决。之前看起来手机端上是使用nav自动调整在窄屏上的适配。该问题待解决 IV. 返回页面顶部按钮原来是可以用的，但是莫名其妙的挂了，现在还不知道为什么。估计是搜索top寻找相关信息。该问题待解决 V. 返回js报错有个litten.me:9005一直在访问，这是个原来编写yilia的xd做的统计功能。导致在chrome的页面上看起来要加载很久。可以在themes\\yilia\\source\\main.0cf68a.js中找到192function，删除掉函数内的内容，就ok了。该问题已解决。 VI. 添加文章置顶功能先安装插件： 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在/themes/*/layout（/_macro）/post.ejs输入： 12345&lt;% if (page.top) { %&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;% } %&gt; 最后在markdown文件的开头top设置中输入数字，数字越大优先级越高。该问题已解决。 VII. 置顶的标签问题打开文章之后左上角会有一个紫色的小置顶标签，看起来有点丑，但是不影响正常使用，还不知道怎么美化。该问题待解决 VIII. aboutme显示问题好像打开网站之后aboutme的显示总是会慢一拍，现在莫名其妙的好了。该问题已解决。","link":"/2021/08/02/yilia%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98%E9%83%A8%E5%88%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"hexo使用说明","text":"这个blog的框架使用的是hexo，themes是下载的yilia，可以从github上免费下载。自己调整了一些配置，主要是记录一下调整的内容和一些代码命令。 I. 下载的链接hexo估计下载的几率比较小，主要是参考了b站上的一个视频教程。但是yilia主题偶尔还是会发生一些错误，需要重新下载并配置：yilia下载链接。 II. 简单代码操作进入root目录: sudo su 后输入password本地调试: hexo clean + hexo g + hexo s推到远端: hexo d 然后输入GitHub的账户和密码创建笔记: hexo n &quot;笔记名称&quot; 然后就可以在/source/_posts目录下找到对应的笔记文件大多数的root代码就是这些，应该可以满足日常的需求。 III. blog的配置在本地的文件中，有两个名字一样的配置文件夹，都叫_config.yml，但是这两个有本质性的区别。myblog目录下的_config.yml调整的是整个网站的配置内容。themes目录下的_config.yml针对的是blog主题的配置，一般来说这个用的多一点。 themes目录下的_config.yml大部分的操作其实这个文件里的注释都已经写的比较清楚了，但是还是有一些需要注意的地方。在这个文件里true表示功能已经打开，false表示功能已经关闭。menu菜单中有一个随笔目前还没有弄懂是做什么的。已经在菜单中添加了归档，可以按照日期检查所有的blog文章。添加了author和subtitle，这两部分内容将显示在主页的头像下面。主页左边栏上的社交网络表示在文件里是subnav，可以在该文件中修改地址，目前还没有想出添加新的社交网络的方法，本来想加一个Instagram上去，但是npm run dev一直显示缺少sass文件，装了半天也没有装上去，好像和node的版本有关系（触及知识盲区）😅 有人知道怎么改的话请告诉我。在subnav里还有一个rss目前还不知道是干什么的，估计和底下的rss有点关系。快速到顶端的功能，目前已关闭，测试的时候是可用的，但是每次过一阵子不管这个按钮就挂了，目前不知道原因。上面的目录功能可以打开，所有文章都会显示目录。头像是avatar，调用的是/yilia/source/assets里面的head.jpeg。同理标签页上的是favicon，图片也保存在这个上面的文件夹里。评论功能还没有研究明白，目前已经关闭，后面可能会开启。打赏功能估计后面也不会开启，没什么卵用。友链目前也关掉了，还没有想好需要什么样的友链加上去，其他有blog的同学可以来一起交流，其实感觉可以吧csdn和leetcode这种网站加上去，我也不太懂。tag的开关默认设置为了打开，因为关闭按钮的颜色被我修改目录颜色的时候不小心给改成了橘色，现在看起来有点丑，所以就一直保存开的状态吧（css源码实在是太多了）。右滑块的背景颜色使用的是BrulyWood到OldLace的渐变，因为没想出来用什么样的背景比较好看，所以只改了个颜色。还有aboutme部分不知道为什么一打开网页的时候会显示brbr标签，需要过一会才会变成正常的排版，手机端可能也是相同情况。 myblog目录下的_config.yml这个文件中主要是关于hexo的配置。我把本地的端口设置为了4001，因为4000经常会被莫名其妙的占用。包括添加了一部分关于jsonContent的设置，这样滑块目录内容才可以正常使用。网站的名字目前是divide÷，因为没有想出更好的名字，就用微信名先代替。deploy里设置的是git的内容，保证每次能推到GitHub的仓库里。 IV. CSS&amp;HTML5的内容这部分内容其实挺多挺杂的，因为hexo框架和yilia本身就带了很多内容，而且格式很乱，非常难以辨别，主要可以使用Chrome浏览器的开发者模式去定位需要修改的模块和内容，再去vscode里搜索直接进行修改，这样会方便一些。","link":"/2021/08/01/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"title":"Markdown的语法知识","text":"这是一篇简单介绍和记录Markdown语法的笔记，参考的一些网上的资料和CSDN的文章。 I. 标题1.使用#表示标题其中#必须在行首，在标题的前面的#越少，标题的字体就越大 （从一个#到五个#都有） 2.使用===或者---表示例如：一级标题用===二级标题用--- II. 分割线使用三个或以上的-或者*表示，且这一行只有符号，注意不要被识别为二级标题即可，例如可以为往中间或者前面加上空格- - -* * * III. 斜体和粗体使用*和**分别表示斜体和粗体，例如：斜体 粗体 斜体+粗体删除线用两个～，例如：～～这是要删除的文字～～删除文字部分失败了，不过感觉用处不大 IV. 超链接和图片超链接和图片的写法类似，图片仅在超链接之间多加了一个!超链接写法分别是：网站写法(Google)图片的例子: V. 无序列表使用-,+,*表示无序列表，前后留一行空白，可以嵌套，例如： 一层 二层 二层 三层 四层 一层 VI. 有序列表使用1. （点后面有个空格）表示有序列表 一层 一层 这一级别的列表没有显示出序号 一层 VII. 文字应用使用&gt;表示，可以有多个&gt;，表示层次更深 the first floor the second flooralthough i used the &gt; in the beginning. this is still the second floor the third floor have a line of space. here is the first floor now VIII. 行内代码块用`表示:行内代码块有一些字符需要转译，使用反斜杠\\进行转译 IX. 代码块使用四个缩进表示代码块，一般使用三个`表示 public static void main(String[] args){ System.out.println(“Hello World”); }上面的代码没有按照要求显示出来，不过底下的已经出来了上面的意义不大，以底下的写法为准下面是有highlight和行数提醒的代码 123public static void main(String[] args){ System.out.println(&quot;Hello World);} X. 表格直接看例子，第二行的---:表示了对齐方式，默认左对齐，还有右对齐和居中|商品|数量|单价||—|—:|:—:||苹果|10|$1||电脑|1|$1000|表格失败了，没有显示出来，需要完善 XI. 流程图主要的语法为 name=&gt;type: describe，其中type主要有以下几种：1.开始和结束：start end2.输入输出：inputoutput3.操作：operation4.条件：condition5.子程序：subroutine语法参考网站：流程图语法参考估计流程图很少用得上 XII. 数学公式使用$表示，其中一个$表示在行内，两个$表示独占一行$$E=mc^2$$支持LaTeX编辑显示，访问MathJax参考更多用法推荐一个数学公式在线编译网站：https://private.codecogs.com/latex/eqneditor.php今天增加了矩阵的写法，假如我们想要在markdown中实现一个矩阵，也需要用Mathjex。 123456$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\\\\\ 4 &amp; 5 &amp; 6 \\\\\\\\ \\end{bmatrix}$$ 上面的代码实现出来的效果👇$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ \\end{bmatrix}$$假如要更换矩阵的括号，需要修改{bmatrix}变成其他的标志符。 XIII. 支持HTML标签1. 段落的缩进例如想要段落的缩进，可以如下：&nbsp;&nbsp;不断行的空白格&nbsp;或 &ensp;&ensp;半方大的空白&ensp;或 &emsp;&emsp;全方大的空白&emsp;或  2. 页面内跳转点我跳转点我跳转的功能这里演示不了，写法如下： &lt;h6 id='anchor'&gt;我是一个锚点&lt;/h6&gt; XIV. 参考文章Markdown语法介绍（详细）","link":"/2021/07/29/markdown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"XJTLU","slug":"XJTLU","link":"/tags/XJTLU/"},{"name":"CAN201","slug":"CAN201","link":"/tags/CAN201/"},{"name":"Lecture","slug":"Lecture","link":"/tags/Lecture/"},{"name":"Lab","slug":"Lab","link":"/tags/Lab/"},{"name":"CAN304","slug":"CAN304","link":"/tags/CAN304/"},{"name":"CPT203","slug":"CPT203","link":"/tags/CPT203/"},{"name":"Tutorial","slug":"Tutorial","link":"/tags/Tutorial/"},{"name":"CPT204","slug":"CPT204","link":"/tags/CPT204/"},{"name":"CPT205","slug":"CPT205","link":"/tags/CPT205/"},{"name":"CPT208","slug":"CPT208","link":"/tags/CPT208/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"CS224n","slug":"CS224n","link":"/tags/CS224n/"},{"name":"ECE551","slug":"ECE551","link":"/tags/ECE551/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"DKU","slug":"DKU","link":"/tags/DKU/"},{"name":"Duke","slug":"Duke","link":"/tags/Duke/"},{"name":"INT201","slug":"INT201","link":"/tags/INT201/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"dart","slug":"dart","link":"/tags/dart/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"yilia","slug":"yilia","link":"/tags/yilia/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"CAN302","slug":"CAN302","link":"/tags/CAN302/"},{"name":"ECE550","slug":"ECE550","link":"/tags/ECE550/"},{"name":"computer system","slug":"computer-system","link":"/tags/computer-system/"}],"categories":[{"name":"XJTLU note","slug":"XJTLU-note","link":"/categories/XJTLU-note/"},{"name":"CAN201","slug":"XJTLU-note/CAN201","link":"/categories/XJTLU-note/CAN201/"},{"name":"CAN304","slug":"XJTLU-note/CAN304","link":"/categories/XJTLU-note/CAN304/"},{"name":"CPT203","slug":"XJTLU-note/CPT203","link":"/categories/XJTLU-note/CPT203/"},{"name":"CPT205","slug":"XJTLU-note/CPT205","link":"/categories/XJTLU-note/CPT205/"},{"name":"INT201","slug":"XJTLU-note/INT201","link":"/categories/XJTLU-note/INT201/"},{"name":"problem solving","slug":"problem-solving","link":"/categories/problem-solving/"},{"name":"SURF note","slug":"SURF-note","link":"/categories/SURF-note/"},{"name":"blog note","slug":"blog-note","link":"/categories/blog-note/"},{"name":"CAN302","slug":"XJTLU-note/CAN302","link":"/categories/XJTLU-note/CAN302/"}]}